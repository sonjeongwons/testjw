package com.cvc.scanner.controller;

import com.cvc.scanner.dto.FileDto;
import com.cvc.scanner.service.V3ScannerService;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.InputStream;
import java.util.Random;

import org.springframework.http.HttpStatus;
import jakarta.validation.Valid;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/scanner")
public class V3ScannerController {

    private static final Logger logger = LoggerFactory.getLogger(V3ScannerController.class);

    @Autowired
    private V3ScannerService v3ScannerService;

    @GetMapping("/simple")
    public ResponseEntity<Map<String, Object>> simpleScan(@RequestHeader("X-CVC-API-KEY") String apiKey, @RequestParam String fileName) {
        logger.info("Simple scan requested. Filename: {}, API Key: {}", fileName, apiKey);
        if (!v3ScannerService.validateApiKey(apiKey)) {
            logger.warn("Unauthorized access attempt with API Key: {}", apiKey);
            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
        }
        return ResponseEntity.ok(v3ScannerService.simpleScan(fileName));
    }

    @GetMapping("/remote")
    public ResponseEntity<Map<String, Object>> remoteScan(@RequestHeader("X-CVC-API-KEY") String apiKey, @RequestParam String fileName) {
        logger.info("Remote scan requested. Filename: {}, API Key: {}", fileName, apiKey);
        if (!v3ScannerService.validateApiKey(apiKey)) {
            logger.warn("Unauthorized access attempt with API Key: {}", apiKey);
            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
        }
        return ResponseEntity.ok(v3ScannerService.remoteScan(fileName));
    }

    @GetMapping("/detail")
    public ResponseEntity<Map<String, Object>> detailScan(@RequestHeader("X-CVC-API-KEY") String apiKey, @RequestParam String fileName) {
        logger.info("Detail scan requested. Filename: {}, API Key: {}", fileName, apiKey);
        if (!v3ScannerService.validateApiKey(apiKey)) {
            logger.warn("Unauthorized access attempt with API Key: {}", apiKey);
            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
        }
        return ResponseEntity.ok(v3ScannerService.detailScan(fileName));
    }

    @PostMapping("/base64-scan")
    public ResponseEntity<FileDto.Response> scanFile(
            @RequestHeader("X-CVC-API-KEY") String apiKey,
            @Valid @RequestBody FileDto.Request fileDtoRequest) {
        logger.info("File scan requested. Filename: {}, API Key: {}", fileDtoRequest.getFileName(), apiKey);
        if (!v3ScannerService.validateApiKey(apiKey)) {
            logger.warn("Unauthorized access attempt with API Key: {}", apiKey);
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                    FileDto.Response.builder()
                            .fileName(fileDtoRequest.getFileName())
                            .returnCode(HttpStatus.UNAUTHORIZED.value())
                            .message("Unauthorized: Invalid API Key")
                            .build()
            );
        }
        FileDto.Response response = v3ScannerService.scanBase64File(fileDtoRequest);
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }

    @PostMapping(value = "/multipart-scan", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<FileDto.Response> scanMultipartFile(
            @RequestHeader("X-CVC-API-KEY") String apiKey,
            @RequestPart("file") MultipartFile file) {

        logger.info("Multipart file scan requested. Filename: {}, API Key: {}", file.getOriginalFilename(), apiKey);
        if (!v3ScannerService.validateApiKey(apiKey)) {
            logger.warn("Unauthorized access attempt with API Key: {}", apiKey);
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
                    FileDto.Response.builder()
                            .fileName(file.getOriginalFilename())
                            .returnCode(HttpStatus.UNAUTHORIZED.value())
                            .message("Unauthorized: Invalid API Key")
                            .build()
            );
        }
        FileDto.Response response = v3ScannerService.scanMultipartFile(file);
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }

}











package com.cvc.scanner.service;

import com.cvc.scanner.dto.FileDto;
import com.ahnlab.v3engine.V3Const;
import com.ahnlab.v3engine.V3Scanner;

import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileOutputStream;
import java.nio.file.Files;
import java.time.Instant;
import java.util.*;


@Service
public class V3ScannerService {

    private static final Logger logger = LoggerFactory.getLogger(V3ScannerService.class);

    @Value("${api.key}")
    private String validApiKey;
    //private static final String VALID_API_KEY = "CVCKEY";

    public boolean validateApiKey(String apiKey) {
        return validApiKey.equals(apiKey);
    }

    public Map<String, Object> simpleScan(String filename) {
        Map<String, Object> result = new HashMap<>();
        int ret = V3Scanner.scanFile(filename);
        result.put("filename", filename);
        result.put("returnCode", ret);
        printScanInfo(filename, ret, null);
        return result;
    }

    public Map<String, Object> remoteScan(String filename) {
        Map<String, Object> result = new HashMap<>();
        Properties prop = new Properties();
        int ret = V3Scanner.remoteScanFile(filename, prop);

        result.put("filename", filename);
        result.put("returnCode", ret);
        result.put("details", prop);
        return result;
    }

    public Map<String, Object> detailScan(String filename) {
        Map<String, Object> result = new HashMap<>();
        Properties prop = new Properties();
        int ret = V3Scanner.scanFile(filename, prop);

        result.put("filename", filename);
        result.put("returnCode", ret);
        result.put("details", prop);
        return result;
    }

    public FileDto.Response scanBase64File(FileDto.Request fileDtoRequest) {
        File tempFile = null;
        try {
            // 파일 디코딩 후 임시파일로 저장
            byte[] fileData = Base64.getDecoder().decode(fileDtoRequest.getFileData());
            String baseDir = "/tmp/"; // 임시 디렉터리로 변경
            String uniqueFileName = "scan_" + UUID.randomUUID() + "_" + Instant.now().toEpochMilli() + "_" + fileDtoRequest.getFileName();
            tempFile = new File(baseDir + File.separator + uniqueFileName);
            String FilePath = tempFile.getAbsolutePath();
            logger.info("tempFile : {}", FilePath);
            Properties prop = new Properties();

            try (FileOutputStream fos = new FileOutputStream(tempFile)) {
                fos.write(fileData);
                fos.flush();
                System.out.println("파일 내용 확인 :  "+ new String(fileData));
            }
            // 파일 스캔 수행
            int ret = V3Scanner.scanFile(FilePath, prop);
            printScanInfo(FilePath, ret, prop);
            return FileDto.Response.builder()
                    .fileName(fileDtoRequest.getFileName())
                    .returnCode(ret)
                    .message(prop.getProperty(V3Const.PROP_KEY_MORE_INFO))
                    .build();
        } catch (Exception e) {
            return FileDto.Response.builder()
                    .fileName(fileDtoRequest.getFileName())
                    .returnCode(-1)
                    .message("File processing failed: " + e.getMessage())
                    .build();
        } finally {
            if (tempFile != null && tempFile.exists()) {
                try {
                    Files.delete(tempFile.toPath());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public FileDto.Response scanMultipartFile(MultipartFile file) {
        File tempFile = null;
        try {
            // 파일 크기 제한 (1GB)
            if (file.getSize() > 1024L * 1024L * 1024L) {
                return FileDto.Response.builder()
                        .fileName(file.getOriginalFilename())
                        .returnCode(-1)
                        .message("File size exceeds the 1GB limit.")
                        .build();
            }

            // 파일 확장자 필터링
            String fileName = file.getOriginalFilename();
            if (isDeniedExtension(fileName)) {
                return FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(-1)
                        .message("Unsupported file type.")
                        .build();
            }
            Properties prop = new Properties();
            logger.info("Processing file on disk.");
            tempFile = Files.createTempFile("scan_", "_" + UUID.randomUUID() + "_" + Instant.now().toEpochMilli() + "_" + fileName).toFile();
            logger.info("tempFile : {}", tempFile.getAbsolutePath());
            file.transferTo(tempFile);

            int ret = V3Scanner.scanFile(tempFile.getAbsolutePath(), prop); // 디스크 기반 검사
            printScanInfo(tempFile.getAbsolutePath(), ret, prop);
            return buildResponse(fileName, ret, prop);

        } catch (Exception e) {
            return FileDto.Response.builder()
                    .fileName(file.getOriginalFilename())
                    .returnCode(-1)
                    .message("File processing failed: " + e.getMessage())
                    .build();
        } finally {
            if (tempFile != null && tempFile.exists()) {
                try {
                    tempFile.delete();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    // 지원되는 파일 확장자 확인
    private boolean isDeniedExtension(String fileName) {
        String[] allowedExtensions = {".exe", ".bat"};
        String lowerFileName = fileName.toLowerCase();
        return Arrays.stream(allowedExtensions).anyMatch(lowerFileName::endsWith);
    }

    // Response 생성 헬퍼 메서드
    private FileDto.Response buildResponse(String fileName, int ret, Properties prop) {
        return FileDto.Response.builder()
                .fileName(fileName)
                .returnCode(ret)
                .message(prop.getProperty(V3Const.PROP_KEY_MORE_INFO, "No additional information."))
                .build();
    }

    static void printScanInfo(String filename, int ret, Properties prop)
    {
        // message
        String msg = "";
        switch (ret)
        {
            case V3Const.RET_AUTH_FAILED	: msg = "인증 실패";
                break;

            case V3Const.RET_CLIENT_TIMEOUT  : msg = "검사 요청 클라이언트 TIMEOUT";
                break;

            case V3Const.RET_NETWORK_ERROR  : msg = "네트워크 장애";
                break;

            case V3Const.RET_CLIENT_FAIL  : msg = "검사 요청 클라이언트 오류";
                break;

            case V3Const.RET_CANNOT_SCAN  : msg = "검사 실패";
                break;

            case V3Const.RET_NO_MALWARE   : msg = "악성코드 없음";
                break;

            case V3Const.RET_MALWARE_FOUND : msg = "악성코드 발견";
                break;

            case V3Const.RET_CLEAN_MODIFY_SUCCESS   : msg = "수정 치료 성공";
                break;

            case V3Const.RET_CLEAN_MODIFY_FAIL      : msg = "수정 치료 실패(삭제 권고)";
                break;

            case V3Const.RET_CLEAN_DEL_SUCCESS      : msg = "삭제 치료 성공";
                break;

            case V3Const.RET_CLEAN_DEL_FAIL      : msg = "삭제 치료 실패(삭제 권고)";
                break;

            case V3Const.RET_CLEAN_DEL_FAIL_BYCONF      : msg = "삭제 치료 실패(검사 서버 옵션)";
                break;

            default: msg = "알수 없음";
                break;
        }

        // 정보 출력
        System.out.println("filename  : " + filename);
        System.out.println("return    : " + ret + " (" + msg + ")");
        if (prop != null)
        {
            System.out.println("date rev  : " + prop.getProperty(V3Const.PROP_KEY_DATE_REV, "N/A"));
            System.out.println("scan time : " + prop.getProperty(V3Const.PROP_KEY_SCAN_DATE_TIME, "N/A"));
            System.out.println("more info : " + prop.getProperty(V3Const.PROP_KEY_MORE_INFO, "N/A"));
            if (ret == V3Const.RET_MALWARE_FOUND)
            {
                System.out.println( " malware : " + prop.getProperty(V3Const.PROP_KEY_MALWARE_NAME, "N/A") );
                System.out.println( "     in  : " + prop.getProperty(V3Const.PROP_KEY_MALWARE_FILE, "N/A") );
            }
            System.out.println(prop);
        }
        System.out.println("");
    }
}
