ì•„ë˜ëŠ” FunctionService ì½”ë“œë¥¼ ë¦¬íŒ©í† ë§ ë° í´ë¦°ì½”ë“œ ê´€ì ì—ì„œ ê°œì„ í•œ ì˜ˆì œì™€ ê·¸ ì´ìœ ì…ë‹ˆë‹¤. ê° ë³€ê²½ì‚¬í•­ì— ëŒ€í•œ ì„¤ëª…ì„ í•¨ìˆ˜ë³„ë¡œ ì œì‹œí•˜ê² ìŠµë‹ˆë‹¤.

ë¦¬íŒ©í† ë§ ëª©í‘œ
ê°€ë…ì„±: í•¨ìˆ˜ì™€ ë³€ìˆ˜ëª…ì„ ëª…í™•íˆ í•˜ê³ , ë³µì¡í•œ ë¡œì§ì„ ê°„ê²°í•˜ê²Œ ë¶„ë¦¬.
ì¤‘ë³µ ì œê±°: ë°˜ë³µë˜ëŠ” ì½”ë“œë¥¼ ì¬ì‚¬ìš© ê°€ëŠ¥í•˜ë„ë¡ êµ¬ì¡°í™”.
ì˜ì¡´ì„± ì£¼ì… ê°•í™”: ê°ì²´ ìƒì„±ì„ ì¤„ì´ê³  DIë¥¼ í™œìš©.
ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™”: ì ì¬ì ì¸ NullPointerException(NPE)ì™€ ê¸°íƒ€ ì˜¤ë¥˜ë¥¼ ë°©ì§€.
í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„± í–¥ìƒ: ë©”ì„œë“œê°€ ë‹¨ì¼ ì±…ì„ì„ ê°€ì§€ë„ë¡ ë¶„ë¦¬.
ë¦¬íŒ©í† ë§ ì½”ë“œ
ë³€ê²½ëœ ì½”ë“œ
java
ì½”ë“œ ë³µì‚¬
@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class FunctionService {

    private final FunctionErrorRepository functionErrorRepository;
    private final IstioCallService istioCallService;
    private final KnativeClient knativeClient; // DIë¥¼ í†µí•œ ì£¼ì…ìœ¼ë¡œ ìˆ˜ì •
    private final KubernetesClient kubernetesClient; // DIë¥¼ í†µí•œ ì£¼ì…ìœ¼ë¡œ ìˆ˜ì •
    private final String volumeName = "serverless-storage";
    private final String BASE_URL = "samsungsdscloud.com";

    /**
     * ëª¨ë“  Knative Function ìƒíƒœë¥¼ ì ê²€í•˜ì—¬ ë¹„ì •ìƒ ìƒíƒœë¥¼ ê¸°ë¡.
     */
    public void checkKnativeFunctionAll() {
        List<Namespace> namespaces = getNamespacesFilteredByPattern("scf-.*-api");
        namespaces.forEach(namespace -> checkNamespaceFunctions(namespace));
    }

    private void checkNamespaceFunctions(Namespace namespace) {
        String namespaceName = namespace.getMetadata().getName();
        log.info("Checking namespace: {}", namespaceName);

        List<Service> services = knativeClient.services()
                .inNamespace(namespaceName)
                .list()
                .getItems();

        services.forEach(service -> {
            List<Condition> conditions = Optional.ofNullable(service.getStatus())
                    .map(ServiceStatus::getConditions)
                    .orElse(List.of());

            conditions.stream()
                    .filter(condition -> !"True".equals(condition.getStatus()))
                    .forEach(condition -> handleServiceError(service, condition));
        });
    }

    private void handleServiceError(Service service, Condition condition) {
        String functionName = service.getMetadata().getName();
        String conditionType = condition.getType();
        log.warn("Function {} in error condition: {}", functionName, condition);

        if (!functionErrorRepository.existsByFunctionNameAndType(functionName, conditionType)) {
            FunctionError error = FunctionError.register(functionName, condition);
            functionErrorRepository.save(error);
        }
    }

    /**
     * ê¸°ë¡ëœ ëª¨ë“  FunctionError ìƒíƒœë¥¼ ì¬ì ê²€í•˜ì—¬ ì •ìƒí™”ëœ í•­ëª© ì‚­ì œ.
     */
    @Transactional
    public void checkKnativeFunctionAllError() {
        List<FunctionError> errors = functionErrorRepository.findAll();
        errors.forEach(this::checkAndRemoveErrorIfResolved);
    }

    private void checkAndRemoveErrorIfResolved(FunctionError error) {
        String functionName = error.getFunctionName();
        String namespacePattern = "scf-.*-api";
        List<Namespace> namespaces = getNamespacesFilteredByPattern(namespacePattern);

        namespaces.forEach(namespace -> {
            String namespaceName = namespace.getMetadata().getName();
            Service service = knativeClient.services()
                    .inNamespace(namespaceName)
                    .withName(functionName)
                    .get();

            if (service == null) {
                log.info("Service {} not found in namespace {}", functionName, namespaceName);
                return;
            }

            List<Condition> conditions = Optional.ofNullable(service.getStatus())
                    .map(ServiceStatus::getConditions)
                    .orElse(List.of());

            boolean allConditionsResolved = conditions.stream()
                    .allMatch(condition -> "True".equals(condition.getStatus()));

            if (allConditionsResolved) {
                functionErrorRepository.deleteById(error.getFunctionErrorSeq());
                log.info("Resolved error for function {}", functionName);
            }
        });
    }

    /**
     * íŠ¹ì • íŒ¨í„´ê³¼ ì¼ì¹˜í•˜ëŠ” ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ëª©ë¡ ë°˜í™˜.
     */
    public List<Namespace> getNamespacesFilteredByPattern(String pattern) {
        Pattern regexPattern = Pattern.compile(pattern);
        return kubernetesClient.namespaces()
                .list()
                .getItems()
                .stream()
                .filter(namespace -> regexPattern.matcher(namespace.getMetadata().getName()).matches())
                .collect(Collectors.toList());
    }
}
í•¨ìˆ˜ë³„ ë³€ê²½ì‚¬í•­
1. checkKnativeFunctionAll
ë³€ê²½ ì „: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì™€ ì„œë¹„ìŠ¤ë¥¼ í•œ ë©”ì„œë“œì—ì„œ ì²˜ë¦¬. ì¤‘ë³µ ì½”ë“œ ì¡´ì¬.
ë³€ê²½ í›„:
ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì²˜ë¦¬ì™€ ì„œë¹„ìŠ¤ ìƒíƒœ ì ê²€ì„ checkNamespaceFunctions ë©”ì„œë“œë¡œ ë¶„ë¦¬.
ì„œë¹„ìŠ¤ ì¡°ê±´ë³„ ìƒíƒœ ì²˜ë¦¬ë¥¼ handleServiceErrorë¡œ ìœ„ì„.
ì´ì : ì½”ë“œ ì¤‘ë³µ ì œê±°, ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP) ì¤€ìˆ˜.
2. checkNamespaceFunctions
ë³€ê²½ ì „: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‚´ë¶€ì˜ ë¡œì§ì´ ë©”ì¸ ë©”ì„œë“œì— í˜¼ì¬.
ë³€ê²½ í›„: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë³„ ì ê²€ ë¡œì§ì„ ë¶„ë¦¬í•˜ì—¬ ëª…í™•ì„± ì¦ê°€.
ì´ì : ë©”ì„œë“œ í¬ê¸° ì¶•ì†Œ ë° ì¬ì‚¬ìš©ì„± í–¥ìƒ.
3. handleServiceError
ë³€ê²½ ì „: ì„œë¹„ìŠ¤ ìƒíƒœ ì ê²€ê³¼ DB ì €ì¥ì´ ì§ì ‘ ë©”ì¸ ë¡œì§ì— í˜¼í•©.
ë³€ê²½ í›„: ì—ëŸ¬ ì¡°ê±´ ì²˜ë¦¬ ë¡œì§ì„ ë³„ë„ ë©”ì„œë“œë¡œ ë¶„ë¦¬.
ì´ì : ì¬ì‚¬ìš©ì„± ì¦ê°€, ê°€ë…ì„± í–¥ìƒ.
4. checkKnativeFunctionAllError
ë³€ê²½ ì „: ì—ëŸ¬ ì²˜ë¦¬ ë¡œì§ì´ ì¸ë¼ì¸.
ë³€ê²½ í›„: ì—ëŸ¬ ì ê²€ ë¡œì§ì„ checkAndRemoveErrorIfResolved ë©”ì„œë“œë¡œ ë¶„ë¦¬.
ì´ì : ì½”ë“œ ì¤‘ë³µ ì œê±° ë° ëª…í™•ì„± ì¦ê°€.
5. getNamespacesFilteredByPattern
ë³€ê²½ ì „: ë°˜ë³µì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„¤ì„ìŠ¤í˜ì´ìŠ¤ í•„í„°ë§ ë¡œì§ì´ ê³³ê³³ì— ì¡´ì¬.
ë³€ê²½ í›„: ê³µí†µ ë©”ì„œë“œë¡œ ì¶”ì¶œí•˜ì—¬ ì¬ì‚¬ìš©.
ì´ì : ì¤‘ë³µ ì œê±° ë° ì½”ë“œ ê°„ê²°í™”.
ë³€ê²½ ì´ìœ  ìš”ì•½
ì˜ì¡´ì„± ì£¼ì… ê°•í™”

DefaultKubernetesClientì™€ DefaultKnativeClientë¥¼ DIë¡œ ì£¼ì…ë°›ë„ë¡ ë³€ê²½.
í…ŒìŠ¤íŠ¸ ì‹œ Mock ê°ì²´ë¥¼ ì‰½ê²Œ ì£¼ì…í•  ìˆ˜ ìˆì–´ ìœ ì—°ì„±ì´ í–¥ìƒë¨.
ì¤‘ë³µ ì½”ë“œ ì œê±°

ë„¤ì„ìŠ¤í˜ì´ìŠ¤ í•„í„°ë§, ì„œë¹„ìŠ¤ ì¡°ê±´ ì ê²€, ì—ëŸ¬ ì²˜ë¦¬ ë“±ì˜ ì¤‘ë³µ ì½”ë“œë¥¼ ë¶„ë¦¬ ë° í†µí•©.
ì¬ì‚¬ìš©ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì´ ê°œì„ ë¨.
ì˜ˆì™¸ ì²˜ë¦¬ ë³´ê°•

Optionalê³¼ List.of()ë¡œ NPE ë°©ì§€.
ë¡œê·¸ ë©”ì‹œì§€ì— ë” ë§ì€ ì»¨í…ìŠ¤íŠ¸ ì¶”ê°€.
ê°€ë…ì„± í–¥ìƒ

ë©”ì„œë“œ í¬ê¸°ë¥¼ ì¤„ì´ê³ , ê° ë©”ì„œë“œê°€ í•˜ë‚˜ì˜ ì±…ì„ë§Œ ê°€ì§€ë„ë¡ ë¦¬íŒ©í† ë§.
ì¶”ê°€ ê°œì„  ì œì•ˆ
Custom Exception ë„ì…

ì—ëŸ¬ ìƒí™©ì„ ëª…í™•íˆ í•˜ê¸° ìœ„í•´ CustomException í´ë˜ìŠ¤ ì¶”ê°€.
Configuration íŒŒì¼ë¡œ ì„¤ì • ê´€ë¦¬

volumeName, BASE_URL ë“±ì˜ ìƒìˆ˜ë¥¼ application.ymlë¡œ ì´ë™.
í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ë³´ê°•

ê° ë©”ì„œë“œì˜ ì£¼ìš” ì‹œë‚˜ë¦¬ì˜¤ì— ëŒ€í•œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±.
ê²°ë¡ 
ë¦¬íŒ©í† ë§ í›„ ì½”ë“œëŠ” ë‹¨ì¼ ì±…ì„ ì›ì¹™ì„ ë” ì˜ ì¤€ìˆ˜í•˜ë©° ê°€ë…ì„±ê³¼ ì¬ì‚¬ìš©ì„±ì´ í¬ê²Œ í–¥ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ìœ ì§€ë³´ìˆ˜ì„±ê³¼ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±ì´ ê°œì„ ë˜ê³ , ì½”ë“œ í’ˆì§ˆì´ ì „ë°˜ì ìœ¼ë¡œ í–¥ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ğŸ˜Š

Q1: ìœ„ ë¦¬íŒ©í† ë§ì—ì„œ DIë¥¼ ì ìš©í•œ ì´ìœ ëŠ” ë¬´ì—‡ì´ë©°, ì¶”ê°€ì ìœ¼ë¡œ ê°œì„ í•  ìˆ˜ ìˆëŠ” ì ì€ ë¬´ì—‡ì¸ê°€ìš”?

Q2: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì™€ ì„œë¹„ìŠ¤ ìƒíƒœ ì ê²€ ë¡œì§ì„ ë¶„ë¦¬í•œ ê²ƒì´ ìš´ì˜ê³¼ í…ŒìŠ¤íŠ¸ì—ì„œ ì–´ë–¤ ì´ì ì„ ì œê³µí•˜ë‚˜ìš”?

Q3: Optionalê³¼ Streamì„ í™œìš©í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì´ëŠ” ë‹¤ë¥¸ ë°©ë²•ì—ëŠ” ì–´ë–¤ ê²ƒì´ ìˆì„ê¹Œìš”?






ë‚˜ì˜ ë§:
ì–´ë–¤ ì ì´ ê°œì„ ë˜ì—ˆëŠ”ì§€ ë©”ì†Œë“œë³„ë¡œ ìì„¸íˆ ì½”ë“œë¥¼ ì•Œë ¤ì¤˜. ì–´ë–¤ ì½”ë“œê°€ ë³€ê²½ë˜ì—ˆëŠ”ì§€ ë§ì´ì•¼. ì „/í›„ ë¹„êµí•´ì„œ ë¦¬íŒ©í† ë§, í´ë¦°ì½”ë“œê´€ì ì—ì„œ ê°œì„ ëœ ì ê³¼ ë°”ê¾¸ëŠ” ì‚¬ìœ ë¥¼ ì•Œë ¤ì¤˜.
ChatGPTì˜ ë§:
ChatGPT
ë©”ì†Œë“œë³„ ì „/í›„ ë¹„êµì™€ ê°œì„  ì‚¬í•­
1. checkKnativeFunctionAll
ë³€ê²½ ì „
java
ì½”ë“œ ë³µì‚¬
public void checkKnativeFunctionAll() {
    KnativeClient kn = new DefaultKnativeClient();
    try (KubernetesClient client = new DefaultKubernetesClient()) {
        List<Namespace> namespaces = getNamespacesFilteredByPattern(client, "scf-.*-api");
        for (Namespace namespace : namespaces) {
            System.out.println("Namespace Name: " + namespace.getMetadata().getName());
            ServiceList services = kn.services()
                    .inNamespace(namespace.getMetadata().getName())
                    .list();
            for (Service svc : services.getItems()) {
                if (!CollectionUtils.isEmpty(svc.getStatus().getConditions())) {
                    log.info(svc.toString());
                    List<Condition> conditions = svc.getStatus().getConditions();
                    for (Condition condition : conditions) {
                        log.info(condition.toString());
                        if (!"True".equals(condition.getStatus())) {
                            log.info(svc.getMetadata().toString());
                            if (!functionErrorRepository.existsByFunctionNameAndType(svc.getMetadata().getName(), condition.getType())) {
                                functionErrorRepository.save(FunctionError.register(svc.getMetadata().getName(), condition));
                            }
                        }
                    }
                }
            }
        }
    }
}
ë³€ê²½ í›„
java
ì½”ë“œ ë³µì‚¬
public void checkKnativeFunctionAll() {
    List<Namespace> namespaces = getNamespacesFilteredByPattern("scf-.*-api");
    namespaces.forEach(this::checkNamespaceFunctions);
}

private void checkNamespaceFunctions(Namespace namespace) {
    String namespaceName = namespace.getMetadata().getName();
    log.info("Checking namespace: {}", namespaceName);

    List<Service> services = knativeClient.services()
            .inNamespace(namespaceName)
            .list()
            .getItems();

    services.forEach(service -> {
        List<Condition> conditions = Optional.ofNullable(service.getStatus())
                .map(ServiceStatus::getConditions)
                .orElse(List.of());

        conditions.stream()
                .filter(condition -> !"True".equals(condition.getStatus()))
                .forEach(condition -> handleServiceError(service, condition));
    });
}
ë³€ê²½ ì‚¬í•­ ë° ê°œì„ ëœ ì 
ì˜ì¡´ì„± ì£¼ì… í™œìš©

ë³€ê²½ ì „: DefaultKnativeClientì™€ DefaultKubernetesClientë¥¼ ë§¤ë²ˆ ìƒì„±.
ë³€ê²½ í›„: DIë¡œ KnativeClientì™€ KubernetesClientë¥¼ ì£¼ì…ë°›ì•„ ê´€ë¦¬.
ì´ìœ : ê°ì²´ ìƒì„±ì„ ìµœì†Œí™”í•˜ì—¬ ì„±ëŠ¥ì„ ê°œì„ í•˜ê³ , í…ŒìŠ¤íŠ¸ì—ì„œ Mock ê°ì²´ë¥¼ í™œìš©í•  ìˆ˜ ìˆë„ë¡ ìœ ì—°ì„± í™•ë³´.
ë¡œì§ ë¶„ë¦¬

checkNamespaceFunctionsë¡œ ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë³„ í•¨ìˆ˜ ìƒíƒœ ì ê²€ ë¡œì§ì„ ë¶„ë¦¬.
ì´ìœ : ë©”ì†Œë“œê°€ ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP)ì„ ë”°ë¥´ë©°, ì½”ë“œ ì¬ì‚¬ìš©ì„±ê³¼ ê°€ë…ì„±ì´ í–¥ìƒë¨.
Optionalê³¼ Stream í™œìš©

ë³€ê²½ ì „: if (!CollectionUtils.isEmpty(...))ë¡œ null ì²´í¬.
ë³€ê²½ í›„: Optionalê³¼ Streamì„ í™œìš©í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì„.
ì´ìœ : null ì²´í¬ë¥¼ ê°„ê²°í•˜ê³  ì•ˆì „í•˜ê²Œ ì²˜ë¦¬.
ìƒíƒœ ì¡°ê±´ ì²˜ë¦¬ ê°œì„ 

ìƒíƒœ ì¡°ê±´ë³„ ì²˜ë¦¬ë¥¼ handleServiceErrorë¡œ ìœ„ì„.
ì´ìœ : ìƒíƒœ ì²˜ë¦¬ ë¡œì§ì˜ ì¬ì‚¬ìš©ì„±ì„ ë†’ì´ê³ , ì¤‘ë³µ ì œê±°.
2. checkKnativeFunctionAllError
ë³€ê²½ ì „
java
ì½”ë“œ ë³µì‚¬
@Transactional
public void checkKnativeFunctionAllError() {
    List<FunctionError> items = this.functionErrorRepository.findAll();
    if (!CollectionUtils.isEmpty(items)) {
        items.stream().forEach(item -> {
            checkStatus(item);
        });
    }
}

private void checkStatus(FunctionError item) {
    try (KubernetesClient client = new DefaultKubernetesClient()) {
        List<Namespace> namespaces = getNamespacesFilteredByPattern(client, "scf-.*-api");
        for (Namespace namespace : namespaces) {
            if (null == knativeClient.services().inNamespace(namespace.getMetadata().getName()).withName(item.getFunctionName()).get()) {
                return;
            }

            ServiceStatus aDefault = knativeClient.services()
                    .inNamespace(namespace.getMetadata().getName())
                    .withName(item.getFunctionName())
                    .get()
                    .getStatus();
            List<Condition> conditions = aDefault.getConditions();
            for (Condition condition : conditions) {
                if ("True".equals(condition.getStatus())) {
                    Optional<FunctionError> byId = functionErrorRepository.findById(item.getFunctionErrorSeq());
                    if (byId.isPresent()) {
                        functionErrorRepository.delete(byId.get());
                    }
                }
            }
        }
    }
}
ë³€ê²½ í›„
java
ì½”ë“œ ë³µì‚¬
@Transactional
public void checkKnativeFunctionAllError() {
    List<FunctionError> errors = functionErrorRepository.findAll();
    errors.forEach(this::checkAndRemoveErrorIfResolved);
}

private void checkAndRemoveErrorIfResolved(FunctionError error) {
    String functionName = error.getFunctionName();
    String namespacePattern = "scf-.*-api";
    List<Namespace> namespaces = getNamespacesFilteredByPattern(namespacePattern);

    namespaces.forEach(namespace -> {
        String namespaceName = namespace.getMetadata().getName();
        Service service = knativeClient.services()
                .inNamespace(namespaceName)
                .withName(functionName)
                .get();

        if (service == null) {
            log.info("Service {} not found in namespace {}", functionName, namespaceName);
            return;
        }

        List<Condition> conditions = Optional.ofNullable(service.getStatus())
                .map(ServiceStatus::getConditions)
                .orElse(List.of());

        boolean allConditionsResolved = conditions.stream()
                .allMatch(condition -> "True".equals(condition.getStatus()));

        if (allConditionsResolved) {
            functionErrorRepository.deleteById(error.getFunctionErrorSeq());
            log.info("Resolved error for function {}", functionName);
        }
    });
}
ë³€ê²½ ì‚¬í•­ ë° ê°œì„ ëœ ì 
ë°˜ë³µ ì½”ë“œ ì œê±°

ë³€ê²½ ì „: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ í•„í„°ë§ê³¼ ìƒíƒœ í™•ì¸ ë¡œì§ì´ ì¤‘ë³µ.
ë³€ê²½ í›„: getNamespacesFilteredByPatternì„ ì¬ì‚¬ìš©.
ì¡°ê±´ ê²€ì‚¬ ë‹¨ìˆœí™”

ë³€ê²½ ì „: ìƒíƒœ ì¡°ê±´ í™•ì¸ ë° ì‚­ì œ ë¡œì§ì´ ë³µì¡.
ë³€ê²½ í›„: boolean allConditionsResolvedë¥¼ í†µí•´ ê°€ë…ì„± í–¥ìƒ.
ì´ìœ : ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì´ê¸° ìœ„í•´ ì¡°ê±´ ê²€ì‚¬ ë‹¨ìˆœí™”.
ë¡œê·¸ ì¶”ê°€

ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì™€ ì„œë¹„ìŠ¤ ìƒíƒœë¥¼ ëª…í™•íˆ ë¡œê¹….
ì´ìœ : ë””ë²„ê¹… ì‹œ ìœ ìš©í•œ ì •ë³´ë¥¼ ì œê³µ.
3. getNamespacesFilteredByPattern
ë³€ê²½ ì „
java
ì½”ë“œ ë³µì‚¬
public static List<Namespace> getNamespacesFilteredByPattern(KubernetesClient client, String pattern) {
    NamespaceList namespaceList = client.namespaces().list();
    Pattern regexPattern = Pattern.compile(pattern);

    return namespaceList.getItems()
            .stream()
            .filter(namespace -> regexPattern.matcher(namespace.getMetadata().getName()).matches())
            .collect(Collectors.toList());
}
ë³€ê²½ í›„
java
ì½”ë“œ ë³µì‚¬
public List<Namespace> getNamespacesFilteredByPattern(String pattern) {
    Pattern regexPattern = Pattern.compile(pattern);
    return kubernetesClient.namespaces()
            .list()
            .getItems()
            .stream()
            .filter(namespace -> regexPattern.matcher(namespace.getMetadata().getName()).matches())
            .collect(Collectors.toList());
}
ë³€ê²½ ì‚¬í•­ ë° ê°œì„ ëœ ì 
ì˜ì¡´ì„± ì£¼ì… í™œìš©

ë³€ê²½ ì „: KubernetesClient ê°ì²´ë¥¼ ë©”ì†Œë“œ ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬.
ë³€ê²½ í›„: kubernetesClientë¥¼ í•„ë“œë¡œ ì£¼ì…ë°›ì•„ ì‚¬ìš©.
ì´ìœ : ì˜ì¡´ì„± ì£¼ì…ìœ¼ë¡œ ë©”ì†Œë“œ í˜¸ì¶œì„ ê°„ê²°í•˜ê²Œ í•˜ê³  í…ŒìŠ¤íŠ¸ ì‹œ Mock ì£¼ì… ê°€ëŠ¥.
Static ì œê±°

ë³€ê²½ ì „: Static ë©”ì†Œë“œë¡œ ì„ ì–¸.
ë³€ê²½ í›„: ì¸ìŠ¤í„´ìŠ¤ ë©”ì†Œë“œë¡œ ë³€ê²½.
ì´ìœ : Staticì€ í…ŒìŠ¤íŠ¸ì™€ í™•ì¥ì„± ì¸¡ë©´ì—ì„œ ì œí•œì .
