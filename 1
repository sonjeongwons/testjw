package com.scf.manager.mvc.service;


import com.google.gson.Gson;
import com.scf.manager.mvc.domain.Function;
import com.scf.manager.mvc.dto.*;
import com.scf.manager.mvc.repository.FunctionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Value;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class FunctionMetricService {

    @Value("${monitoring.http.timeout}")
    private int timeOutValue;

    public static final String METRIC_TIME_RANGE_1_HOUR = "1";
    public static final String METRIC_TIME_RANGE_3_HOUR = "3";
    public static final String METRIC_TIME_RANGE_12_HOUR = "12";

    public static final String METRIC_TIME_UNIT_15M = "15";
    public static final String METRIC_TIME_UNIT_30M = "30";
    public static final String METRIC_TIME_UNIT_180M = "180";
    public static final String METRIC_TIME_UNIT_1440M = "1440";

    @Value("${monitoring.prometheus.prometheusHttpApi}")
    private String prometheusHttpApi;

    private final FunctionRepository functionRepository;

    public String generateQueryForRequestCount(String functionName, String timeRange, String queryTiming) throws IOException {
        return "query=sum(rate(activator_request_count{service_name=\"" + functionName + "\"}[" + timeRange + "m]))*60*" + timeRange + "&time=" + queryTiming;
    }
    public String generateQueryForRequestLatency(String functionName, String timeRange, String queryTiming) throws IOException {
        return "query=(sum(rate(activator_request_latencies_sum{service_name=\"" + functionName + "\",response_code=\"200\"}[" + timeRange
                + "m])) / sum(rate(activator_request_latencies_count{service_name=\"" + functionName + "\",response_code=\"200\"}[" + timeRange
                + "m])))/1000&time=" + queryTiming;
    }
    public String generateQueryForFunctionMemory(String functionName, String timeRange, String queryTiming) throws IOException {
        return "query=avg(avg_over_time(container_memory_working_set_bytes{pod=~\"" + functionName + "-.*\", container=\"user-container\"}[" + timeRange + "m]))/1024&time=" + queryTiming;
    }
    public String generateQueryForActualPods(String functionName, String timeRange, String queryTiming) throws IOException {
        return "query=autoscaler_actual_pods{service_name=\"" + functionName + "\"}&time=" + queryTiming;
    }
    public String generateQueryForSuccessCount(String functionName, String timeRange, String queryTiming) throws IOException {
        return "query=sum(rate(activator_request_count{response_code=\"200\", service_name=\"" + functionName + "\"}[" + timeRange + "m]))*60*" + timeRange + "&time=" + queryTiming;
    }
    public String generateQueryForFailCount(String functionName, String timeRange, String queryTiming) throws IOException {
        return "query=sum(rate(activator_request_count{response_code=\"500\", service_name=\"" + functionName + "\"}[" + timeRange + "m]))*60*" + timeRange + "&time=" + queryTiming;
    }

    public FunctionMetricListDTO getMetricList(String functionKey, String time, String start, String end) throws IOException, ParseException {
        URL url = new URL(prometheusHttpApi);

        Function function = functionRepository.findByFunctionKey(functionKey).orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
        String functionName = function.getName();
        String queryTiming = "";
        FunctionMetricListDTO response = new FunctionMetricListDTO();
        Gson g = new Gson();
        List<FunctionMetricElementsListDTO> requestCountList = new ArrayList<>();
        List<FunctionMetricElementsListDTO> requestLatencyList = new ArrayList<>();
        List<FunctionMetricElementsListDTO> functionMemoryList = new ArrayList<>();

        List<FunctionMetricElementsListDTO> actualPodsList = new ArrayList<>();
        List<FunctionMetricElementsListDTO> successCountList = new ArrayList<>();
        List<FunctionMetricElementsListDTO> failCountList = new ArrayList<>();

        if(METRIC_TIME_RANGE_1_HOUR.equals(time)){ //1시간 15분 단위 4개
            Calendar cal = Calendar.getInstance();
            queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
            getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_15M);

            for (int i=0; i<3; i++){
                cal.add(Calendar.MINUTE, -15);
                queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_15M);
            }
        } else if (METRIC_TIME_RANGE_3_HOUR.equals(time)) { //3시간 30분 단위 6개
            Calendar cal = Calendar.getInstance();
            queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
            getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_30M);
            for (int i=0; i<5; i++){
                cal.add(Calendar.MINUTE, -30);
                queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_30M);
            }
        } else if (METRIC_TIME_RANGE_12_HOUR.equals(time)) { //12시간 3시간 단위 4개
            Calendar cal = Calendar.getInstance();
            queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
            getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_180M);
            for (int i=0; i<3; i++){
                cal.add(Calendar.MINUTE, -180);
                queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_180M);
            }
        } else { //사용자 지정 기간 1일 단위 날짜수 ex)1101 ~ 1103 이면 3일치
            SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
            Date startDate = format.parse(start);
            long startdateLong = startDate.getTime() / 1000L;
            //종료 일자
            Date endDate = format.parse(end);
            long enddateLong = endDate.getTime() / 1000L;
            //종료-시작 일수 차이
            int dateDiffer = (int) ((enddateLong-startdateLong) / (24*60*60));

            Calendar cal = Calendar.getInstance();
            cal.setTime(endDate);
            cal.add(Calendar.MINUTE, 720);
            queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
            getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_1440M);

            for (int i=0; i<dateDiffer; i++){
                cal.add(Calendar.MINUTE, -1440);
                queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetric(url, functionName, queryTiming, g, requestCountList, requestLatencyList, functionMemoryList, actualPodsList, successCountList, failCountList, METRIC_TIME_UNIT_1440M);
            }
        }

        for(FunctionMetricElementsListDTO element : requestLatencyList) {
            RequestLatencyMetricInvalidValueHandling(element);
        }

        response.setRequestCount(requestCountList);
        response.setRequestLatency(requestLatencyList);
        response.setFunctionMemory(functionMemoryList);

        response.setActualPods(actualPodsList);
        response.setSuccessCount(successCountList);
        response.setFailCount(failCountList);

        return response;
    }

    private void RequestLatencyMetricInvalidValueHandling(FunctionMetricElementsListDTO element){
        if(element.getData().getResult().size() > 0){
            if("NaN".equals(element.getData().getResult().get(0).getValue().get(1)) || "Inf".equals(element.getData().getResult().get(0).getValue().get(1))
                    || "-Inf".equals(element.getData().getResult().get(0).getValue().get(1)) || "+Inf".equals(element.getData().getResult().get(0).getValue().get(1))){
                element.getData().getResult().get(0).getValue().set(1, "0");
            }
        }
    }


    private void getEachMetric(URL url, String functionName, String queryTiming, Gson g, List<FunctionMetricElementsListDTO> requestCountList, List<FunctionMetricElementsListDTO> requestLatencyList, List<FunctionMetricElementsListDTO> functionMemoryList, List<FunctionMetricElementsListDTO> actualPodsList, List<FunctionMetricElementsListDTO> successCountList, List<FunctionMetricElementsListDTO> failCountList, String timeRange) throws IOException {
        requestCountList.add(g.fromJson(getPrometheusMetric(url, generateQueryForRequestCount(functionName, timeRange, queryTiming)), FunctionMetricElementsListDTO.class));
        requestLatencyList.add(g.fromJson(getPrometheusMetric(url, generateQueryForRequestLatency(functionName, timeRange, queryTiming)), FunctionMetricElementsListDTO.class));
        functionMemoryList.add(g.fromJson(getPrometheusMetric(url, generateQueryForFunctionMemory(functionName, timeRange, queryTiming)), FunctionMetricElementsListDTO.class));

        actualPodsList.add(g.fromJson(getPrometheusMetric(url, generateQueryForActualPods(functionName, timeRange, queryTiming)), FunctionMetricElementsListDTO.class));
        successCountList.add(g.fromJson(getPrometheusMetric(url, generateQueryForSuccessCount(functionName, timeRange, queryTiming)), FunctionMetricElementsListDTO.class));
        failCountList.add(g.fromJson(getPrometheusMetric(url, generateQueryForFailCount(functionName, timeRange, queryTiming)), FunctionMetricElementsListDTO.class));
    }

    public FunctionBillingMetricDTO getBillingMetric(String metricType, String date) throws IOException, ParseException {
        URL url = new URL(prometheusHttpApi);
        Gson g = new Gson();

        SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
        Calendar cal = Calendar.getInstance();
        cal.setTime(format.parse(date));
        String queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);

        StringBuilder query = new StringBuilder();

        JSONObject prometheusReturn;
        List<FunctionBillingElementsDTO> functionMetricList = new ArrayList<>();
        FunctionBillingMetricDTO response = new FunctionBillingMetricDTO();

        List<Function> functionList = functionRepository.findAll();
        for(Function f : functionList){
            query.delete(0, query.length());
            if("requestCount".equals(metricType)){
                query.append("query=sum(increase(activator_request_count{service_name=\"").append(f.getName()).append("\"}[1d]))&time=").append(queryTiming);
            }else{
                query.append("query=sum(sum_over_time(container_memory_working_set_bytes{pod=~\"").append(f.getName()).append("-.*\", container=\"user-container\"}[1d]))/1024/1024/1024*60&time=").append(queryTiming);
            }
            prometheusReturn = new JSONObject(getPrometheusMetric(url, query.toString()));
            prometheusReturn.put("functionKey", f.getFunctionKey());
            functionMetricList.add(g.fromJson(prometheusReturn.toString(), FunctionBillingElementsDTO.class));
        }
        response.setMetric(functionMetricList);
        return response;
    }

    private String getPrometheusMetric(URL url, String query) throws IOException {
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setConnectTimeout(timeOutValue);
        connection.setReadTimeout(timeOutValue);
        connection.setRequestMethod("POST");
        connection.setDoOutput(true);
        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
        outputStream.writeBytes(query);
        outputStream.flush();
        outputStream.close();

        if(connection.getResponseCode()== HttpURLConnection.HTTP_OK ){
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            StringBuffer stringBuffer = new StringBuffer();

            String inputLine;
            while ((inputLine = bufferedReader.readLine()) != null)  {
                stringBuffer.append(inputLine);
            }
            bufferedReader.close();
            return stringBuffer.toString();
        }
        return null;
    }

    public FunctionMetricDTO getCloudMonitoringMetric(String functionKey, String range) throws IOException, ParseException {
        URL url = new URL(prometheusHttpApi);

        Function function = functionRepository.findByFunctionKey(functionKey).orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
        String functionName = function.getName();
        String queryTiming = "";

        Calendar cal = Calendar.getInstance();
        queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);

        Gson g = new Gson();

        FunctionMetricDTO output = new FunctionMetricDTO();
        FunctionMetricElementsListDTO requestLatency;

        output.setRequestCount(g.fromJson(getPrometheusMetric(url, generateQueryForRequestCount(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        requestLatency = g.fromJson(getPrometheusMetric(url, generateQueryForRequestLatency(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class);
        output.setFunctionMemory(g.fromJson(getPrometheusMetric(url, generateQueryForFunctionMemory(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        output.setActualPods(g.fromJson(getPrometheusMetric(url, generateQueryForActualPods(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        output.setSuccessCount(g.fromJson(getPrometheusMetric(url, generateQueryForSuccessCount(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        output.setFailCount(g.fromJson(getPrometheusMetric(url, generateQueryForFailCount(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));

        // requestLatency invalid 값 처리 (NaN, Inf)
        RequestLatencyMetricInvalidValueHandling(requestLatency);

        output.setRequestLatency(requestLatency);

        return output;
    }

    // Cloud Monitoring 전용 매트릭 계산기 (Counter Reset 보정)
    public FunctionMetricElementsListDTO calMetricCount(FunctionMetricElementsListDTO nowCount, FunctionMetricElementsListDTO preCount) {
        if(nowCount.getData().getResult().size() > 0 && preCount.getData().getResult().size() > 0){
            nowCount.getData().getResult().get(0).getValue().set(1, Double.toString(Double.valueOf(nowCount.getData().getResult().get(0).getValue().get(1)) - Double.valueOf(preCount.getData().getResult().get(0).getValue().get(1))));
        } else if(nowCount.getData().getResult().size() >= 0 && preCount.getData().getResult().size() == 0 ){
        } else if(nowCount.getData().getResult().size() == 0 && preCount.getData().getResult().size() > 0){
        }
        return nowCount;
    }
}

