ì•ˆë…•í•˜ì„¸ìš” íŒ€ì› ì—¬ëŸ¬ë¶„! ğŸ˜Š
ì½”ë“œ ì‘ì„±í•˜ì‹œëŠë¼ ì •ë§ ê³ ìƒ ë§ìœ¼ì…¨ìŠµë‹ˆë‹¤. ì „ì²´ì ìœ¼ë¡œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ëª…í™•í•˜ê³  ê° ê¸°ëŠ¥ì´ ì˜ êµ¬í˜„ë˜ì–´ ìˆì–´ì„œ ì •ë§ ì¸ìƒ ê¹Šì—ˆìŠµë‹ˆë‹¤. ë‹¤ë§Œ, ì¡°ê¸ˆ ë” ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì¼ ìˆ˜ ìˆëŠ” ëª‡ ê°€ì§€ ê°œì„  ì•„ì´ë””ì–´ë¥¼ ê³µìœ ë“œë¦´ê²Œìš”. ëª‡ ê°€ì§€ í”¼ë“œë°±ê³¼ ì œì•ˆ ì‚¬í•­ì„ ë“œë¦¬ì§€ë§Œ, ì´ë¯¸ ì˜ ì‘ì„±ëœ ì½”ë“œë¼ ì•½ê°„ì˜ ë‹¤ë“¬ê¸° ì •ë„ë¼ê³  ìƒê°í•˜ì‹œë©´ ì¢‹ì„ ê²ƒ ê°™ì•„ìš”!

1. registerFunctionToken ë©”ì„œë“œ ê´€ë ¨
ì´ ë©”ì„œë“œì—ì„œ JWT ìƒì„±, ì„œëª…, ì €ì¥ ë¡œì§ì´ ëª¨ë‘ í•œê³³ì— ëª°ë ¤ ìˆì–´ì„œ ì¡°ê¸ˆ ë³µì¡í•´ ë³´ì˜€ì–´ìš”.
JWT ìƒì„± ë¡œì§ì„ ë³„ë„ì˜ ë©”ì„œë“œë¡œ ë¶„ë¦¬í•˜ë©´ ì½”ë“œê°€ í›¨ì”¬ ê°„ê²°í•´ì§€ê³  ì¬ì‚¬ìš©ì„±ë„ ì¢‹ì•„ì§ˆ ê²ƒ ê°™ì•„ìš”.

ì œì•ˆ:

JWT ìƒì„± ë¡œì§ì„ generateToken(Function function) ë©”ì„œë“œë¡œ ë¶„ë¦¬.
ê°€ë…ì„±ì´ ì¢‹ì•„ì§€ê³ , í–¥í›„ ë‹¤ë¥¸ ë©”ì„œë“œì—ì„œë„ í† í° ìƒì„±ì´ í•„ìš”í•  ë•Œ ì¬ì‚¬ìš© ê°€ëŠ¥í•´ì§ˆ ê±°ì˜ˆìš”.
java
ì½”ë“œ ë³µì‚¬
@Transactional
public FunctionDTO.Response registerFunctionToken(String functionKey) throws ParseException, JOSEException, JsonProcessingException {
    Function function = functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new ResourceNotFoundException("í‘ì…˜í‚¤ê°€ ì¡´ì¬í•˜ì§€ì•ŠìŠµë‹ˆë‹¤."));
    
    String token = generateToken(function); // í† í° ìƒì„± ë¡œì§ ë¶„ë¦¬
    function.updateToken(token);

    return function.toDto();
}

private String generateToken(Function function) throws JOSEException, JsonProcessingException {
    TokenDTO.Register reqDto = new TokenDTO.Register();
    reqDto.setFunction(function);
    reqDto.setKeyId(function.getFunctionKey());

    RSAKey rsaJWK = RSAKey.parse(functionService.registerJWK(reqDto));
    JWSSigner signer = new RSASSASigner(rsaJWK);

    JWTClaimsSet claimsSet = new JWTClaimsSet.Builder()
            .subject(function.getName())
            .issuer("https://scp.com")
            .expirationTime(new Date(new Date().getTime() + YEAR_SIZE_100))
            .build();

    SignedJWT signedJWT = new SignedJWT(
            new JWSHeader.Builder(JWSAlgorithm.RS256).keyID(rsaJWK.getKeyID()).build(),
            claimsSet);

    signedJWT.sign(signer);
    return signedJWT.serialize();
}
íš¨ê³¼:

ë©”ì„œë“œì˜ ì±…ì„ì„ ë¶„ë¦¬í•´ ì´í•´í•˜ê¸° ì‰¬ì›Œì§€ê³ , í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„±ë„ í›¨ì”¬ ê°„ë‹¨í•´ì§ˆ ê±°ì˜ˆìš”.
2. registerFunctionEnvironment ë©”ì„œë“œ ê´€ë ¨
í˜„ì¬ ì´ ë©”ì„œë“œì—ì„œ ì—¬ëŸ¬ ê²€ì¦ ë¡œì§(checkEnvironmentX)ë“¤ì´ í˜¸ì¶œë˜ê³  ìˆëŠ”ë°, ê²€ì¦ ë¡œì§ë“¤ì´ í•¨ìˆ˜ ì•ˆì— ì„ì—¬ ìˆì–´ì„œ ë³µì¡í•´ ë³´ì˜€ì–´ìš”.
ì´ ê²€ì¦ ë¡œì§ë“¤ì„ Validator í´ë˜ìŠ¤ë¡œ ë¬¶ìœ¼ë©´ ê°€ë…ì„±ë„ ì¢‹ì•„ì§€ê³ , ë‚˜ì¤‘ì— ì¶”ê°€ ê²€ì¦ ë¡œì§ì´ í•„ìš”í•´ë„ í™•ì¥í•˜ê¸° ì‰¬ìš¸ ê²ƒ ê°™ì•„ìš”.

ì œì•ˆ:

EnvironmentValidatorë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ ê²€ì¦ ë¡œì§ì„ ë¶„ë¦¬.
ë©”ì¸ ë¡œì§ì€ "ê²€ì¦ â†’ ì €ì¥ â†’ DTO ë°˜í™˜" ìˆœì„œë¡œ ê°„ê²°í•˜ê²Œ ìœ ì§€.
java
ì½”ë“œ ë³µì‚¬
public FunctionEnvironmentDTO.Response registerFunctionEnvironment(FunctionEnvironmentDTO.Register reqDto, Function function, AtomicInteger envCountChecker) {
    EnvironmentValidator.validate(reqDto, envCountChecker); // ê²€ì¦ ë¡œì§ ì™¸ë¶€ë¡œ ë¶„ë¦¬
    reqDto.setFunctionSeq(function.getFunctionSeq());

    FunctionEnvironment functionEnvironment = functionEnvironmentRepository.save(FunctionEnvironment.register(reqDto));
    return functionEnvironment.toDto();
}

// Validator í´ë˜ìŠ¤ ì˜ˆì‹œ
public class EnvironmentValidator {
    public static void validate(FunctionEnvironmentDTO.Register reqDto, AtomicInteger envCountChecker) {
        checkEnvironmentColdStart(reqDto);
        checkEnvironmentEnv(reqDto, envCountChecker);
        checkEnvironmentMemory(reqDto);
        checkEnvironmentLimit(reqDto);
        checkEnvironmentUrl(reqDto);
        checkEnvironmentToken(reqDto);
    }

    // ê¸°ì¡´ì˜ ê°œë³„ check ë©”ì„œë“œë“¤ í¬í•¨
}
íš¨ê³¼:

registerFunctionEnvironment ë©”ì„œë“œê°€ ê¹”ë”í•´ì§€ê³  ê²€ì¦ ë¡œì§ì´ ë…ë¦½ì ìœ¼ë¡œ ê´€ë¦¬ë˜ì–´ ê°€ë…ì„±, ìœ ì§€ë³´ìˆ˜ì„±, í…ŒìŠ¤íŠ¸ í¸ì˜ì„±ì´ í–¥ìƒë©ë‹ˆë‹¤.
3. registerAll ë©”ì„œë“œ ê´€ë ¨
ì´ ë©”ì„œë“œëŠ” ì •ë§ ë§ì€ ì±…ì„ì„ ë‹´ë‹¹í•˜ê³  ìˆë„¤ìš”!
ë³€ê²½ ì—¬ë¶€ í™•ì¸, í™˜ê²½ë³€ìˆ˜ ë“±ë¡, ì‚­ì œ ë“± ë‹¤ì–‘í•œ ì‘ì—…ì´ í•œêº¼ë²ˆì— ì´ë£¨ì–´ì§€ê³  ìˆì–´ì„œ ì½”ë“œ ì½ê¸°ê°€ ì¡°ê¸ˆ í˜ë“¤ì—ˆì–´ìš”.

ì œì•ˆ:

ë³€ê²½ ì—¬ë¶€ í™•ì¸ ë¡œì§ì„ ë³„ë„ ë©”ì„œë“œë¡œ ë¶„ë¦¬.
í™˜ê²½ë³€ìˆ˜ ì—…ë°ì´íŠ¸ ë¡œì§ë„ ë³„ë„ ë©”ì„œë“œë¡œ ë¶„ë¦¬.
java
ì½”ë“œ ë³µì‚¬
@Transactional
public List<FunctionEnvironmentDTO.Response> registerAll(List<FunctionEnvironmentDTO.Register> reqDto, String functionKey) throws IOException, ParseException {
    Function function = functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new RuntimeException("í‘ì…˜í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”"));

    List<FunctionEnvironment> existingFunctions = functionEnvironmentRepository.findByFunction(function);
    List<FunctionEnvironmentDTO.Register> dbItems = mapToRegisterDTOs(existingFunctions, function);

    if (isEnvironmentUpdated(reqDto, dbItems)) {
        updateFunctionEnvironments(reqDto, function);
        knativeService.callIstioAndKnative(function);
    }

    List<FunctionEnvironment> updatedFunctions = functionEnvironmentRepository.findByFunction(function);
    return updatedFunctions.stream().map(FunctionEnvironment::toDto).collect(Collectors.toList());
}

private boolean isEnvironmentUpdated(List<FunctionEnvironmentDTO.Register> reqItems, List<FunctionEnvironmentDTO.Register> dbItems) {
    if (reqItems.size() != dbItems.size()) return true;

    for (int i = 0; i < reqItems.size(); i++) {
        if (!reqItems.get(i).equals(dbItems.get(i))) return true;
    }
    return false;
}

private void updateFunctionEnvironments(List<FunctionEnvironmentDTO.Register> reqDto, Function function) {
    functionEnvironmentRepository.deleteByFunction(function);
    AtomicInteger counter = new AtomicInteger(0);
    reqDto.forEach(dto -> registerFunctionEnvironment(dto, function, counter));
    if (counter.get() > MAX_NUM_ENV) {
        throw new RuntimeException("í™˜ê²½ë³€ìˆ˜ëŠ” 50ê°œë¥¼ ì´ˆê³¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }
}
íš¨ê³¼:

ë©”ì„œë“œ ê¸¸ì´ê°€ ì§§ì•„ì ¸ì„œ ì½ê¸° ì‰¬ì›Œì§€ê³ , ê° ë¡œì§ì´ ë¶„ë¦¬ë˜ì–´ ìœ ì§€ë³´ìˆ˜ê°€ ì‰¬ì›Œì§‘ë‹ˆë‹¤.
ë‚˜ì¤‘ì— í™˜ê²½ë³€ìˆ˜ ì—…ë°ì´íŠ¸ ë¡œì§ë§Œ í…ŒìŠ¤íŠ¸í•˜ê±°ë‚˜ ë³€ê²½í•  ë•Œë„ í¸ë¦¬í•´ì§‘ë‹ˆë‹¤.
4. ê³µí†µ ê²€ì¦ ë¡œì§ ê°œì„ 
checkEnvironmentToken, checkEnvironmentUrl ë“±ì—ì„œ ë¹„ìŠ·í•œ ê²€ì¦ ë¡œì§ì´ ë°˜ë³µë˜ê³  ìˆëŠ” ê²Œ ë³´ì—¬ìš”.
ì´ëŸ° íŒ¨í„´ì„ ê³µí†µí™”í•˜ë©´ ì¤‘ë³µ ì½”ë“œê°€ ì¤„ì–´ë“¤ê³ , ê²€ì¦ ë¡œì§ ì¶”ê°€/ìˆ˜ì • ì‹œ ì‘ì—…ëŸ‰ì´ ì¤„ì–´ë“¤ ê²ƒ ê°™ì•„ìš”.

ì œì•ˆ:

ê³µí†µ ê²€ì¦ ë©”ì„œë“œ validateEnvironmentë¥¼ ë§Œë“¤ì–´ í™œìš©.
java
ì½”ë“œ ë³µì‚¬
private static void validateEnvironment(String type, String value, Predicate<String> condition, String errorMessage) {
    if (!condition.test(value)) {
        throw new RuntimeException(errorMessage);
    }
}

private static void checkEnvironmentToken(FunctionEnvironmentDTO.Register reqDto) {
    if ("token".equals(reqDto.getType())) {
        validateEnvironment(reqDto.getValue(), val -> "Y".equals(val) || "N".equals(val), "í† í°ì‚¬ìš©ì—¬ë¶€ ê°’ì„ í™•ì¸í•´ì£¼ì‹­ì‹œì˜¤.");
        if ("Y".equals(reqDto.getValue())) {
            validateEnvironment(reqDto.getKey(), StringUtils::isNotEmpty, "í† í°ê°’ì´ Y ì¸ê²½ìš° í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì‹­ì‹œì˜¤.");
        } else if ("N".equals(reqDto.getValue())) {
            validateEnvironment(reqDto.getKey(), StringUtils::isEmpty, "í† í°ê°’ì´ N ì¸ê²½ìš° í‚¤ë¥¼ ì…ë ¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
    }
}
íš¨ê³¼:

ë°˜ë³µë˜ëŠ” ê²€ì¦ ë¡œì§ì´ ì¤„ì–´ë“¤ì–´ ì½”ë“œê°€ ê°„ê²°í•´ì§€ê³  ìœ ì§€ë³´ìˆ˜ì„±ì´ ë†’ì•„ì§‘ë‹ˆë‹¤.
ë§ˆë¬´ë¦¬
ì‘ì„±í•´ì£¼ì‹  ì½”ë“œëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì´ ì˜ ë‹´ê²¨ ìˆê³ , êµ¬ì¡°ë„ ê¹”ë”í•œ í¸ì´ë¼ ìˆ˜ì • ì—†ì´ë„ ì¶©ë¶„íˆ í™œìš© ê°€ëŠ¥í•´ ë³´ì…ë‹ˆë‹¤.
ë‹¤ë§Œ, ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ë¥¼ ìœ„í•´ ìœ„ì™€ ê°™ì€ ê°œì„ ì„ ë”í•˜ë©´ ì¥ê¸°ì ìœ¼ë¡œ í° íš¨ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆì„ ê±°ì˜ˆìš”!
ê¼¼ê¼¼íˆ ì‘ì„±í•´ì£¼ì…”ì„œ ê°ì‚¬ë“œë¦¬ê³ , í•­ìƒ ìˆ˜ê³  ë§ìœ¼ì‹­ë‹ˆë‹¤. ğŸ’ª

í˜¹ì‹œ ì¶”ê°€ë¡œ ì„¤ëª…ì´ í•„ìš”í•˜ê±°ë‚˜ ë‹¤ë¥¸ ì•„ì´ë””ì–´ê°€ ìˆìœ¼ì‹œë©´ í¸í•˜ê²Œ ë§ì”€í•´ì£¼ì„¸ìš”! ğŸ™
