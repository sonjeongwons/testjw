$ git diff develop...refactoring-kmsservice|cat
diff --git a/src/main/java/com/scf/manager/mvc/service/KmsService.java b/src/main/java/com/scf/manager/mvc/service/KmsService.java
index 34da597..d6c64d8 100644
--- a/src/main/java/com/scf/manager/mvc/service/KmsService.java
+++ b/src/main/java/com/scf/manager/mvc/service/KmsService.java
@@ -73,255 +73,175 @@ public class KmsService {
     @Value("${SCF_KEY}")
     private String scfEncryptKey;

-    // URI
-    private static String KMS_API_BASE_URI;
-    // END POINT
-    private static String KMS_API_DECRYPT = "/kms/v1/decrypt/%s";
-    private static String KMS_API_CREATE_DATAKEY = "/kms/v1/datakey/plaintext/%s";
-    // 샘플용 KEY TAG
-    private static String KEY_NAME;
-
-    private static String accessKey;
-    private static String accessSecretKey;
-    private static String method;
-    private static String headerProjectId;
-    private static String headerClientType;
-    public JSONObject createDataKey(DataKeyDTO.Register reqDto) throws Exception {
-        KMS_API_BASE_URI = reqDto.getEndpointUrl();
-        accessKey=reqDto.getAccessKey();
-        accessSecretKey=reqDto.getSecretKey();
-        method="POST";
-        headerProjectId=reqDto.getProjectId();
-        headerClientType="OpenApi";
-        KEY_NAME = reqDto.getMasterKey();
-
-        // 새로운 데이터 키 생성을 요청
-        JSONObject encryptedDataKey = getDataKey();
-        return encryptedDataKey;
-    }
+    private static final String KMS_API_DECRYPT = "/kms/v1/decrypt/%s";
+    private static final String KMS_API_CREATE_DATAKEY = "/kms/v1/datakey/plaintext/%s";

+    private String kmsApiBaseUri;
+    private String keyName;
+    private String accessKey;
+    private String accessSecretKey;
+    private String method;
+    private String headerProjectId;
+    private String headerClientType;

-    private static JSONObject getDataKey() throws Exception {
-        String endPoint = String.format(KMS_API_CREATE_DATAKEY, KEY_NAME);
-        JSONObject data = new JSONObject();
-        data.put("requestPlainKey", false);
+    public JSONObject createDataKey(DataKeyDTO.Register reqDto) throws Exception {
+        initializeApiConfig(reqDto.getEndpointUrl(), reqDto.getAccessKey(), reqDto.getSecretKey(), reqDto.getProjectId(), reqDto.getMasterKey());
+        return callKmsApi(KMS_API_CREATE_DATAKEY, buildCreateDataKeyPayload());
+    }

-        // OpenAPI 호출
-        JSONObject respJsonObject = callApi(endPoint, data.toJSONString());
-        //return respJsonObject.get("dataKey").toString();
-        return respJsonObject;
+    public String transferEnvEncrypt(DataKeyDTO.envEncrpyt reqDto, String functionKey) throws Exception {
+        initializeApiConfig(reqDto.getEndpointUrl(), reqDto.getAccessKey(), reqDto.getSecretKey(), reqDto.getProjectId(), reqDto.getMasterKey());
+        Map<String, String> envelope = buildEncryptionEnvelope(reqDto, functionKey);
+        return encryptWithKey(convertMapToJson(envelope), scfEncryptKey);
     }

-    private static JSONObject callApi(String endPoint, String data) throws Exception {
-        String host = KMS_API_BASE_URI + endPoint;
-        String timestamp = Long.toString(System.currentTimeMillis());
-        String signature = makeHmacSignature(host, timestamp);
-        InputStream in = null;
-        BufferedReader reader = null;
-        HttpsURLConnection httpsConn = null;
+    public String transferEnvDecrypt(DataKeyDTO.envDecrpyt reqDto) throws Exception {
+        initializeApiConfig(reqDto.getEndpointUrl(), reqDto.getAccessKey(), reqDto.getSecretKey(), reqDto.getProjectId(), null);
+        String decryptedJson = decryptWithKey(reqDto.getCipherText(), scfEncryptKey);
+        Map<String, String> decryptedData = convertJsonToMap(decryptedJson);
+        String decryptedDataKey = callDecryptDataKey(decryptedData.get("encryptedDataKey"));
+        return decryptEnvValue(decryptedData.get("cipherEnv"), decryptedDataKey);
+    }

-        try {
-            // HTTPS URL 연결
-            URL url = new URL(host);
-            httpsConn = (HttpsURLConnection) url.openConnection();
-
-            // Hostname verification 설정
-            httpsConn.setHostnameVerifier(new HostnameVerifier() {
-                @Override
-                public boolean verify(String hostname, SSLSession session) {
-                    // Ignore host name verification. It always returns true.
-                    return true;
-                }
-            });
-
-            httpsConn.setDoInput(true);
-            httpsConn.setUseCaches(false);
-            httpsConn.setRequestMethod("POST");
-            httpsConn.setRequestProperty("X-Cmp-ProjectId", headerProjectId);
-            httpsConn.setRequestProperty("X-Cmp-AccessKey", accessKey);
-            httpsConn.setRequestProperty("X-Cmp-Signature", signature);
-            httpsConn.setRequestProperty("X-Cmp-ClientType", headerClientType);
-            httpsConn.setRequestProperty("X-Cmp-Timestamp", timestamp);
-            httpsConn.setRequestProperty("Content-Type", "application/json; utf-8");
-            httpsConn.setRequestProperty("Accept", "application/json");
-            httpsConn.setDoOutput(true); // OutputStream을 사용해서 post body 데이터 전송
-            try (OutputStream os = httpsConn.getOutputStream()) {
-                byte request_data[] = data.getBytes("utf-8");
-                os.write(request_data);
-                os.close();
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
+    // ===== Helper Methods =====

-        } catch (Exception e) {
-            System.out.println("error : " + e);
-        } finally {
-            if (reader != null) {
-                reader.close();
-            }
-            if (httpsConn != null) {
-                httpsConn.disconnect();
-            }
-        }
+    private void initializeApiConfig(String endpointUrl, String accessKey, String secretKey, String projectId, String masterKey) {
+        this.kmsApiBaseUri = endpointUrl;
+        this.accessKey = accessKey;
+        this.accessSecretKey = secretKey;
+        this.method = "POST";
+        this.headerProjectId = projectId;
+        this.headerClientType = "OpenApi";
+        this.keyName = masterKey; // masterKey는 null일 수 있음.
+    }

-        int responseCode = httpsConn.getResponseCode();
+    private JSONObject buildCreateDataKeyPayload() {
+        JSONObject data = new JSONObject();
+        data.put("requestPlainKey", false);
+        return data;
+    }

-        // 호스트 연결
-        httpsConn.connect();
-        httpsConn.setInstanceFollowRedirects(true);
+    private Map<String, String> buildEncryptionEnvelope(DataKeyDTO.envEncrpyt reqDto, String functionKey) throws Exception {
+        SecretKey secretKey = createSecretKeyFromBase64(reqDto.getPlainText());
+        byte[] cipherEnv = encryptData(reqDto.getEnvValue().getBytes(StandardCharsets.UTF_8), secretKey);
+        return Map.of(
+                "envKey", reqDto.getEnvKey(),
+                "cipherEnv", encodeBase64(cipherEnv),
+                "functionKey", functionKey,
+                "masterKey", reqDto.getMasterKey(),
+                "encryptedDataKey", reqDto.getDataKey()
+        );
+    }

-        // response 반환
-        if (responseCode == HttpsURLConnection.HTTP_OK) { // 정상 호출 200
-            in = httpsConn.getInputStream();
-        } else { // 에러 발생
-            in = httpsConn.getErrorStream();
-        }
+    private JSONObject callKmsApi(String endpointTemplate, JSONObject payload) throws Exception {
+        String endpoint = String.format(endpointTemplate, keyName);
+        String url = kmsApiBaseUri + endpoint;
+        String timestamp = String.valueOf(System.currentTimeMillis());
+        String signature = generateHmacSignature(url, timestamp);

-        JSONParser parser = new JSONParser();
-        JSONObject repsObj = (JSONObject) parser.parse(new InputStreamReader(in, "UTF-8"));
-        String jsonString = repsObj.toString();
-        log.info("API call after sonny" + jsonString);
-        return repsObj;
+        return performHttpPost(url, payload.toJSONString(), buildHeaders(timestamp, signature));
+    }

+    private Map<String, String> buildHeaders(String timestamp, String signature) {
+        return Map.of(
+                "X-Cmp-ProjectId", headerProjectId,
+                "X-Cmp-AccessKey", accessKey,
+                "X-Cmp-Signature", signature,
+                "X-Cmp-ClientType", headerClientType,
+                "X-Cmp-Timestamp", timestamp,
+                "Content-Type", "application/json; utf-8",
+                "Accept", "application/json"
+        );
     }

-    public static String makeHmacSignature(String url, String timestamp) {
-        String body = method + url + timestamp + accessKey + headerProjectId + headerClientType;
-        String encodeBase64Str;
+    private String callDecryptDataKey(String encryptedDataKey) throws Exception {
+        JSONObject payload = new JSONObject();
+        payload.put("cipherText", encryptedDataKey);
+        JSONObject response = callKmsApi(KMS_API_DECRYPT, payload);
+        return (String) response.get("decryptedData");
+    }

+    private String generateHmacSignature(String url, String timestamp) {
         try {
-            byte[] message = body.getBytes("UTF-8");
-            byte[] secretKey = accessSecretKey.getBytes("UTF-8");
+            String body = method + url + timestamp + accessKey + headerProjectId + headerClientType;
+            byte[] message = body.getBytes(StandardCharsets.UTF_8);
+            byte[] secretKey = accessSecretKey.getBytes(StandardCharsets.UTF_8);

             Mac mac = Mac.getInstance("HmacSHA256");
-            SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey, "HmacSHA256");
-            mac.init(secretKeySpec);
-            byte[] hmacSha256 = mac.doFinal(message);
-            encodeBase64Str = encodeBase64(hmacSha256);
+            mac.init(new SecretKeySpec(secretKey, "HmacSHA256"));
+            return encodeBase64(mac.doFinal(message));
         } catch (Exception e) {
-            throw new RuntimeException("Failed to calculate hmac-sha256", e);
+            throw new RuntimeException("Failed to calculate HMAC-SHA256 signature", e);
         }
-
-        return encodeBase64Str;
     }

-    private static String encodeBase64(byte[] bytesToEncode) {
-        return Base64.getEncoder().encodeToString(bytesToEncode);
+    private SecretKey createSecretKeyFromBase64(String base64Key) {
+        byte[] keyBytes = decodeBase64(base64Key);
+        return new SecretKeySpec(keyBytes, "AES");
     }

-    private static byte[] decodeBase64(String stringToDecode) {
-        return Base64.getDecoder().decode(stringToDecode);
-    }
-
-    public String transferEnvEncrypt(DataKeyDTO.envEncrpyt reqDto, String functionKey) throws Exception {
-        KMS_API_BASE_URI = reqDto.getEndpointUrl();
-        accessKey=reqDto.getAccessKey();
-        accessSecretKey=reqDto.getSecretKey();
-        method="POST";
-        headerProjectId=reqDto.getProjectId();
-        headerClientType="OpenApi";
-        KEY_NAME = reqDto.getMasterKey();
-
-        // 암호화를 할 데이터 전송
-        return encryptEnv(reqDto,functionKey);
-    }
-
-    public String encryptEnv(DataKeyDTO.envEncrpyt reqDto, String functionKey) throws Exception {
-        Object obj=reqDto.getEnvValue();
-        String dataKey=reqDto.getPlainText();
-        Map<String, String> envelope = new HashMap<>();
-
-        // 생성된 데이터 키를 AES-CBC 방식으로 암호화
-        // Cipher Class 사용
-        SecretKey secretKey = new SecretKeySpec(decodeBase64(dataKey), "AES");
+    private byte[] encryptData(byte[] data, SecretKey secretKey) throws Exception {
         Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
         cipher.init(Cipher.ENCRYPT_MODE, secretKey);
-        byte[] cipherEnv = cipher.doFinal(obj.toString().getBytes());
-        envelope.put("envKey",reqDto.getEnvKey());
-        envelope.put("cipherEnv", encodeBase64(cipherEnv));
-        envelope.put("functionKey",functionKey);
-        envelope.put("masterKey",reqDto.getMasterKey());
-        envelope.put("encryptedDataKey",reqDto.getDataKey());
-
-        return encryptWithKey(JSONObject.toJSONString(envelope), scfEncryptKey);
-    }
-
-    // 지정된 키를 사용하여 데이터를 AES 알고리즘으로 암호화
-    private static String encryptWithKey(String targetData, String managerKey) throws Exception {
-        // Base64 디코딩된 키
-        byte[] managerKeyBytes = Arrays.copyOf(managerKey.getBytes(StandardCharsets.UTF_8), 16);
-        // SecretKey 객체 생성
-        SecretKey secretKey = new SecretKeySpec(managerKeyBytes, "AES");
-        // Cipher 객체 초기화
-        Cipher cipher = Cipher.getInstance("AES");
-        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
-        // 데이터 암호화
-        byte[] encryptedBytes = cipher.doFinal(targetData.getBytes());
-        // 암호화된 데이터를 Base64로 인코딩하여 반환
-        return encodeBase64(encryptedBytes);
+        return cipher.doFinal(data);
     }

-    public String decryptDataKey(String sealedKey) throws Exception {
-        String endPoint = String.format(KMS_API_DECRYPT, KEY_NAME);
-        JSONObject data = new JSONObject();
-        data.put("cipherText", sealedKey);
-        JSONObject respJsonObject = callApi(endPoint, data.toJSONString());
-        String plaintext = (respJsonObject.get("decryptedData")).toString();
-        return plaintext;
+    private String decryptEnvValue(String encryptedValue, String key) throws Exception {
+        SecretKey secretKey = createSecretKeyFromBase64(key);
+        byte[] encryptedBytes = decodeBase64(encryptedValue);
+        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
+        cipher.init(Cipher.DECRYPT_MODE, secretKey);
+        return new String(cipher.doFinal(encryptedBytes), StandardCharsets.UTF_8);
     }

-    public String transferEnvDecrypt(DataKeyDTO.envDecrpyt reqDto) throws Exception {
-        KMS_API_BASE_URI = reqDto.getEndpointUrl();
-        accessKey=reqDto.getAccessKey();
-        accessSecretKey=reqDto.getSecretKey();
-        method="POST";
-        headerProjectId=reqDto.getProjectId();
-        headerClientType="OpenApi";
-
+    private JSONObject performHttpPost(String url, String body, Map<String, String> headers) throws Exception {
+        HttpsURLConnection connection = null;
+        try {
+            URL endpoint = new URL(url);
+            connection = (HttpsURLConnection) endpoint.openConnection();
+            connection.setRequestMethod("POST");
+            connection.setDoOutput(true);
+            headers.forEach(connection::setRequestProperty);
+
+            try (OutputStream os = connection.getOutputStream()) {
+                os.write(body.getBytes(StandardCharsets.UTF_8));
+            }

-        String decryptedEnv = decryptEnv(reqDto.getCipherText());
+            int responseCode = connection.getResponseCode();
+            InputStream responseStream = (responseCode == 200)
+                    ? connection.getInputStream()
+                    : connection.getErrorStream();

-        return decryptedEnv;
+            return (JSONObject) new JSONParser().parse(new InputStreamReader(responseStream, StandardCharsets.UTF_8));
+        } finally {
+            if (connection != null) connection.disconnect();
+        }
     }

-    public String decryptEnv(String cipherText) throws Exception {
-        String decryptedCipherText=decryptWithKey(cipherText,scfEncryptKey);
-        // JSON 문자열을 Map으로 변환
-        Map<String, String> resultMap = convertJsonToMap(decryptedCipherText);
-
-        // "encryptedDataKey"에 해당하는 값을 추출
-        String encryptedDataKey = resultMap.get("encryptedDataKey");
-        String masterKey = resultMap.get("masterKey");
-        String cipherEnv = resultMap.get("cipherEnv");
-        KEY_NAME = masterKey;
-        String decryptedDataKey = decryptDataKey(encryptedDataKey);
-        //TODO 복호화 하는 부분 코딩해야함 - 240611 - Sonny
-        // ↓↓↓↓ 복호화 추가 TBD ↓↓↓↓
-
-        //decryptedDataKey를 통해 cipherEnv를 복호화하는 로직 추가 필요
-
-        // ↑↑↑↑ 복호화 추가 TBD ↑↑↑↑
-
-        // 추후 return 값으로 cipherEnv에 대한 복호화 변수값 반환 필요
-        return decryptedCipherText;
+    private String encryptWithKey(String targetData, String key) throws Exception {
+        SecretKey secretKey = createSecretKeyFromBase64(key);
+        byte[] encryptedBytes = encryptData(targetData.getBytes(StandardCharsets.UTF_8), secretKey);
+        return encodeBase64(encryptedBytes);
     }

-    private static String decryptWithKey(String targetData, String managerKey) throws Exception {
-        // Base64 디코딩된 키
-        //byte[] decodedKey = Base64.getDecoder().decode(mangerKey);
-        byte[] managerKeyBytes = Arrays.copyOf(managerKey.getBytes(StandardCharsets.UTF_8), 16);
-        // SecretKey 객체 생성
-        SecretKey secretKey = new SecretKeySpec(managerKeyBytes, "AES");
-        // 암호문 Base64 디코딩
-        byte[] encryptedBytes = Base64.getDecoder().decode(targetData);
-        // Cipher 객체 초기화
+    private String decryptWithKey(String encryptedData, String key) throws Exception {
+        SecretKey secretKey = createSecretKeyFromBase64(key);
+        byte[] encryptedBytes = decodeBase64(encryptedData);
         Cipher cipher = Cipher.getInstance("AES");
         cipher.init(Cipher.DECRYPT_MODE, secretKey);
+        return new String(cipher.doFinal(encryptedBytes), StandardCharsets.UTF_8);
+    }
+
+    private String encodeBase64(byte[] bytes) {
+        return Base64.getEncoder().encodeToString(bytes);
+    }

-        // 복호화 수행
-        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
+    private byte[] decodeBase64(String base64String) {
+        return Base64.getDecoder().decode(base64String);
+    }

-        // 복호화된 데이터를 문자열로 변환
-        return new String(decryptedBytes);
+    private String convertMapToJson(Map<String, String> map) {
+        return new JSONObject(map).toJSONString();
     }
+
 }

j1.son@j1-son002 MINGW64 /c/project/functions-manager (refactoring-kmsservice)
