코드 리팩토링 및 개선
FileManagerService 클래스는 파일 관리와 관련된 여러 기능을 제공하고 있지만, 다음과 같은 문제가 있습니다:

중복된 코드

파일 확장자 및 콘텐츠 타입 처리 로직에서 중복된 코드가 많습니다.
반복적으로 사용되는 로직을 별도로 추출할 필요가 있습니다.
가독성 부족

메서드의 길이가 길고, 단일 메서드가 여러 책임을 가지고 있어 가독성이 떨어집니다.
이를 개선하기 위해 메서드를 분리하고 이름을 명확히 할 필요가 있습니다.
예외 처리 부족 및 불명확한 메시지

예외 처리 메시지가 구체적이지 않고, 특정 예외 상황에 대한 추가 정보 제공이 필요합니다.
전역 변수 의존

videoAllows, imageAllows 등 배열 변수가 전역으로 설정되어 있고, 초기화되지 않은 상태에서 접근할 가능성이 있습니다.
리팩토링 코드
java
코드 복사
@Slf4j
@Service
@RequiredArgsConstructor
public class FileManagerService {
    private final FileManagerRepository fileManagerRepository;

    private static final String SAVE_PATH = "files";
    private static final List<String> VIDEO_EXTENSIONS = List.of("mp4", "wmv", "avi");
    private static final List<String> IMAGE_EXTENSIONS = List.of("png", "jpg", "jpeg", "gif");
    private static final List<String> AUDIO_EXTENSIONS = List.of("mp3", "wav", "flac");
    private static final List<String> PPT_EXTENSIONS = List.of("ppt", "pptx");

    /**
     * 파일 등록
     */
    @Transactional
    public FileManagerDTO.Response registerFileManager(FileManagerDTO.Register reqDto) {
        FileManager fileManager = fileManagerRepository.save(FileManager.register(reqDto));
        return fileManager.toDto();
    }

    /**
     * 파일 목록 검색
     */
    @Transactional(readOnly = true)
    public Page<FileManagerDTO.Response> searchAllFileManager(FileManagerDTO.Search reqDto) {
        return fileManagerRepository.searchAllFileManager(reqDto);
    }

    /**
     * 단일 파일 검색
     */
    @Transactional(readOnly = true)
    public FileManagerDTO.Response searchFileManager(Long fileSeq) {
        FileManager fileManager = fileManagerRepository.findById(fileSeq)
                .orElseThrow(() -> new ResourceNotFoundException("파일매니저 데이터를 찾을 수 없습니다."));
        return fileManager.toDto();
    }

    /**
     * 파일 수정
     */
    @Transactional
    public FileManagerDTO.Response modifyFileManager(Long fileSeq, FileManagerDTO.Modify reqDto) {
        FileManager fileManager = fileManagerRepository.findById(fileSeq)
                .orElseThrow(() -> new ResourceNotFoundException("파일매니저 데이터를 찾을 수 없습니다."));
        fileManager.modify(reqDto);
        return fileManagerRepository.save(fileManager).toDto();
    }

    /**
     * 단일 파일 저장
     */
    public FileManagerDTO.Response saveFile(MultipartFile file) {
        validateFile(file);
        try {
            Path root = createDirectoryIfNotExists(SAVE_PATH);
            Path filePath = root.resolve(file.getOriginalFilename());
            Files.copy(file.getInputStream(), filePath, StandardCopyOption.REPLACE_EXISTING);
            log.info("File saved: {}", filePath);
            return FileManagerDTO.Response.builder().filePath(filePath.toString()).build();
        } catch (IOException e) {
            throw new FileException("파일 저장 중 오류 발생: " + file.getOriginalFilename(), e);
        }
    }

    /**
     * 다중 파일 업로드
     */
    public List<FileManagerDTO.Response> uploadFiles(List<MultipartFile> files) {
        List<FileManagerDTO.Response> responses = new ArrayList<>();
        for (MultipartFile file : files) {
            if (!file.isEmpty()) {
                responses.add(saveFile(file));
            }
        }
        return responses;
    }

    /**
     * 파일명 중복 방지를 위한 MD5 생성
     */
    public static String generateMD5(String input) throws NoSuchAlgorithmException {
        MessageDigest md = MessageDigest.getInstance("MD5");
        byte[] hash = md.digest(input.getBytes());
        StringBuilder hexString = new StringBuilder();
        for (byte b : hash) {
            hexString.append(String.format("%02x", b));
        }
        return hexString.toString();
    }

    /**
     * MediaType 생성
     */
    public static MediaType getMediaType(String filename) {
        String extension = FilenameUtils.getExtension(filename).toLowerCase();
        return switch (extension) {
            case "png" -> MediaType.IMAGE_PNG;
            case "jpeg", "jpg" -> MediaType.IMAGE_JPEG;
            case "gif" -> MediaType.IMAGE_GIF;
            case "mp4", "wmv", "avi" -> MediaType.parseMediaType("video/mp4");
            case "zip" -> MediaType.parseMediaType("application/zip");
            case "pdf" -> MediaType.parseMediaType("application/pdf");
            case "ppt", "pptx" -> MediaType.parseMediaType("application/vnd.ms-powerpoint");
            case "doc" -> MediaType.parseMediaType("application/msword");
            default -> null;
        };
    }

    /**
     * 콘텐츠 타입 체크
     */
    public static ContentsType checkContentType(MultipartFile file) {
        String extension = getFileExtension(file.getOriginalFilename());
        if (VIDEO_EXTENSIONS.contains(extension)) return ContentsType.Video;
        if (IMAGE_EXTENSIONS.contains(extension)) return ContentsType.Image;
        if (AUDIO_EXTENSIONS.contains(extension)) return ContentsType.Audio;
        if (PPT_EXTENSIONS.contains(extension)) return ContentsType.PPT;
        return ContentsType.ETC;
    }

    /**
     * 파일 확장자 추출
     */
    public static String getFileExtension(String filename) {
        if (filename == null || filename.isEmpty()) return "";
        return FilenameUtils.getExtension(filename).toLowerCase();
    }

    /**
     * 디렉토리 생성 유틸
     */
    private Path createDirectoryIfNotExists(String path) {
        try {
            Path dir = Paths.get(path);
            if (!Files.exists(dir)) {
                Files.createDirectories(dir);
            }
            return dir;
        } catch (IOException e) {
            throw new FileException("디렉토리 생성 실패: " + path, e);
        }
    }

    /**
     * 파일 검증 유틸
     */
    private void validateFile(MultipartFile file) {
        if (file == null || file.isEmpty()) {
            throw new FileException("업로드된 파일이 비어있습니다.");
        }
    }
}
주요 개선 사항 및 이유
중복 코드 제거

콘텐츠 타입, 파일 확장자 관련 로직에서 중복된 부분을 제거하고 공통 메서드로 통합했습니다.
예: getFileExtension, checkContentType.
가독성 향상

메서드 길이를 줄이고, 메서드명을 명확히 하여 각 메서드가 수행하는 작업을 쉽게 파악할 수 있게 했습니다.
예: saveFile 메서드 내에서 디렉토리 생성과 파일 저장 로직 분리.
예외 처리 강화

각 메서드에서 발생 가능한 예외에 대해 상세한 메시지를 추가하고, 예외 정보를 캡슐화한 FileException을 활용했습니다.
전역 변수 제거

videoAllows 등의 전역 변수를 상수 리스트로 변경하여 초기화되지 않은 상태에서 접근할 위험을 제거했습니다.
Java 17+ switch 표현식 사용

getMediaType 메서드에서 switch 표현식을 활용해 가독성을 높였습니다.
리팩토링 효과
가독성: 코드가 더 간결하고, 각 메서드의 역할이 명확해졌습니다.
유지보수성: 중복 코드를 제거해 새로운 기능 추가 시 수정 범위가 줄어들었습니다.
안정성: 예외 처리 메시지를 명확히 하여 디버깅 및 사용자 경험이 개선되었습니다.
확장성: 상수 리스트와 공통 메서드를 활용해 새로운 콘텐츠 타입이나 확장자가 추가되어도 코드 수정이 최소화됩니다.
