$ git diff main...38-central-control|cat
diff --git a/Makefile b/Makefile
index 31be5e8..fd05a2f 100644
--- a/Makefile
+++ b/Makefile
@@ -61,7 +61,7 @@ vet: ## Run go vet against code.

 .PHONY: test
 test: manifests generate fmt vet envtest ## Run tests.
-       KUBEBUILDER_ASSETS="$(shell $(ENVTEST) use $(ENVTEST_K8S_VERSION) --bin-dir $(LOCALBIN) -p path)" go test -v $$(go list ./... | grep -v /e2e) -coverprofile cover.out
+       KUBEBUILDER_ASSETS="$(shell $(ENVTEST) use $(ENVTEST_K8S_VERSION) --bin-dir $(LOCALBIN) -p path)" go test --failfast -p 1 -v $$(go list ./... | grep -v /e2e) -coverprofile cover.out

 # Utilize Kind or modify the e2e tests to load the image locally, enabling compatibility with other vendors.
 .PHONY: test-e2e  # Run the e2e tests against a Kind k8s instance that is spun up.
diff --git a/cmd/main.go b/cmd/main.go
index 3d81b22..44b698b 100644
--- a/cmd/main.go
+++ b/cmd/main.go
@@ -40,7 +40,7 @@ import (

        "github.com/kuoss/ingress-annotator/controllers/configmapcontroller"
        "github.com/kuoss/ingress-annotator/controllers/ingresscontroller"
-       "github.com/kuoss/ingress-annotator/controllers/namespacecontroller"
+       "github.com/kuoss/ingress-annotator/pkg/matcher"
        "github.com/kuoss/ingress-annotator/pkg/rulesstore"
        // +kubebuilder:scaffold:imports
 )
@@ -153,21 +153,13 @@ func run(mgr ctrl.Manager, ctx context.Context) error {
                return fmt.Errorf("unable to create ConfigMapReconciler: %w", err) // test unreachable
        }

-       ingressReconciler := &ingresscontroller.IngressReconciler{
-               Client:     mgr.GetClient(),
-               RulesStore: rulesStore,
-       }
-
-       if err = ingressReconciler.SetupWithManager(mgr); err != nil {
+       if err = (&ingresscontroller.IngressReconciler{
+               Client:  mgr.GetClient(),
+               Matcher: matcher.New(rulesStore),
+       }).SetupWithManager(mgr); err != nil {
                return fmt.Errorf("unable to create IngressReconciler: %w", err) // test unreachable
        }

-       if err = (&namespacecontroller.NamespaceReconciler{
-               Client:            mgr.GetClient(),
-               IngressReconciler: ingressReconciler,
-       }).SetupWithManager(mgr); err != nil {
-               return fmt.Errorf("unable to create NamespaceReconciler: %w", err) // test unreachable
-       }
        // +kubebuilder:scaffold:builder

        if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil {
diff --git a/cmd/main_test.go b/cmd/main_test.go
index cba1734..21a0fa3 100644
--- a/cmd/main_test.go
+++ b/cmd/main_test.go
@@ -127,7 +127,7 @@ func TestRun(t *testing.T) {
                                ObjectMeta: metav1.ObjectMeta{Namespace: "test-namespace", Name: "ingress-annotator"},
                                Data:       map[string]string{"rules": "invalid rules"},
                        },
-                       wantError: "unable to start rules store: failed to initialize RulesStore: failed to extract rules from configMap: failed to unmarshal rules: yaml: unmarshal errors:\n  line 1: cannot unmarshal !!str `invalid...` into model.Rules",
+                       wantError: "unable to start rules store: failed to initialize RulesStore: failed to extract rules from configMap: failed to unmarshal rules: yaml: unmarshal errors:\n  line 1: cannot unmarshal !!str `invalid...` into []model.Rule",
                },
                {
                        name:      "Error setting up ready check",
diff --git a/config/rbac/role.yaml b/config/rbac/role.yaml
index 1eb6f5d..122ccbb 100644
--- a/config/rbac/role.yaml
+++ b/config/rbac/role.yaml
@@ -26,30 +26,6 @@ rules:
   - get
   - patch
   - update
-- apiGroups:
-  - ""
-  resources:
-  - namespaces
-  verbs:
-  - get
-  - list
-  - patch
-  - update
-  - watch
-- apiGroups:
-  - ""
-  resources:
-  - namespaces/finalizers
-  verbs:
-  - update
-- apiGroups:
-  - ""
-  resources:
-  - namespaces/status
-  verbs:
-  - get
-  - patch
-  - update
 - apiGroups:
   - networking.k8s.io
   resources:
diff --git a/controllers/configmapcontroller/configmap_controller_test.go b/controllers/configmapcontroller/configmap_controller_test.go
index 009c37f..706384a 100644
--- a/controllers/configmapcontroller/configmap_controller_test.go
+++ b/controllers/configmapcontroller/configmap_controller_test.go
@@ -13,6 +13,7 @@ import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
+       "sigs.k8s.io/controller-runtime/pkg/reconcile"

        "github.com/kuoss/ingress-annotator/pkg/rulesstore"
        "github.com/kuoss/ingress-annotator/pkg/testutil/fakeclient"
@@ -75,7 +76,7 @@ func TestConfigMapReconciler_Reconcile(t *testing.T) {
                        name:       "Requeue on ConfigMap Get error",
                        clientOpts: &fakeclient.ClientOpts{GetError: "*"},
                        cm:         createConfigMap("default", "ingress-annotator", ""),
-                       newCM:      createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       newCM:      createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        nn:         types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN:  types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        want:       ctrl.Result{RequeueAfter: 30 * time.Second},
@@ -85,7 +86,7 @@ func TestConfigMapReconciler_Reconcile(t *testing.T) {
                        name:       "Requeue when ConfigMap not found",
                        clientOpts: &fakeclient.ClientOpts{GetNotFoundError: true},
                        cm:         createConfigMap("default", "ingress-annotator", ""),
-                       newCM:      createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       newCM:      createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        nn:         types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN:  types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        want:       ctrl.Result{RequeueAfter: 30 * time.Second},
@@ -94,39 +95,39 @@ func TestConfigMapReconciler_Reconcile(t *testing.T) {
                        name:       "Error during Ingress list should result in requeue",
                        clientOpts: &fakeclient.ClientOpts{ListError: true},
                        cm:         createConfigMap("default", "ingress-annotator", ""),
-                       newCM:      createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       newCM:      createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        nn:         types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN:  types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
-                       want:       ctrl.Result{},
+                       want:       reconcile.Result{},
                        wantError:  "failed to annotateAllIngresses: failed to list ingresses: mocked ListError",
                },
                {
                        name:      "Unmarshal error on invalid ConfigMap data",
-                       cm:        createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       cm:        createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        newCM:     createConfigMap("default", "ingress-annotator", "invalid rules"),
                        nn:        types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN: types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        want:      ctrl.Result{RequeueAfter: 30 * time.Second},
-                       wantError: "failed to update rules in rules store: failed to extract rules from configMap: failed to unmarshal rules: yaml: unmarshal errors:\n  line 1: cannot unmarshal !!str `invalid...` into model.Rules",
+                       wantError: "failed to update rules in rules store: failed to extract rules from configMap: failed to unmarshal rules: yaml: unmarshal errors:\n  line 1: cannot unmarshal !!str `invalid...` into []model.Rule",
                },
                {
                        name:      "No requeue when ConfigMap has no changes",
-                       cm:        createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
-                       newCM:     createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       cm:        createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
+                       newCM:     createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        nn:        types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN: types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        want:      ctrl.Result{},
                },
                {
                        name:      "Process valid ConfigMap without errors or requeue",
-                       cm:        createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       cm:        createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        nn:        types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN: types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        want:      ctrl.Result{},
                },
                {
                        name:      "No errors when request name differs from ConfigMap name",
-                       cm:        createConfigMap("default", "ingress-annotator", "rule1:\n  key1: value1"),
+                       cm:        createConfigMap("default", "ingress-annotator", "- description: rule1\n  annotations:\n    key1: value1"),
                        nn:        types.NamespacedName{Namespace: "default", Name: "ingress-annotator"},
                        requestNN: types.NamespacedName{Namespace: "default", Name: "xxx"},
                        want:      ctrl.Result{},
diff --git a/controllers/ingresscontroller/ingress_controller.go b/controllers/ingresscontroller/ingress_controller.go
index d2d5ea5..0f77827 100644
--- a/controllers/ingresscontroller/ingress_controller.go
+++ b/controllers/ingresscontroller/ingress_controller.go
@@ -19,7 +19,6 @@ package ingresscontroller
 import (
        "context"
        "encoding/json"
-       "strings"
        "time"

        "github.com/go-logr/logr"
@@ -29,21 +28,20 @@ import (
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

+       "github.com/kuoss/ingress-annotator/pkg/matcher"
        "github.com/kuoss/ingress-annotator/pkg/model"
-       "github.com/kuoss/ingress-annotator/pkg/rulesstore"
        "github.com/kuoss/ingress-annotator/pkg/util"
 )

 type ingressScope struct {
-       logger             logr.Logger
-       namespace          *corev1.Namespace
-       ingress            *networkingv1.Ingress
-       updatedAnnotations model.Annotations
+       logger    logr.Logger
+       namespace *corev1.Namespace
+       ingress   *networkingv1.Ingress
 }

 type IngressReconciler struct {
        client.Client
-       RulesStore rulesstore.IRulesStore
+       *matcher.Matcher
 }

 // +kubebuilder:rbac:groups=networking.k8s.io,resources=ingresses,verbs=get;list;watch;update;patch
@@ -74,15 +72,6 @@ func (r *IngressReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ct
                return ctrl.Result{}, nil
        }

-       // ensure remove annotation key 'reconcile'
-       if _, exists := ingress.Annotations[model.ReconcileKey]; exists {
-               delete(ingress.Annotations, model.ReconcileKey)
-               if err := r.Update(ctx, &ingress); err != nil {
-                       return ctrl.Result{}, err
-               }
-               return ctrl.Result{Requeue: true}, nil
-       }
-
        // Fetch Namespace resource
        var namespace corev1.Namespace
        if err := r.Get(ctx, client.ObjectKey{Name: ingress.Namespace}, &namespace); err != nil {
@@ -91,10 +80,9 @@ func (r *IngressReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ct

        // Initialize ingressScope
        scope := &ingressScope{
-               logger:             logger,
-               namespace:          &namespace,
-               ingress:            &ingress,
-               updatedAnnotations: copyAnnotations(ingress.Annotations), // Copy to avoid mutating original map
+               logger:    logger,
+               namespace: &namespace,
+               ingress:   &ingress,
        }

        // Reconcile Ingress
@@ -102,87 +90,69 @@ func (r *IngressReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ct
 }

 func (r *IngressReconciler) reconcileIngress(ctx context.Context, scope *ingressScope) (ctrl.Result, error) {
-       originalAnnotations := copyAnnotations(scope.updatedAnnotations)
-       r.removeManagedAnnotations(scope)
-       r.addNewAnnotations(scope)
+       ingress := scope.ingress
+       logger := scope.logger

-       // Early exit if there are no changes to annotations.
-       if annotationsEqual(originalAnnotations, scope.updatedAnnotations) {
+       toBeAnnotations := r.GetToBeAnnotations(ctx, scope)
+
+       // Early exit silently if there are no changes to annotations.
+       if annotationsEqual(toBeAnnotations, ingress.Annotations) {
                return ctrl.Result{}, nil
        }

-       // Update the Ingress resource with new annotations.
-       scope.ingress.Annotations = scope.updatedAnnotations
-       if err := r.Update(ctx, scope.ingress); err != nil {
-               scope.logger.Error(err, "Failed to update Ingress with new annotations")
+       ingress.Annotations = toBeAnnotations
+       if err := r.Update(ctx, ingress); err != nil {
+               logger.Error(err, "Failed to update Ingress with to-be annotations")
                return ctrl.Result{RequeueAfter: 30 * time.Second}, err
        }

-       scope.logger.Info("Successfully reconciled Ingress with new annotations")
+       logger.Info("Successfully reconciled Ingress with to-be annotations")
        return ctrl.Result{}, nil
 }

-func copyAnnotations(annotations map[string]string) map[string]string {
-       if annotations == nil {
-               return make(map[string]string)
-       }
-       copy := make(map[string]string, len(annotations))
-       for k, v := range annotations {
-               copy[k] = v
-       }
-       return copy
-}
+func (r *IngressReconciler) GetToBeAnnotations(ctx context.Context, scope *ingressScope) model.Annotations {
+       ingress := scope.ingress
+       logger := scope.logger
+
+       toBeAnnotations := copyAnnotations(ingress.Annotations)
+       delete(toBeAnnotations, model.ReconcileKey)

-func (r *IngressReconciler) removeManagedAnnotations(scope *ingressScope) {
-       managedAnnotations := make(model.Annotations)
-       if value, ok := scope.ingress.Annotations[model.ManagedAnnotationsKey]; ok && value != "" {
+       // remove managed annotations if exists
+       if value, exists := toBeAnnotations[model.ManagedAnnotationsKey]; exists {
+               managedAnnotations := make(model.Annotations)
                if err := json.Unmarshal([]byte(value), &managedAnnotations); err != nil {
-                       scope.logger.Error(err, "Warning: Failed to unmarshal managed annotations")
+                       logger.Error(err, "Warning: Failed to unmarshal managed annotations")
+               } else {
+                       for key, value := range managedAnnotations {
+                               if currentValue, exists := toBeAnnotations[key]; exists && currentValue == value {
+                                       delete(toBeAnnotations, key)
+                               }
+                       }
                }
+               delete(toBeAnnotations, model.ManagedAnnotationsKey)
        }

-       for key, value := range managedAnnotations {
-               if currentValue, exists := scope.updatedAnnotations[key]; exists && currentValue == value {
-                       delete(scope.updatedAnnotations, key)
+       // add annotations by rules matched
+       annotationsByRules := r.Matcher.GetAnnotationsForIngress(ingress)
+       if len(annotationsByRules) > 0 {
+               for key, value := range annotationsByRules {
+                       toBeAnnotations[key] = value
                }
+               b := util.MustMarshalJSON(annotationsByRules)
+               toBeAnnotations[model.ManagedAnnotationsKey] = string(b) + "\n"
        }
-       delete(scope.updatedAnnotations, model.ManagedAnnotationsKey)
+       return toBeAnnotations
 }

-func (r *IngressReconciler) addNewAnnotations(scope *ingressScope) {
-       newAnnotations := r.getNewAnnotations(scope)
-       for key, value := range newAnnotations {
-               scope.updatedAnnotations[key] = value
-       }
-       if len(newAnnotations) == 0 {
-               return
+func copyAnnotations(annotations map[string]string) map[string]string {
+       if annotations == nil {
+               return make(map[string]string)
        }
-
-       b := util.MustMarshalJSON(newAnnotations)
-       scope.updatedAnnotations[model.ManagedAnnotationsKey] = string(b) + "\n"
-}
-
-func (r *IngressReconciler) getNewAnnotations(scope *ingressScope) model.Annotations {
-       ruleNames := r.getRuleNames(scope)
-       rules := r.RulesStore.GetRules()
-       newAnnotations := make(model.Annotations)
-
-       for _, ruleName := range ruleNames {
-               if annotations, exists := (*rules)[ruleName]; exists {
-                       for k, v := range annotations {
-                               newAnnotations[k] = v
-                       }
-               } else {
-                       scope.logger.Info("Warning: no ruleName in rules", "ruleName", ruleName)
-               }
+       copy := make(map[string]string, len(annotations))
+       for k, v := range annotations {
+               copy[k] = v
        }
-       return newAnnotations
-}
-
-func (r *IngressReconciler) getRuleNames(scope *ingressScope) []string {
-       namespaceRuleNames := getRuleNamesFromObject(scope.namespace, model.RulesKey)
-       ingressRuleNames := getRuleNamesFromObject(scope.ingress, model.RulesKey)
-       return mergeRuleNames(namespaceRuleNames, ingressRuleNames)
+       return copy
 }

 func annotationsEqual(a, b map[string]string) bool {
@@ -196,38 +166,3 @@ func annotationsEqual(a, b map[string]string) bool {
        }
        return true
 }
-
-func mergeRuleNames(names1, names2 []string) []string {
-       seen := make(map[string]bool)
-       result := []string{}
-
-       for _, name := range names1 {
-               if !seen[name] {
-                       seen[name] = true
-                       result = append(result, name)
-               }
-       }
-
-       for _, name := range names2 {
-               if !seen[name] {
-                       seen[name] = true
-                       result = append(result, name)
-               }
-       }
-
-       return result
-}
-
-func getRuleNamesFromObject(obj client.Object, key string) []string {
-       if value, ok := obj.GetAnnotations()[key]; ok && value != "" {
-               names := strings.Split(value, ",")
-               var cleaned []string
-               for _, name := range names {
-                       if trimmedName := strings.TrimSpace(name); trimmedName != "" {
-                               cleaned = append(cleaned, trimmedName)
-                       }
-               }
-               return cleaned
-       }
-       return []string{}
-}
diff --git a/controllers/ingresscontroller/ingress_controller_test.go b/controllers/ingresscontroller/ingress_controller_test.go
index d394f45..95ec29c 100644
--- a/controllers/ingresscontroller/ingress_controller_test.go
+++ b/controllers/ingresscontroller/ingress_controller_test.go
@@ -5,6 +5,7 @@ import (
        "testing"
        "time"

+       "github.com/go-logr/logr"
        "github.com/jmnote/tester/testcase"
        "github.com/stretchr/testify/assert"
        "go.uber.org/mock/gomock"
@@ -14,173 +15,219 @@ import (
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"

+       "github.com/kuoss/ingress-annotator/pkg/matcher"
        "github.com/kuoss/ingress-annotator/pkg/model"
        "github.com/kuoss/ingress-annotator/pkg/testutil/fakeclient"
        "github.com/kuoss/ingress-annotator/pkg/testutil/mocks"
 )

-func TestIngressReconciler_SetupWithManager(t *testing.T) {
+func TestSetupWithManager(t *testing.T) {
        mockCtrl := gomock.NewController(t)
        defer mockCtrl.Finish()

        store := mocks.NewMockIRulesStore(mockCtrl)
+       matcher := matcher.New(store)

        client := fakeclient.NewClient(nil)
        reconciler := &IngressReconciler{
-               Client:     client,
-               RulesStore: store,
+               Client:  client,
+               Matcher: matcher,
        }

        err := reconciler.SetupWithManager(fakeclient.NewManager())
        assert.NoError(t, err)
 }

-func TestIngressReconciler_Reconcile(t *testing.T) {
+func TestReconcile_ok(t *testing.T) {
        mockCtrl := gomock.NewController(t)
        defer mockCtrl.Finish()

        testCases := []struct {
                name               string
                clientOpts         *fakeclient.ClientOpts
-               requestNN          *types.NamespacedName
                ingressAnnotations map[string]string
                deletionTimestamp  *metav1.Time
                finalizers         []string
                wantResult         ctrl.Result
                wantAnnotations    map[string]string
-               wantError          string
-               wantGetError       string
        }{
                {
-                       name:       "IngressExistsButNoAnnotations_ShouldReturnDefaultResult",
-                       requestNN:  &types.NamespacedName{Namespace: "default", Name: "my-ingress"},
-                       wantResult: ctrl.Result{},
-               },
-               {
-                       name:              "IngressWithDeletionTimestampAndFinalizer_ShouldHandleDeletion",
+                       name:              "HandleDeletion_WhenIngressHasDeletionTimestampAndFinalizer",
                        deletionTimestamp: &metav1.Time{Time: time.Now()},
                        finalizers:        []string{"test-finalizer"},
-                       requestNN:         &types.NamespacedName{Namespace: "default", Name: "my-ingress"},
-                       wantResult:        ctrl.Result{},
-               },
-               {
-                       name:         "IngressDoesNotExist_ShouldReturnNotFoundError",
-                       requestNN:    &types.NamespacedName{Namespace: "default", Name: "xxx"},
-                       wantResult:   ctrl.Result{},
-                       wantGetError: `ingresses.networking.k8s.io "xxx" not found`,
+
+                       wantResult: ctrl.Result{},
                },
                {
-                       name: "ReconcileAnnotationTrue_ShouldRequeue",
