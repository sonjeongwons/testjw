/*
Copyright 2024.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"time"

	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	servingv1 "knative.dev/serving/pkg/apis/serving/v1"
	modulev1 "scf.scp.samsungsds.com/crd/api/v1"
)

// ScfWatcherReconciler reconciles a ScfWatcher object
type ScfWatcherReconciler struct {
	client.Client
	Scheme *runtime.Scheme
}

// Function Status JSON Data
type FunctionStatusData struct {
	functionStatus string
}

const (
	StatusTrue      = "True"
	StatusFalse     = "False"
	StatusUnknown   = "Unkown"
	StatusActive    = "Active"
	StatusSuccess   = "Success"
	StatusFail      = "Fail"
	StatusReady     = "READY"
	StatusNotReady  = "NOT_READY"
	StatusDeploying = "DEPLOYING"
)
const MaxRetryCount = 3

//+kubebuilder:rbac:groups=module.scf.scp.samsungsds.com,resources=scfwatchers,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=module.scf.scp.samsungsds.com,resources=scfwatchers/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=module.scf.scp.samsungsds.com,resources=scfwatchers/finalizers,verbs=update
//+kubebuilder:rbac:groups=serving.knative.dev,resources=services,verbs=get;list;watch;update;patch
//+kubebuilder:rbac:groups=core,resources=configmaps,verbs=get;list;watch

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the ScfWatcher object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.18.4/pkg/reconcile
func (r *ScfWatcherReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	logger := log.FromContext(ctx)
	logger.Info("Reconcile 시작")

	// TODO(user): your logic here
	// 1. ScfWatcher CR 객체 가져오기
	var scfWatcher modulev1.ScfWatcher
	if err := r.Get(ctx, req.NamespacedName, &scfWatcher); err != nil {
		logger.Error(err, "Unable to fetch ScfWatcher")
		return ctrl.Result{}, client.IgnoreNotFound(err)
	}

	// 2-1 관련된 Knative Service 가져오기
	var ksvc servingv1.Service
	if err := r.Get(ctx, client.ObjectKey{Namespace: scfWatcher.Spec.KsvcNamespace, Name: scfWatcher.Spec.KsvcName}, &ksvc); err != nil {
		logger.Error(err, "Unable to fetch Knative Service")
		return ctrl.Result{}, err
	}

	// 2-2 LB Health 상태 조회
	lbId := scfWatcher.Spec.LoadbalancerId
	lbHealthStatus, err := getLBHealthStatus(ctx, lbId)
	if err != nil {
		logger.Error(err, "Error getting LB health status: %v")

		// 재시도 횟수 초과 확인
		if scfWatcher.Status.RetryCount >= MaxRetryCount {
			logger.Info("최대 재시도 횟수 초과. Requeue 중지")
			return ctrl.Result{}, nil
		}

		// 재시도 횟수 증가
		scfWatcher.Status.RetryCount++
		_=r.Status().Update(ctx, &scfWatcher)

		return ctrl.Result{RequeueAfter: 5 * time.Second}, nil
	}

		// 정상 동작 시 재시도 횟수 초기화
		if scfWatcher.Status.RetryCount > 0 {
			scfWatcher.Status.RetryCount = 0
			_=r.Status().Update(ctx, &scfWatcher)
		}

	logger.Info("LB 헬스체크 상태 값 : " + lbHealthStatus)

	// 2-3 LB DNS연결 여부 조회
	lbDnsConnectivity, err := checkLBDnsConnectivity(ctx, "cp-scf-manager.scf-manager-cp")
	if err != nil {
		logger.Error(err, "Error getting DNS Connectivity: %v")

		// 재시도 횟수 초과 확인
		if scfWatcher.Status.RetryCount >= MaxRetryCount {
			logger.Info("최대 재시도 횟수 초과. Requeue 중지")
			return ctrl.Result{}, nil
		}

		// 재시도 횟수 증가
		scfWatcher.Status.RetryCount++
		_=r.Status().Update(ctx, &scfWatcher)

		return ctrl.Result{RequeueAfter: 5 * time.Second}, nil
	}

	// 정상 동작 시 재시도 횟수 초기화
	if scfWatcher.Status.RetryCount > 0 {
		scfWatcher.Status.RetryCount = 0
		_=r.Status().Update(ctx, &scfWatcher)
	}

	logger.Info("DNS 연결 여부 : " + lbDnsConnectivity)

	// 3. 현재 상태와 이전 상태를 비교합니다.
	currentStatus := getStatusFromKsvc(ksvc)
	logger.Info("기존상태 : " + scfWatcher.Status.LastKsvcStatus)
	logger.Info("신규상태" + currentStatus)

	// LB헬스체크 및 DNS연결 관련 ScfWatcher의 상태를 업데이트
	scfWatcher.Status.LoadBalancerHealthStatus = lbHealthStatus
	scfWatcher.Status.LoadBalancerEndpointDnsConnectivity = lbDnsConnectivity
	if err := r.Client.Status().Update(ctx, &scfWatcher); err != nil {
		logger.Error(err, "Unable to update ScfWatcher status")
		return ctrl.Result{}, err
	}
	logger.Info("ScfWatcher CR Status 업데이트 완료")
	logger.Info("ScfWatcher CR Status 업데이트 값 : ", "LB헬스체크 : ", lbHealthStatus, "DNS연결 : ", lbDnsConnectivity)

	if scfWatcher.Status.LastKsvcStatus == StatusTrue && currentStatus == StatusTrue && lbHealthStatus == StatusActive && lbDnsConnectivity == StatusSuccess {
		// 상태에 변화가 없으면 Reconcile을 반복하지 않음
		logger.Info("Knative상태, LB헬스체크 상태, DNS Lookup 이상없음")
		return ctrl.Result{}, nil
	}
	logger.Info("상태비교 끝")

	// 4. Watcher ConfigMap 정보 불러오기
	//var configMap corev1.ConfigMap
	//if err := r.Get(ctx, client.ObjectKey{Namespace: "scf-watcher", Name: "watcher-config"}, &configMap); err != nil {
	//logger.Error(err, "Unable to fetch Watcher ConfigMap")
	//return ctrl.Result{}, err
	//}

	logger.Info("scf-manager 엔드포인트 불러오기")
	// 5. Watcher ConfigMap으로 부터 MANAGER_ENDPOINT 정보 불러오기
	//managerEndpoint := configMap.Data["MANAGER_ENDPOINT"]
	managerEndpoint := "http://cp-scf-manager.scf-manager-cp:8080/api/v2/function/status/"
	if managerEndpoint == "" {
		logger.Error(nil, "MANAGER_ENDPOINT not found in ConfigMap")
		return ctrl.Result{}, fmt.Errorf("MANAGER_ENDPOINT not found in ConfigMap")
	}

	// 6. scf-manager에게 상태 업데이트 전송
	returnStatus := StatusDeploying

	// Function URL 기능 활성화 여부 검사
	functionUrlEnabled := scfWatcher.Spec.FunctionUrlEnabled
	if functionUrlEnabled {
		if currentStatus == StatusTrue && lbHealthStatus == StatusActive && lbDnsConnectivity == StatusSuccess {
			returnStatus = StatusReady
		} else if currentStatus == StatusFail && lbHealthStatus != StatusActive && lbDnsConnectivity == StatusFail {
			returnStatus = StatusNotReady
		}
	} else {
		if currentStatus == StatusTrue {
			returnStatus = StatusReady
		} else if currentStatus == StatusFail {
			returnStatus = StatusNotReady
		}
	}

	statusMessage := map[string]string{"functionStatus": returnStatus}
	if err := sendStatusToManager(ctx, managerEndpoint, statusMessage, scfWatcher.Spec.KsvcName); err != nil {
		logger.Error(err, "Failed to send status update to manager")
		return ctrl.Result{}, err
	}
	logger.Info("상태전송", "status", returnStatus)

	// 6. ksvc 상태 관련 ScfWatcher의 상태를 업데이트
	scfWatcher.Status.LastKsvcStatus = currentStatus
	scfWatcher.Status.LastReportedTime = metav1.Now()
	if err := r.Client.Status().Update(ctx, &scfWatcher); err != nil {
		logger.Error(err, "Unable to update ScfWatcher status")
		return ctrl.Result{}, err
	}
	logger.Info("ScfWatcher CR Status 업데이트 완료")
	logger.Info("ScfWatcher CR Status 업데이트 값 : " + currentStatus)
	return ctrl.Result{}, nil
}

// getStatusFromKsvc 함수는 Knative 서비스의 현재 상태를 확인
func getStatusFromKsvc(ksvc servingv1.Service) string {
	for _, condition := range ksvc.Status.Conditions {
		if condition.Type == "Ready" {
			if condition.Status == corev1.ConditionTrue {
				return StatusTrue
			} else if condition.Status == corev1.ConditionFalse {
				return StatusFail
			} else {
				return StatusUnknown
			}
		}
	}
	return StatusUnknown
}

// sendStatusToManager 함수는 상태를 Manager endpoint로 전송
func sendStatusToManager(ctx context.Context, endpoint string, status map[string]string, ksvcName string) error {
	logger := log.FromContext(ctx)
	statusJSON, err := json.Marshal(status)
	if err != nil {
		return err
	}
	//resp, err := http.Post(endpoint+":"+ksvcName, "application/json", bytes.NewBuffer(statusJSON))
	req, err := http.NewRequest(http.MethodPut, endpoint+ksvcName, bytes.NewBuffer(statusJSON))
	log.Log.Info("Here is endpoint : " + endpoint + ksvcName)
	//log.Log.Info("Here is JsonBody : "+statusJSON)
	if err != nil {
		logger.Error(err, "Failed to make Request")
		return err
	}

	req.Header.Set("Content-Type", "application/json")
	client := &http.Client{}
	resp, err := client.Do(req)

	if err != nil {
		logger.Error(err, "Failed to send API to Manager")
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to report status: %v", resp.Status)
	}
	return nil
}

// SetupWithManager sets up the controller with the Manager.
func (r *ScfWatcherReconciler) SetupWithManager(mgr ctrl.Manager) error {
	return ctrl.NewControllerManagedBy(mgr).
		For(&modulev1.ScfWatcher{}).                                                                       // ScfWatcher 리소스를 관찰
		Watches(&servingv1.Service{}, handler.EnqueueRequestsFromMapFunc(r.findObjectsForKnativeService)). // Knative Service 리소스를 관찰
		Complete(r)
}

func (r *ScfWatcherReconciler) findObjectsForKnativeService(ctx context.Context, obj client.Object) []reconcile.Request {
	scfWatchers := &modulev1.ScfWatcherList{}
	err := r.List(ctx, scfWatchers)
	if err != nil {
		return []reconcile.Request{}
	}

	var requests []reconcile.Request
	for _, scfWatcher := range scfWatchers.Items {
		if scfWatcher.Spec.KsvcName == obj.GetName() && scfWatcher.Spec.KsvcNamespace == obj.GetNamespace() {
			requests = append(requests, reconcile.Request{
				NamespacedName: types.NamespacedName{
					Name:      scfWatcher.Name,
					Namespace: scfWatcher.Namespace,
				},
			})
		}
	}
	return requests
}

// LB 상태를 가져오는 함수 (LB API 호출 시뮬레이션)
func getLBHealthStatus(ctx context.Context, lbId string) (string, error) {
	logger := log.FromContext(ctx)
	// 여기에 LB API 호출 코드를 넣으면 됨.
	// 지금은 예시로, API 호출한 결과를 받아오는 부분을 시뮬레이션

	// 실제 구현에서는 HTTP 요청하거나 SDK 클라이언트 호출하는 식으로 작성.
	req, err := http.NewRequest(http.MethodGet, "http://cp-scf-manager.scf-manager-cp:8080/api/v2/function/status/"+lbId, nil)
	if err != nil {
		logger.Error(err, "Failed to make Request")
		return "", err
	}

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logger.Error(err, "Failed to send API to LB")
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to get LB health status: %v", resp.Status)
	}

	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	return string(bodyBytes), nil
}

// LB DNS 등록 확인 함수
func checkLBDnsConnectivity(ctx context.Context, endpoint string) (string, error) {
	logger := log.FromContext(ctx)
	// nslookup 대체로 net.LookupHost 사용
	_, err := net.LookupHost(endpoint)
	if err != nil {
		logger.Error(err, "Failed to connext DNS")
		return StatusFail, err
	}
	return StatusSuccess, nil
}
