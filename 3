🔹 개선된 코드
java
복사
편집
package com.scf.manager.mvc.service;

import com.scf.manager.common.crd.*;
import io.fabric8.kubernetes.api.model.KubernetesResourceList;
import io.fabric8.kubernetes.client.KubernetesClient;
import io.fabric8.kubernetes.client.KubernetesClientBuilder;
import io.fabric8.kubernetes.client.dsl.MixedOperation;
import io.fabric8.kubernetes.client.dsl.Resource;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j
@Service
@RequiredArgsConstructor
public class FunctionRabbitMQService {

    private static final String NAMESPACE = "rabbitmq";
    private static final String CONNECTION_SECRET_NAME = "rabbitmq-cluster-secret-credentials";

    private MixedOperation<RabbitMQSource, KubernetesResourceList<RabbitMQSource>, Resource<RabbitMQSource>> getRabbitMQSourceClient(KubernetesClient client) {
        return client.resources(RabbitMQSource.class);
    }

    public void registerRabbitMQSource(String rabbitMQSourceName) {
        try (KubernetesClient client = new KubernetesClientBuilder().build()) {
            MixedOperation<RabbitMQSource, KubernetesResourceList<RabbitMQSource>, Resource<RabbitMQSource>> rabbitMQSourceClient = getRabbitMQSourceClient(client);

            RabbitMQSource rabbitMQSource = createRabbitMQSource(rabbitMQSourceName);

            // 기존 리소스 삭제 후 생성
            rabbitMQSourceClient.inNamespace(NAMESPACE).withName(rabbitMQSourceName).delete();
            rabbitMQSourceClient.inNamespace(NAMESPACE).create(rabbitMQSource);
        } catch (Exception e) {
            log.error("Exception occurred in registerRabbitMQSource: {}", e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }

    public void deleteRabbitMQSource(String rabbitMQSourceName) {
        try (KubernetesClient client = new KubernetesClientBuilder().build()) {
            MixedOperation<RabbitMQSource, KubernetesResourceList<RabbitMQSource>, Resource<RabbitMQSource>> rabbitMQSourceClient = getRabbitMQSourceClient(client);

            rabbitMQSourceClient.inNamespace(NAMESPACE).withName(rabbitMQSourceName).delete();
        } catch (Exception e) {
            log.error("Exception occurred in deleteRabbitMQSource: {}", e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }

    private RabbitMQSource createRabbitMQSource(String rabbitMQSourceName) {
        RabbitMQSourceSpec rabbitMQSourceSpec = RabbitMQSourceSpec.builder()
                .rabbitmqClusterReference(
                        RabbitMQClusterReferenceSpec.builder()
                                .connectionSecret(
                                        ConnectionSecretSpec.builder()
                                                .name(CONNECTION_SECRET_NAME)
                                                .build()
                                )
                                .namespace(NAMESPACE)
                                .build()
                )
                .rabbitMQResourcesConfig(
                        RabbitMQResourcesConfigSpec.builder()
                                .exchangeName(rabbitMQSourceName)
                                .parallelism(1)
                                .queueName(rabbitMQSourceName)
                                .predeclared(false)
                                .build()
                )
                .sink(
                        SinkSpec.builder()
                                .ref(
                                        RefSpec.builder()
                                                .apiVersion("serving.knative.dev/v1")
                                                .kind("Service")
                                                .name("scf-d79013ae-bb79-445d-be77-f0c9b4a78e8f-api")
                                                .namespace("scf-d79013ae-bb79-445d-be77-f0c9b4a78e8f-api")
                                                .build()
                                )
                                .build()
                )
                .build();

        RabbitMQSource rabbitMQSource = new RabbitMQSource();
        rabbitMQSource.getMetadata().setName(rabbitMQSourceName);
        rabbitMQSource.getMetadata().setNamespace(NAMESPACE);
        rabbitMQSource.setSpec(rabbitMQSourceSpec);

        return rabbitMQSource;
    }
}
📌 개선 사항 및 이유
각 메소드 단위로 어떤 점을 개선했는지 자세히 설명하겠다.

1️⃣ registerRabbitMQSource() 메소드 개선
🔺 기존 코드 문제점
RabbitMQSourceSpec 생성 로직이 registerRabbitMQSource() 내에 포함되어 있어, 메소드가 너무 길어짐 → SRP(Single Responsibility Principle) 위반
NAMESPACE와 CONNECTION_SECRET_NAME 같은 값이 하드코딩되어 있음 → Magic String 사용
예외 처리 시 e.getStackTrace()[0]을 사용하여 예외 위치를 로깅하는데, 스택의 첫 번째 요소만 출력하는 것은 부적절하며 전체 스택 트레이스를 로깅하는 것이 더 효과적임
KubernetesClient를 직접 인스턴스화하는 것이 반복됨
🛠 개선 작업
createRabbitMQSource() 메소드를 분리하여, RabbitMQSourceSpec을 생성하는 책임을 별도로 분리 → 단일 책임 원칙(SRP) 준수
NAMESPACE와 CONNECTION_SECRET_NAME을 static final 상수로 선언하여 Magic String 제거
e.getStackTrace()[0] 대신 e.getMessage()와 Throwable을 로그로 남겨 전체 예외 메시지를 확인할 수 있도록 개선
getRabbitMQSourceClient() 메소드를 추가하여 MixedOperation 객체를 재사용하도록 변경
2️⃣ deleteRabbitMQSource() 메소드 개선
🔺 기존 코드 문제점
KubernetesClient를 직접 인스턴스화하는 것이 중복됨
e.getStackTrace()[0]을 통한 예외 처리 방식이 적절하지 않음
🛠 개선 작업
getRabbitMQSourceClient() 메소드를 사용하여 중복 코드 제거
예외 메시지를 보다 명확하게 출력하고, Throwable을 함께 로깅하여 전체적인 스택 트레이스를 확인할 수 있도록 변경
3️⃣ createRabbitMQSource() 메소드 추가
🔺 기존 코드 문제점
RabbitMQSourceSpec을 생성하는 코드가 registerRabbitMQSource() 내에 있어, 메소드가 너무 복잡하고 길어짐
RabbitMQSource 객체를 생성하는 과정이 중복적으로 포함됨
🛠 개선 작업
createRabbitMQSource() 메소드를 별도로 정의하여 객체 생성의 책임을 분리하고, registerRabbitMQSource()에서의 역할을 단순화함
4️⃣ getRabbitMQSourceClient() 메소드 추가
🔺 기존 코드 문제점
KubernetesClient를 생성한 후, MixedOperation<RabbitMQSource, KubernetesResourceList<RabbitMQSource>, Resource<RabbitMQSource>> 객체를 매번 생성해야 했음
🛠 개선 작업
getRabbitMQSourceClient() 메소드를 추가하여 MixedOperation을 재사용 가능하도록 분리하여 중복 코드 제거
📌 리팩토링 결과 요약
변경 내용	개선 전	개선 후
Magic String 제거	"rabbitmq" 등의 하드코딩된 문자열 존재	static final 상수 사용
단일 책임 원칙(SRP) 준수	registerRabbitMQSource()에서 모든 처리를 수행	createRabbitMQSource()로 RabbitMQSource 생성 로직 분리
중복 코드 제거	MixedOperation을 생성하는 코드가 여러 곳에 존재	getRabbitMQSourceClient() 메소드 추가
예외 처리 개선	e.getStackTrace()[0]으로 로깅	e.getMessage()와 전체 Throwable 로깅
메소드 가독성 향상	긴 코드 블록 존재	메소드 분리로 역할 명확화
✅ 기대되는 효과
코드가 보다 가독성이 좋아지고 유지보수성이 향상됨
registerRabbitMQSource() 메소드가 보다 명확한 책임을 가지게 됨
중복 코드 제거로 인해 코드 재사용성 증가
예외 처리를 보다 안전하고 명확하게 수행하여, 디버깅이 용이해짐
이제 코드가 보다 클린하고 유지보수하기 좋은 형태가 되었다. 추가적인 개선이 필요하면 더 말해줘!
