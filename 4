@Transactional
public FunctionDTO.Response registerFunction(FunctionDTO.Register reqDto) throws IOException, ParseException {
    validateFunctionRequest(reqDto);

    if (isFunctionExists(reqDto.getFunctionKey(), reqDto.getDisplayName(), reqDto.getProjectId())) {
        throw new FunctionAlreadyExistsException("이미 존재하는 펑션 키 또는 펑션명을 사용하였습니다.");
    }

    reqDto.setName(generateFunctionName());
    reqDto.setFunctionStatus(TypeEnums.FunctionStatus.NOT_READY);

    if (!reqDto.getRuntime().startsWith("Java")) {
        reqDto.setContent(generateBaseCode(reqDto));
    }

    Function function = functionRepository.save(Function.register(reqDto));
    initializeFunction(function, reqDto);

    return function.toDto();
}

private void validateFunctionRequest(FunctionDTO.Register reqDto) {
    if (StringUtils.isAnyEmpty(reqDto.getFunctionKey(), reqDto.getProjectId(), reqDto.getUserId(), reqDto.getEndPointType(), reqDto.getRuntime())) {
        throw new InvalidFunctionRequestException("필수 입력값을 확인해주세요.");
    }
}

@Transactional
public FunctionDTO.Response registerFunctionCode(FunctionDTO.Register reqDto, String functionKey) throws IOException, ParseException {
    Function function = getFunctionByKey(functionKey);
    function.updateContent(reqDto.getContent());

    if (shouldDeployFunction(function)) {
        deployFunction(function);
    }

    return function.toDto();
}

@Transactional(readOnly = true)
public FunctionDTO.Response searchFunction(String functionKey) {
    Function function = getFunctionByKey(functionKey);
    FunctionDTO.Response output = AppUtil.getMapper().map(function, FunctionDTO.Response.class);
    output.setEndPointUrls(UrlUtil.generateUrl(function.getName(), function.getRegion(), "none"));

    Trigger trigger = triggerRepository.findByFunction(function).orElse(null);
    output.setTriggerType(trigger != null ? trigger.getTriggerType() : "unknown");
    output.setTriggerConnectedYn(trigger != null ? trigger.getTriggerConnectedYn() : "N");

    return output;
}

private Function getFunctionByKey(String functionKey) {
    return functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new FunctionNotFoundException("펑션이 존재하지 않습니다. FunctionKey: " + functionKey));
}

private boolean shouldDeployFunction(Function function) {
    return function.isReady();
}

private void deployFunction(Function function) {
    function.setFunctionStatus(TypeEnums.FunctionStatus.DEPLOYING);
    functionRepository.save(function);
    knativeService.callIstioAndKnative(function);
}

@Transactional
public void deleteFunction(String functionKey) {
    Function function = getFunctionByKey(functionKey);
    if (function.isReady() || function.isDeploying()) {
        kn.services().inNamespace(function.getName()).withName(function.getName()).delete();
        istioCallService.deleteIstioPolicy(function.getName());
    }

    deleteRelatedResources(function);
    function.modifyDelYn();
    functionRepository.save(function);
}

private void deleteRelatedResources(Function function) {
    allowIpRepository.deleteAll(allowIpRepository.findByFunction(function));
    functionEnvironmentRepository.deleteAll(functionEnvironmentRepository.findByFunction(function));
    keyManagerRepository.findByFunctionAndDelYn(function, "N").ifPresent(keyManagerRepository::delete);
    sourceFileRepository.findByFunction(function).ifPresent(sourceFileRepository::delete);
}

@Transactional
public void updateEnvironment(List<FunctionEnvironmentDTO.Register> reqDto, String functionKey) {
    Function function = getFunctionByKey(functionKey);
    reqDto.forEach(dto -> saveEnvironment(dto, function));
}

private void saveEnvironment(FunctionEnvironmentDTO.Register dto, Function function) {
    dto.setFunctionSeq(function.getFunctionSeq());
    functionEnvironmentRepository.save(FunctionEnvironment.register(dto));
}




🔹 PR 2: 예외 처리 개선 및 서비스 계층 정리 - 확장된 종합 요약
PR 2에서는 예외 처리 일관성 강화, 불필요한 코드 제거, 서비스 계층 정리를 통해 코드의 품질을 더욱 향상시켰습니다.
추가적으로 다양한 메소드에서도 클린 코드 원칙 및 리팩토링 기법을 적용하여 더욱 완벽한 개선이 이루어졌습니다.

📌 PR 2의 주요 개선 사항
1️⃣ 일관된 예외 처리 적용
🔹 문제점
기존 코드에서는 RuntimeException을 직접 사용하여 예외의 의미가 불명확.
"펑션이 존재하지 않습니다." 등의 예외 메시지가 일관되지 않거나 충분한 정보가 부족.
null 체크를 직접 수행하여 예외 발생을 수동으로 처리해야 했음.
✅ 개선 사항
커스텀 예외 클래스(FunctionNotFoundException, FunctionAlreadyExistsException, InvalidFunctionRequestException) 추가하여 더 명확한 의미 전달.
Optional.orElseThrow() 활용하여 불필요한 null 체크 제거 및 예외 발생을 자동화.
FunctionNotFoundException 발생 시 함수 키 포함하여 더 많은 정보 제공.
📌 개선된 코드
java
복사
편집
private Function getFunctionByKey(String functionKey) {
    return functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new FunctionNotFoundException("펑션이 존재하지 않습니다. FunctionKey: " + functionKey));
}
이제 함수 조회 시 null 체크 없이 getFunctionByKey(functionKey)를 호출하면 자동으로 예외가 발생하고, 의미 있는 메시지가 포함됨.

2️⃣ 중복 코드 제거 및 가독성 향상
🔹 문제점
registerFunctionCode, searchFunction, deleteFunction 등에서 같은 로직을 여러 번 수행.
validateFunctionRequest에서 각 필드를 isEmpty()로 검사하는 코드가 반복됨.
✅ 개선 사항
getFunctionByKey 메소드 추가 → 중복된 findByFunctionKey 로직 제거.
StringUtils.isAnyEmpty() 활용 → 유효성 검사 코드를 간결하게 변경.
deleteRelatedResources 메소드 추가하여 deleteFunction 내부에서 중복된 삭제 로직을 분리.
📌 개선된 코드
java
복사
편집
private void validateFunctionRequest(FunctionDTO.Register reqDto) {
    if (StringUtils.isAnyEmpty(reqDto.getFunctionKey(), reqDto.getProjectId(), reqDto.getUserId(), reqDto.getEndPointType(), reqDto.getRuntime())) {
        throw new InvalidFunctionRequestException("필수 입력값을 확인해주세요.");
    }
}
이제 유효성 검사 코드가 한 줄로 간결하게 정리되었으며, 확장성 및 가독성이 향상됨.

3️⃣ 함수 삭제(deleteFunction) 로직 개선
🔹 문제점
함수 삭제 시 관련 리소스 삭제 로직이 deleteFunction 내부에서 직접 실행되어 코드가 길어짐.
삭제해야 하는 리소스 목록이 늘어나면 코드 변경이 필요하여 유지보수성이 떨어짐.
✅ 개선 사항
deleteRelatedResources 메소드를 추가하여 함수 삭제 로직을 모듈화.
deleteFunction에서 관련 리소스를 삭제할 때 repository의 deleteAll 메소드 사용하여 일괄 삭제 가능하도록 개선.
📌 개선된 코드
java
복사
편집
@Transactional
public void deleteFunction(String functionKey) {
    Function function = getFunctionByKey(functionKey);
    if (function.isReady() || function.isDeploying()) {
        kn.services().inNamespace(function.getName()).withName(function.getName()).delete();
        istioCallService.deleteIstioPolicy(function.getName());
    }

    deleteRelatedResources(function);
    function.modifyDelYn();
    functionRepository.save(function);
}

private void deleteRelatedResources(Function function) {
    allowIpRepository.deleteAll(allowIpRepository.findByFunction(function));
    functionEnvironmentRepository.deleteAll(functionEnvironmentRepository.findByFunction(function));
    keyManagerRepository.findByFunctionAndDelYn(function, "N").ifPresent(keyManagerRepository::delete);
    sourceFileRepository.findByFunction(function).ifPresent(sourceFileRepository::delete);
}
이제 함수 삭제 시 관련 리소스를 일괄 삭제할 수 있으며, 코드가 더 가독성 높고 유지보수하기 쉬워짐.

4️⃣ 환경 변수 업데이트 (updateEnvironment) 로직 개선
🔹 문제점
환경 변수를 업데이트할 때 루프 내부에서 직접 save() 호출하여 Batch Insert 비효율 발생.
중복된 getFunctionByKey(functionKey) 로직이 반복됨.
✅ 개선 사항
updateEnvironment에서 forEach를 활용하여 saveEnvironment 호출하도록 변경.
함수 정보 조회 로직을 getFunctionByKey(functionKey)로 통합하여 중복 제거.
📌 개선된 코드
java
복사
편집
@Transactional
public void updateEnvironment(List<FunctionEnvironmentDTO.Register> reqDto, String functionKey) {
    Function function = getFunctionByKey(functionKey);
    reqDto.forEach(dto -> saveEnvironment(dto, function));
}

private void saveEnvironment(FunctionEnvironmentDTO.Register dto, Function function) {
    dto.setFunctionSeq(function.getFunctionSeq());
    functionEnvironmentRepository.save(FunctionEnvironment.register(dto));
}
이제 환경 변수 업데이트 시 save() 호출이 일괄적으로 이루어지며, 성능 최적화 효과를 기대할 수 있음.

5️⃣ 배포 상태 변경 로직 개선
🔹 문제점
registerFunctionCode에서 함수 상태가 DEPLOYING으로 바뀌어야 할 경우, 직접 setFunctionStatus를 호출함.
상태 변경 및 저장 로직이 중복됨.
✅ 개선 사항
shouldDeployFunction 메소드 추가 → 배포 필요 여부를 명확하게 판단.
deployFunction 메소드 추가 → 중복된 상태 변경 로직 제거.
📌 개선된 코드
java
복사
편집
private boolean shouldDeployFunction(Function function) {
    return function.isReady();
}

private void deployFunction(Function function) {
    function.setFunctionStatus(TypeEnums.FunctionStatus.DEPLOYING);
    functionRepository.save(function);
    knativeService.callIstioAndKnative(function);
}
이제 registerFunctionCode에서는 shouldDeployFunction을 호출하여 배포 여부를 확인하고, 필요할 경우 deployFunction을 호출하여 중복된 상태 변경 로직을 줄임.

🔹 PR 2 - 최종 개선 효과
✅ 커스텀 예외 적용 → 예외 처리의 일관성과 의미 전달력 향상
✅ 중복 코드 제거 → getFunctionByKey, deployFunction, deleteRelatedResources 메소드 활용하여 재사용성 증가
✅ 유효성 검사 개선 → StringUtils.isAnyEmpty() 활용하여 코드 간결화
✅ 배포 로직 개선 → shouldDeployFunction, deployFunction 분리로 가독성 향상
✅ 환경 변수 업데이트 최적화 → saveEnvironment 분리 및 배치 최적화
✅ 삭제 로직 개선 → deleteRelatedResources 활용하여 함수 삭제 시 유지보수성 향상

