$ git diff develop...feature-function-alignAlias | cat
diff --git a/src/main/java/com/scf/manager/mvc/service/FunctionService.java b/src/main/java/com/scf/manager/mvc/service/FunctionService.java
index d269b96..a154418 100644
--- a/src/main/java/com/scf/manager/mvc/service/FunctionService.java
+++ b/src/main/java/com/scf/manager/mvc/service/FunctionService.java
@@ -134,9 +134,7 @@ public class FunctionService {
         reqDto.setName(generateFunctionName());
         reqDto.setFunctionStatus(TypeEnums.FunctionStatus.NOT_READY.getKey());

-        if (!reqDto.getRuntime().startsWith("Java")) {
-            reqDto.setContent(generateBaseCode(reqDto));
-        }
+        setFunctionContent(reqDto);

         Function function = functionRepository.save(Function.register(reqDto));
         initializeFunction(function, reqDto);
@@ -145,29 +143,43 @@ public class FunctionService {
     }

     private void validateFunctionRequest(FunctionDTO.Register reqDto) {
-        if (StringUtils.isEmpty(reqDto.getFunctionKey()) || StringUtils.isEmpty(reqDto.getProjectId())
-                || StringUtils.isEmpty(reqDto.getUserId()) || StringUtils.isEmpty(reqDto.getEndPointType())
-                || StringUtils.isEmpty(reqDto.getRuntime())) {
+        if (StringUtils.isEmpty(reqDto.getFunctionKey()) ||
+                StringUtils.isEmpty(reqDto.getProjectId()) ||
+                StringUtils.isEmpty(reqDto.getUserId()) ||
+                StringUtils.isEmpty(reqDto.getEndPointType()) ||
+                StringUtils.isEmpty(reqDto.getRuntime())) {
             throw new RuntimeException("필수 입력값을 확인해주세요.");
         }
     }

+    private void setFunctionContent(FunctionDTO.Register reqDto) {
+        if (!reqDto.getRuntime().startsWith("Java")) {
+            reqDto.setContent(generateBaseCode(reqDto));
+        }
+    }
+
     private boolean isFunctionExists(String functionKey, String displayName, String projectId) {
         return functionRepository.findByFunctionKeyAndDelYn(functionKey, "N").isPresent() ||
                 functionRepository.existsByDisplayNameAndProjectIdAndDelYn(displayName, projectId, "N");
     }

     private String generateFunctionName() {
-        return "scf-" + UUID.randomUUID() + "-api";
+        return String.format("scf-%s-api", UUID.randomUUID().toString().replace("-", ""));
     }

     private void initializeFunction(Function function, FunctionDTO.Register reqDto) throws IOException, ParseException {
         setEnvironment(function);
+        registerAllowedIPs(reqDto, function);
+        setupTriggers(function, reqDto);
+    }

+    private void registerAllowedIPs(FunctionDTO.Register reqDto, Function function) {
         if (!CollectionUtils.isEmpty(reqDto.getAllowIps())) {
             reqDto.getAllowIps().forEach(allowIp -> allowIpService.registerAllowIp(allowIp, function.getFunctionSeq()));
         }
+    }

+    private void setupTriggers(Function function, FunctionDTO.Register reqDto) throws IOException, ParseException {
         triggerService.createDefaultTrigger(function);

         if (function.getRuntime().startsWith("Java")) {
@@ -362,38 +374,21 @@ public class FunctionService {

     @Transactional
     public void deleteFunction(String functionKey) {
-
-        Function function = functionRepository.findByFunctionKey(functionKey).orElseThrow(() -> new ResourceNotFoundException("존재하지 않는 펑션입니다."));
+        Function function = functionRepository.findByFunctionKey(functionKey)
+                .orElseThrow(() -> new ResourceNotFoundException("존재하지 않는 펑션입니다."));

         if (function.isReady() || function.isDeploying()) {
-            kn.services().inNamespace(function.getName())
-                    .withName(function.getName()).delete();
-
+            kn.services().inNamespace(function.getName()).withName(function.getName()).delete();
             istioCallService.deleteIstioPolicy(function.getName());
-            this.deleteKnativeFunction(function.getName());
-            deleteUserPVC(function);
-            deleteUserEnvoyFilter(function);
-            deleteScfWatcherCustomResource(function);
-            deleteUserNamespace(function);
+            deleteNamespace(function);
+            cleanupFunctionResources(function);
         }

-        deleteRelatedResources(function);
-
-        //사용자 경로
-        String path = "/mb_scf/serverless" + "/"
-                + function.getName();
-        log.info("path = " + path);
-
-        AppUtil.deleteDirectory(path);
-
-        /* 함수 삭제 시 해당 함수의 Trigger 삭제 */
-        triggerService.deleteTrigger(function, true);
-
-        function.modifyDelYn();
-        functionRepository.save(function);
+        markFunctionAsDeleted(function);
     }

-    private void deleteRelatedResources(Function function) {
+
+    private void cleanupFunctionResources(Function function) {
         List<AllowIp> AllowIps = allowIpRepository.findByFunction(function);
         List<FunctionEnvironment> functionEnvironments = functionEnvironmentRepository.findByFunction(function);
         KeyManager keyManager = keyManagerRepository.findByFunctionAndDelYn(function, "N").orElse(null);
@@ -414,6 +409,20 @@ public class FunctionService {
         }
     }

+    private void deleteNamespace(Function function) {
+        try (KubernetesClient client = new DefaultKubernetesClient()) {
+            client.namespaces().withName(function.getName()).delete();
+            log.info("사용자 네임스페이스 {} 삭제 완료", function.getName());
+        } catch (Exception e) {
+            log.error("사용자 네임스페이스 삭제 중 오류 발생: {}", e.getMessage());
+        }
+    }
+
+    private void markFunctionAsDeleted(Function function) {
+        function.modifyDelYn();
+        functionRepository.save(function);
+    }
+

     @Transactional
     public TokenDTO.Response updateEnvironment(List<FunctionEnvironmentDTO.Register> reqDto, String functionkey) {
@@ -664,100 +673,42 @@ public class FunctionService {
     }

     // 함수 상태 정보 알림에 대한 동작 처리를 수행하는 서비스
+    @Transactional
     public FunctionDTO.Response updateFunctionStatus(FunctionDTO.Modify functionDtos, String name) throws IOException {
-        log.info("함수 상태 업데이트 API 호출");
-
-        // functionKey가 아닌 name (e.g. scf-xxx-api) 기준으로 쿼리 수행
-        Function function = functionRepository.findByName(name).orElseThrow(() -> new ResourceNotFoundException("존재하지 않는 펑션입니다."));
+        Function function = functionRepository.findByName(name)
+                .orElseThrow(() -> new ResourceNotFoundException("존재하지 않는 펑션입니다."));

-        // 1. 함수 상태 DB 업데이트
         function.setFunctionStatus(TypeEnums.FunctionStatus.valueOf(functionDtos.getFunctionStatus()));
-
-        log.info("함수 이름:" + function.getName());
-        log.info("함수 키:" + function.getFunctionKey());
-        log.info("함수 상태:" + function.getFunctionStatus());
-
-        // 함수 재배포 이후, 초기 상태가 일시적으로 False (NOT_READY)일 수 있음
-        // SCP-V의 함수 라이프사이클을 고려하여 scf-watcher에서 NOT_READY에 대한 이벤트가 전달 시에는 DB 내 함수 상태 정보 갱신 X
-        // 24.12.19 함수 상태가 DEPLOYING 상태로 유지되는 오류 수정을 위해 NOT READY 이벤트에 대해서도 함수 상태 갱신하도록 수정
         functionRepository.save(function);

-        // 2. 상태 변경 시, SCP 모듈로 상태 알림 API 호출 (클라우드 모니터링 연계)
-        log.info("클라우드 모니터링 연계를 위한 API 연계 동작 수행");
-
-        // 요청 전달할 URL 주소 정의 (APIM Endpoint + internal api)
-        URL url = new URL(apimEndpoint+"/cloud-function/v1/internal/cloud-functions/status");
-        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
-        connection.setConnectTimeout(timeOutValue);
-        connection.setReadTimeout(timeOutValue);
-        connection.setRequestMethod("POST"); // HTTP 요청 방식을 POST로 설정
-
-        /* 헤더 설정 */
-        connection.setRequestProperty("Content-Type", "application/json; utf-8"); // 요청의 컨텐츠 타입을 JSON으로 설정
-        connection.setRequestProperty("accept", "*/*");
-        connection.setRequestProperty("X-Cmp-ProjectId", function.getProjectId());
-        connection.setRequestProperty("Authorization", "Bearer "+ apimToken);
-
-        connection.setDoOutput(true); // 요청 본문에 데이터를 전송할 수 있도록 설정
-
-        /* 서버로 전송할 RequestBody의 Template Json 정의 */
-        String originBody = """
-                        {
-                                  "projectId": "$projectId$",
-                                  "eventData": null,
-                                  "loggingData": null,
-                                  "region": "$region$",
-                                  "requestBy": "$requestBy$",
-                                  "resourceId": "$resourceId$",
-                                  "resourceName": "$resourceName$",
-                                  "resourceState": "$resourceState$"
-                        }
-                    """;
-
-        /* 함수 상태 정보에 대한 분기 처리 */
-        /* 함수가 DEPLOYING 상태로 변경되었을 때 DEPLOYING 대신 NOT_READY 이벤트 전달 (클라우드 모니터링 기준) */
-        String resourceState = "";
-        if (function.isReady()) {
-            resourceState = "Ready";
-        } else {
-            resourceState = "Not Ready";
-        }
+        notifyCloudMonitoring(function);
+        return function.toDto();
+    }

-        /* 업데이트할 펑션의 데이터를 기반으로 RequestBody 생성 */
-        String requestBody = originBody.replace("$projectId$", function.getProjectId())
-                .replace("$region$", function.getRegion())
-                .replace("$requestBy$", function.getUserId())
-                .replace("$resourceId$", function.getFunctionKey())
-                .replace("$resourceName$", function.getDisplayName())
-                .replace("$resourceState$", resourceState);
+    private void notifyCloudMonitoring(Function function) throws IOException {
+        String resourceState = function.isReady() ? "Ready" : "Not Ready";

-        log.info(requestBody);
+        String requestBody = buildFunctionStatusJson(function, resourceState);
+        URL url = new URL(apimEndpoint + "/cloud-function/v1/internal/cloud-functions/status");
+        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
+        connection.setRequestMethod("POST");
+        connection.setRequestProperty("Content-Type", "application/json; utf-8");
+        connection.setRequestProperty("Authorization", "Bearer " + apimToken);
+        connection.setDoOutput(true);

-        /* Json 문자열을 byte 배열로 전환하여 전송 */
         try (OutputStream os = connection.getOutputStream()) {
-            byte[] input = requestBody.getBytes("utf-8");
-            os.write(input, 0, input.length);
+            os.write(requestBody.getBytes("utf-8"));
         }

-        int responseCode = connection.getResponseCode();
-
-        if(responseCode==HttpURLConnection.HTTP_OK){
-            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
-            StringBuffer stringBuffer = new StringBuffer();
-
-            // 서버의 응답을 저장하여 로그로 출력
-            String inputLine;
-            while ((inputLine = bufferedReader.readLine()) != null)  {
-                stringBuffer.append(inputLine);
-            }
-            bufferedReader.close();
-
-            log.info("SCP 함수 상태 갱신 API 정상 호출");
-            log.info(stringBuffer.toString());
-        } else {
-            log.warn("SCP 함수 상태 갱신 API 호출 실패: " + responseCode);
+        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
+            log.warn("SCP 함수 상태 갱신 API 호출 실패");
         }
+    }

-        return function.toDto();
+    private String buildFunctionStatusJson(Function function, String resourceState) {
+        return String.format(
+                "{\"projectId\": \"%s\", \"region\": \"%s\", \"requestBy\": \"%s\", \"resourceId\": \"%s\", \"resourceName\": \"%s\", \"resourceState\": \"%s\"}",
+                function.getProjectId(), function.getRegion(), function.getUserId(),
+                function.getFunctionKey(), function.getDisplayName(), resourceState);
     }
 }
\ No newline at end of file
