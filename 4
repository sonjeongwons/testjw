좋아, 지금 FunctionDTO.Search에 searchValue 하나만 있는 상황인데, 너는 이걸 단일 String이 아니라 2개 이상의 문자열로 받아서 OR 조건으로 displayName을 검색하고 싶다는 거지? 그렇다면 searchValue를 단일 String에서 List<String> 형태로 바꿔주는 게 핵심이야.


---

1단계: FunctionDTO.Search 수정

@Builder
public static class Search extends SearchParamDTO {
	private String accountId;
	private String userId;
	private String region;

	@Schema(description = "검색어 목록")
	private List<String> searchValues; // <- 기존 String searchValue에서 변경

	private String orderBy;
}

> 기존 searchValue 대신 searchValues: List<String>로 바꿔.




---

2단계: likeSearchDisplayName 수정

public BooleanExpression likeSearchDisplayName(FunctionDTO.Search reqDto) {
	List<String> searchValues = reqDto.getSearchValues();

	if (searchValues != null && !searchValues.isEmpty()) {
		BooleanExpression condition = null;
		for (String value : searchValues) {
			BooleanExpression expr = function.displayName.like("%" + value + "%");
			condition = (condition == null) ? expr : condition.or(expr);
		}
		return condition;
	}
	return null;
}

> 이 코드는 searchValues에 있는 각 검색어를 %value%로 like 검색해서 or 조건으로 묶어주는 방식이야.




---

3단계: 요청에서 리스트로 전달되도록 API 스펙 수정

예를 들어, Swagger 또는 프론트엔드에서 다음과 같이 호출하도록:

GET /functions?searchValues=alpha&searchValues=beta

이러면 Spring MVC에서는 자동으로 List<String>으로 매핑돼.


---

이렇게 하면 이제 다음과 같은 쿼리가 생성돼:

... WHERE display_name LIKE '%alpha%' OR display_name LIKE '%beta%' ...


---

Q1: 여러 필드(ex. displayName, functionKey)에 대해 동시에 OR 조건으로 검색하고 싶은데, 이건 어떻게 확장할 수 있을까?

Q2: 복합 검색 (AND/OR 조합) 쿼리를 유연하게 구성하려면 어떤 DSL 구조를 가져가는 게 좋을까?

Q3: 검색 키워드를 유저에게 더 유연하게 입력받고, AND/OR 조건을 지정하게 하려면 프론트와 백엔드 간 계약은 어떻게 설계하는 게 이상적일까?

