package com.cvc.scanner.service;

import com.cvc.scanner.config.TokenSecurityProperties;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.benmanes.caffeine.cache.Cache;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpStatusCodeException;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TokenService {

    private static final Logger log = LoggerFactory.getLogger(TokenService.class);

    @Value("${cvc.service.id}")
    private String cvcServiceId;

    @Value("${cvc.service.pw}")
    private String cvcServicePw;

    @Value("${iam.api.endpoint}")
    private String iamApiEndpoint;

    private final RestTemplate restTemplate;
    private final TokenSecurityProperties securityProps;
    private final Cache<String, String> adminTokenCache;

    private static final String ADMIN_TOKEN_CACHE_KEY = "adminToken";

    /** admin 토큰을 TTL 캐시에서 획득. 없으면 IAM에서 발급 후 캐시. */
    public String getCvcAdminToken() {
        String cached = adminTokenCache.getIfPresent(ADMIN_TOKEN_CACHE_KEY);
        if (cached != null && !cached.isBlank()) {
            log.debug("[AdminToken] cache=HIT token={}", maskToken(cached));
            return cached;
        }
        log.info("[AdminToken] cache=MISS. fetching from IAM endpoint={}", iamApiEndpoint);
        Instant t0 = Instant.now();
        String fresh = fetchAdminTokenFromIam();
        adminTokenCache.put(ADMIN_TOKEN_CACHE_KEY, fresh);
        log.info("[AdminToken] fetched and cached. costMs={} token={}",
                Duration.between(t0, Instant.now()).toMillis(), maskToken(fresh));
        return fresh;
    }

    /** IAM에서 admin 토큰 발급 */
    private String fetchAdminTokenFromIam() {
        String url = iamApiEndpoint;

        Map<String, Object> body = Map.of(
                "auth", Map.of(
                        "identity", Map.of(
                                "methods", List.of("password"),
                                "password", Map.of(
                                        "user", Map.of(
                                                "name", cvcServiceId,
                                                "domain", Map.of("name", "service"),
                                                "password", "***masked***"
                                        )
                                )
                        )
                )
        );

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(body, headers);

        try {
            Instant t0 = Instant.now();
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
            long cost = Duration.between(t0, Instant.now()).toMillis();

            String token = response.getHeaders().getFirst("X-Subject-Token");
            log.debug("[AdminToken] IAM POST status={} costMs={} hasTokenHeader={}",
                    response.getStatusCodeValue(), cost, token != null);

            if (token == null || token.isBlank()) {
                log.error("[AdminToken] missing X-Subject-Token header. status={} bodySize={}",
                        response.getStatusCodeValue(), safeLen(response.getBody()));
                throw new IllegalStateException("IAM으로부터 admin 토큰을 획득하지 못함");
            }
            return token;

        } catch (HttpStatusCodeException e) {
            log.error("[AdminToken] IAM POST failed status={} body={}",
                    e.getStatusCode().value(), safeSnippet(e.getResponseBodyAsString(), 512));
            throw e;
        } catch (Exception e) {
            log.error("[AdminToken] IAM POST unexpected error: {}", e.toString(), e);
            throw e;
        }
    }

    /**
     * 사용자 토큰 검증:
     * 1) user.domain.name == configured domain (대소문자 무시)
     * 2) user.name ∈ whitelist
     * 3) roles 내 admin 포함
     */
    public boolean validateToken(String userToken) {
        String url = iamApiEndpoint;
        String adminToken = getCvcAdminToken();

        HttpHeaders headers = new HttpHeaders();
        headers.set("X-Auth-Token", adminToken);
        headers.set("X-Subject-Token", userToken);

        HttpEntity<Void> request = new HttpEntity<>(headers);

        // 운영자 디버깅에 도움 되는 컨피그 로그 (info 1회/요청)
        log.debug("[Validate] cfg expectedDomain={} whitelist={}",
                nullSafeLower(securityProps.getUserDomain()),
                securityProps.getWhitelistUserNames());

        try {
            Instant t0 = Instant.now();
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);
            long cost = Duration.between(t0, Instant.now()).toMillis();

            if (!response.getStatusCode().is2xxSuccessful()) {
                log.warn("[Validate] IAM GET non-2xx status={} costMs={} body={}",
                        response.getStatusCodeValue(), cost, safeSnippet(response.getBody(), 512));
                return false;
            }
            if (response.getBody() == null) {
                log.warn("[Validate] IAM GET body=null costMs={}", cost);
                return false;
            }

            String body = response.getBody();
            log.debug("[Validate] IAM GET ok costMs={} bodySize={}", cost, safeLen(body));

            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode root = objectMapper.readTree(body);
            JsonNode tokenNode = root.path("token");

            // 추출: user/domain/roles
            String expectedDomain = nullSafeLower(securityProps.getUserDomain());
            String actualDomain = nullSafeLower(tokenNode.path("user").path("domain").path("name").asText(null));
            String userName     = tokenNode.path("user").path("name").asText(null);

            log.debug("[Validate] claims userName={} actualDomain={}", userName, actualDomain);

            // 1) domain 체크
            if (expectedDomain != null && !expectedDomain.equals(actualDomain)) {
                log.warn("[Validate] domain mismatch expected={} actual={}", expectedDomain, actualDomain);
                return false;
            }

            // 2) 화이트리스트 체크
            boolean whitelisted = isWhitelistedUser(userName);
            if (!whitelisted) {
                log.warn("[Validate] user not in whitelist userName={}", userName);
                return false;
            }

            // 3) admin role 체크
            JsonNode roles = tokenNode.path("roles");
            boolean isAdmin = hasAdminRole(roles);
            log.debug("[Validate] rolesCount={} isAdmin={}", roles != null && roles.isArray() ? roles.size() : -1, isAdmin);
            if (!isAdmin) {
                log.warn("[Validate] admin role missing for userName={}", userName);
                return false;
            }

            log.info("[Validate] success userName={} domain={} result=true", userName, actualDomain);
            return true;

        } catch (HttpStatusCodeException e) {
            log.error("[Validate] IAM GET failed status={} body={} userToken={} adminToken={}",
                    e.getStatusCode().value(),
                    safeSnippet(e.getResponseBodyAsString(), 512),
                    maskToken(userToken),
                    maskToken(adminToken));
            return false; // 운영 관점에선 401로 빠져야 하므로 false 반환
        } catch (Exception e) {
            log.error("[Validate] unexpected error: {} userToken={} adminToken={}",
                    e.toString(), maskToken(userToken), maskToken(adminToken), e);
            return false;
        }
    }

    private boolean isWhitelistedUser(String userName) {
        if (userName == null) {
            log.debug("[Whitelist] userName=null");
            return false;
        }
        Set<String> white = securityProps.getWhitelistUserNames()
                .stream()
                .filter(n -> n != null && !n.isBlank())
                .map(this::nullSafeLower)
                .collect(Collectors.toUnmodifiableSet());
        boolean contains = white.contains(userName.toLowerCase());
        log.debug("[Whitelist] userName={} allowed={}", userName, contains);
        return contains;
    }

    private boolean hasAdminRole(JsonNode roles) {
        if (roles == null || !roles.isArray()) {
            log.debug("[Roles] roles missing or not array");
            return false;
        }
        for (JsonNode role : roles) {
            String roleName = role.path("name").asText("");
            if ("admin".equalsIgnoreCase(roleName)) {
                return true;
            }
        }
        return false;
    }

    /** 보안: 토큰 마스킹(앞 6자리만 노출) */
    private String maskToken(String t) {
        if (t == null) return "null";
        int keep = Math.min(6, t.length());
        return t.substring(0, keep) + "****(" + t.length() + ")";
    }

    /** 본문 길이만 로깅 */
    private int safeLen(String s) {
        return s == null ? -1 : s.length();
    }

    /** 본문 스니펫 로깅(민감값 있을 수 있으므로 길이 제한) */
    private String safeSnippet(String s, int max) {
        if (s == null) return "null";
        String snippet = s.replaceAll("\\s+", " ");
        return snippet.length() <= max ? snippet : snippet.substring(0, max) + "...";
    }

    private String nullSafeLower(String s) {
        return (s == null) ? null : s.toLowerCase();
    }
}
