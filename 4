아래 java 스프링프레임워크로 만든 TokenService.java 코드를 개선하고싶어.
해당 로직들마다 로그를 추가하여 로직 수행 중 에러발생하거나 인증 토큰이 유효하지않거나 조건에 맞지않을때에 로그를 남겨 디버깅할때 참고되도록 개선하고싶어.
로그를 남길때에 어떤 데이터가 주고받고 처리되고있는지에 대해서도 로그에 남기면 어플리케이션 운영할때 정말 도움될거같아 로그가 남겨지도록 로그를 추가해봐

package com.cvc.scanner.service;

import com.cvc.scanner.config.TokenSecurityProperties;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.benmanes.caffeine.cache.Cache;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TokenService {

    @Value("${cvc.service.id}")
    private String cvcServiceId;

    @Value("${cvc.service.pw}")
    private String cvcServicePw;

    @Value("${iam.api.endpoint}")
    private String iamApiEndpoint;

    private final RestTemplate restTemplate;
    private final TokenSecurityProperties securityProps;
    private final Cache<String, String> adminTokenCache;

    private static final String ADMIN_TOKEN_CACHE_KEY = "adminToken";

    /**
     * admin 토큰을 TTL 캐시에서 획득. 없으면 Keystone에서 발급 후 캐시.
     */
    public String getCvcAdminToken() {
        String cached = adminTokenCache.getIfPresent(ADMIN_TOKEN_CACHE_KEY);
        if (cached != null && !cached.isBlank()) {
            return cached;
        }
        String fresh = fetchAdminTokenFromIam();
        adminTokenCache.put(ADMIN_TOKEN_CACHE_KEY, fresh);
        return fresh;
    }

    private String fetchAdminTokenFromIam() {
        String url = iamApiEndpoint;

        Map<String, Object> body = Map.of(
                "auth", Map.of(
                        "identity", Map.of(
                                "methods", List.of("password"),
                                "password", Map.of(
                                        "user", Map.of(
                                                "name", cvcServiceId,
                                                "domain", Map.of("name", "service"),
                                                "password", cvcServicePw
                                        )
                                )
                        )
                )
        );

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(body, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);

        String token = response.getHeaders().getFirst("X-Subject-Token");
        if (token == null || token.isBlank()) {
            throw new IllegalStateException("Keystone으로부터 admin 토큰을 획득하지 못함");
        }
        return token;
    }

    /**
     * 사용자 토큰 검증:
     * 1) user.domain.name == configured domain (대소문자 무시)
     * 2) user.name ∈ whitelist
     * 3) roles 내 admin 포함
     */
    public boolean validateToken(String userToken) {
        String url = iamApiEndpoint;
        String adminToken = getCvcAdminToken();

        HttpHeaders headers = new HttpHeaders();
        headers.set("X-Auth-Token", adminToken);
        headers.set("X-Subject-Token", userToken);

        HttpEntity<Void> request = new HttpEntity<>(headers);

        try {
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);
            if (!response.getStatusCode().is2xxSuccessful() || response.getBody() == null) {
                return false;
            }

            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode root = objectMapper.readTree(response.getBody());
            JsonNode tokenNode = root.path("token");

            // Q1) domain.name == configured domain ?
            String expectedDomain = nullSafeLower(securityProps.getUserDomain());
            String actualDomain = nullSafeLower(tokenNode.path("user").path("domain").path("name").asText(null));
            if (expectedDomain != null && !expectedDomain.equals(actualDomain)) {
                return false;
            }

            // Q2) user.name in whitelist ?
            String userName = tokenNode.path("user").path("name").asText(null);
            if (!isWhitelistedUser(userName)) {
                return false;
            }

            // admin role ?
            JsonNode roles = tokenNode.path("roles");
            if (!hasAdminRole(roles)) {
                return false;
            }

            return true;

        } catch (Exception e) {
            throw new RuntimeException("토큰 검증 응답 파싱 오류", e);
        }
    }

    private boolean isWhitelistedUser(String userName) {
        if (userName == null) return false;
        // 설정값을 소문자 Set으로 정규화
        Set<String> white = securityProps.getWhitelistUserNames()
                .stream()
                .filter(n -> n != null && !n.isBlank())
                .map(this::nullSafeLower)
                .collect(Collectors.toUnmodifiableSet());
        return white.contains(userName.toLowerCase());
    }

    private boolean hasAdminRole(JsonNode roles) {
        if (roles == null || !roles.isArray()) return false;
        for (JsonNode role : roles) {
            String roleName = role.path("name").asText("");
            if ("admin".equalsIgnoreCase(roleName)) {
                return true;
            }
        }
        return false;
    }

    private String nullSafeLower(String s) {
        return (s == null) ? null : s.toLowerCase();
    }
}
