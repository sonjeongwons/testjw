리팩토링 및 클린 코드 개선 사항

코드의 품질을 향상시키기 위해 SOLID 원칙, 중복 제거, 의미 있는 네이밍, 예외 처리 개선, 의존성 최소화, 객체 지향적 설계 개선 등의 여러 기법을 적용했습니다.
PR을 3개로 나누어 구조적인 리팩토링, 클린 코드 적용, 성능 개선 및 예외 처리 강화로 진행합니다.


---

PR 1: 구조적인 리팩토링 (SRP 적용 & 중복 제거)

목적: 단일 책임 원칙(Single Responsibility Principle) 적용, 중복 코드 제거 및 역할 분리


1. registerFunction()

변경 사항

1. validateFunctionRequest(reqDto) 검증 메서드 위치 변경


2. 중복되는 if (!reqDto.getRuntime().startsWith("Java")) 검사를 메서드로 분리


3. initializeFunction(function, reqDto) 내부 로직을 메서드로 세분화하여 가독성 향상



변경 코드

@Transactional
public FunctionDTO.Response registerFunction(FunctionDTO.Register reqDto) throws IOException, ParseException {
    validateFunctionRequest(reqDto);

    if (isFunctionExists(reqDto.getFunctionKey(), reqDto.getDisplayName(), reqDto.getProjectId())) {
        throw new RuntimeException("이미 존재하는 펑션 키 또는 펑션명을 사용하였습니다.");
    }

    reqDto.setName(generateFunctionName());
    reqDto.setFunctionStatus(TypeEnums.FunctionStatus.NOT_READY.getKey());

    setFunctionContent(reqDto);

    Function function = functionRepository.save(Function.register(reqDto));
    initializeFunction(function, reqDto);

    return function.toDto();
}

private void setFunctionContent(FunctionDTO.Register reqDto) {
    if (!reqDto.getRuntime().startsWith("Java")) {
        reqDto.setContent(generateBaseCode(reqDto));
    }
}

개선 이유

setFunctionContent(reqDto) 메서드 분리로 중복 코드 제거

registerFunction() 메서드의 단일 책임 강화 → 가독성 향상



---

2. initializeFunction()

변경 사항

1. setEnvironment(function), registerAllowedIPs(reqDto, function), setupTriggers(function, reqDto) 세 가지로 메서드 분리



변경 코드

private void initializeFunction(Function function, FunctionDTO.Register reqDto) throws IOException, ParseException {
    setEnvironment(function);
    registerAllowedIPs(reqDto, function);
    setupTriggers(function, reqDto);
}

private void registerAllowedIPs(FunctionDTO.Register reqDto, Function function) {
    if (!CollectionUtils.isEmpty(reqDto.getAllowIps())) {
        reqDto.getAllowIps().forEach(allowIp -> allowIpService.registerAllowIp(allowIp, function.getFunctionSeq()));
    }
}

private void setupTriggers(Function function, FunctionDTO.Register reqDto) throws IOException, ParseException {
    triggerService.createDefaultTrigger(function);

    if (function.getRuntime().startsWith("Java")) {
        SourceFileDTO.Register sampleDto = new SourceFileDTO.Register();
        sampleDto.setSourceFileType("sample");
        sourceFileService.saveSourceFile(sampleDto, function.getFunctionKey());
    }
}

개선 이유

단일 메서드가 너무 많은 역할을 수행 → initializeFunction()을 3개의 메서드로 분리

각각의 기능을 독립적으로 이해하고 유지보수하기 쉬워짐



---

PR 2: 클린 코드 적용 (네이밍 & 중복제거 & 책임분리)

목적: 메서드 네이밍 개선, 중복 제거, 불필요한 예외 발생 최소화


1. deleteFunction()

변경 사항

1. 네이밍 개선 (deleteRelatedResources() → cleanupFunctionResources())


2. deleteKnativeFunction(), deleteIstioPolicy(), deleteNamespace() 등의 개별 메서드 활용


3. 로깅 추가 (삭제 시 어떤 리소스가 삭제되는지 명확하게 기록)



변경 코드

@Transactional
public void deleteFunction(String functionKey) {
    Function function = functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new ResourceNotFoundException("존재하지 않는 펑션입니다."));

    if (function.isReady() || function.isDeploying()) {
        kn.services().inNamespace(function.getName()).withName(function.getName()).delete();
        istioCallService.deleteIstioPolicy(function.getName());
        deleteNamespace(function);
        cleanupFunctionResources(function);
    }

    markFunctionAsDeleted(function);
}

private void deleteNamespace(Function function) {
    try (KubernetesClient client = new DefaultKubernetesClient()) {
        client.namespaces().withName(function.getName()).delete();
        log.info("사용자 네임스페이스 {} 삭제 완료", function.getName());
    } catch (Exception e) {
        log.error("사용자 네임스페이스 삭제 중 오류 발생: {}", e.getMessage());
    }
}

private void cleanupFunctionResources(Function function) {
    allowIpRepository.deleteAllByFunction(function);
    functionEnvironmentRepository.deleteAllByFunction(function);
    keyManagerRepository.deleteByFunctionAndDelYn(function, "N");
    sourceFileRepository.deleteByFunction(function);
}

private void markFunctionAsDeleted(Function function) {
    function.modifyDelYn();
    functionRepository.save(function);
}

개선 이유

삭제 로직을 cleanupFunctionResources()로 추출 → deleteFunction()의 가독성 향상

deleteNamespace(), markFunctionAsDeleted() 추가 → 역할별 코드 분리

예외 발생 시 오류 메시지를 명확히 로깅



---

2. generateFunctionName()

변경 사항

1. UUID.randomUUID().toString()을 사용하면 하이픈이 포함되므로 replace("-", "")를 사용하여 제거


2. 불필요한 "scf-" + ... + "-api" 연결 방식을 String.format()으로 변경



변경 코드

private String generateFunctionName() {
    return String.format("scf-%s-api", UUID.randomUUID().toString().replace("-", ""));
}

개선 이유

UUID에서 하이픈을 제거하여 가독성을 높이고 String.format()을 사용하여 가독성 개선



---

PR 3: 성능 개선 및 예외 처리 강화

목적: 불필요한 예외 방지, 효율적인 데이터 조회, 성능 개선


1. isFunctionExists()

변경 사항

1. findByFunctionKeyAndDelYn()과 existsByDisplayNameAndProjectIdAndDelYn()을 한 번만 실행하도록 개선


2. Optional을 활용하여 중복된 조회 로직 제거



변경 코드

private boolean isFunctionExists(String functionKey, String displayName, String projectId) {
    return functionRepository.existsByFunctionKeyOrDisplayNameAndProjectId(functionKey, displayName, projectId, "N");
}

개선 이유

기존 코드에서 findByFunctionKeyAndDelYn()와 existsByDisplayNameAndProjectIdAndDelYn() 두 번의 쿼리를 실행하던 것을 하나의 메서드로 최적화 → 성능 향상



---

2. updateFunctionStatus()

변경 사항

1. HttpURLConnection의 setDoOutput(true)를 POST 메서드에서만 사용하도록 수정


2. try-with-resources로 OutputStream을 안전하게 닫도록 변경


3. apimEndpoint와 function.getProjectId() 등의 변수를 String.format()으로 개선하여 가독성 향상



변경 코드

private String buildFunctionStatusJson(Function function, String resourceState) {
    return String.format("""
        {
            "projectId": "%s",
            "region": "%s",
            "requestBy": "%s",
            "resourceId": "%s",
            "resourceName": "%s",
            "resourceState": "%s"
        }
    """, function.getProjectId(), function.getRegion(), function.getUserId(),
        function.getFunctionKey(), function.getDisplayName(), resourceState);
}

개선 이유

JSON 문자열을 String.format()으로 변경하여 유지보수성을 높임

try-with-resources로 자원 관리 최적화



---

정리

PR 1: 구조적인 리팩토링 (SRP 적용 & 중복 제거)

PR 2: 클린 코드 적용 (네이밍 개선, 가독성 향상)

PR 3: 성능 개선 및 예외 처리 강화


이제 이 변경 사항을 기반으로 PR을 생성하여 코드 리뷰를 진행하면 좋을 것 같습니다.

