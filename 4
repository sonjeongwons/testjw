에러의 핵심 원인은 아래 로그로부터 명확히 드러납니다:

com.google.gson.stream.MalformedJsonException: Use JsonReader.setStrictness(Strictness.LENIENT) to accept malformed JSON at line 2 column 2 path $

즉, AppUtil.JSONStringPrettyPrinter(...)에서 GSON을 사용하여 JSON을 파싱하려고 시도하는데, 해당 문자열이 정상적인 JSON 형식이 아님을 의미합니다. 그리고 그 호출은 아래 위치에서 발생합니다:

log.info("HTTP Request / Body: \n {}", AppUtil.JSONStringPrettyPrinter(bodyContent));

이 에러는 다음과 같은 이유로 발생할 수 있습니다:


---

✅ 원인 분석

1. bodyContent가 JSON이 아닌 경우

String bodyContent = body != null ? new String(body, StandardCharsets.UTF_8) : "null";

이 body는 멀티파트 요청이므로 application/json 형식이 아닌 boundary를 포함한 binary 데이터입니다.

예: 아래와 같이 시작함

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="file"; filename="test.jar"
Content-Type: application/java-archive
...

즉, JSON이 아니므로 Gson.fromJson() 시도 → MalformedJsonException 터짐



---

✅ 해결 방안

🔧 1. AppUtil.JSONStringPrettyPrinter() 호출 조건 수정 (멀티파트일 경우 제외)

// HttpCallService.setRestClientWithLogging() 내부
String contentType = request.getHeaders().getContentType() != null ? request.getHeaders().getContentType().toString() : "";

if (contentType.contains("application/json")) {
    try {
        String bodyContent = body != null ? new String(body, StandardCharsets.UTF_8) : "null";
        log.info("HTTP Request / Body: \n {}", AppUtil.JSONStringPrettyPrinter(bodyContent));
    } catch (Exception e) {
        log.warn("Body 파싱 실패 (JSON이 아닐 수 있음): {}", e.getMessage());
    }
} else {
    log.info("Content-Type이 JSON이 아니므로 body 로깅 생략 (Content-Type: {})", contentType);
}

📌 추가로 AppUtil.java 내에 정의된 JSONStringPrettyPrinter()가 다음처럼 되어 있다면:

public static String JSONStringPrettyPrinter(String json) {
    Gson gson = new GsonBuilder().setPrettyPrinting().create();
    JsonElement je = JsonParser.parseString(json); // 여기서 에러 발생
    return gson.toJson(je);
}

이 함수 자체를 아래와 같이 방어적으로 수정할 수도 있습니다:

public static String JSONStringPrettyPrinter(String json) {
    try {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        JsonElement je = JsonParser.parseString(json);
        return gson.toJson(je);
    } catch (Exception e) {
        return json; // JSON이 아니면 그냥 원본 리턴
    }
}


---

✨ 궁극적인 해결 요약

위치	수정 포인트	설명

HttpCallService#setRestClientWithLogging()	Content-Type이 application/json일 때만 AppUtil.JSONStringPrettyPrinter 호출	멀티파트는 JSON이 아님
AppUtil.JSONStringPrettyPrinter()	예외 처리 추가	파싱 실패 시 원문 그대로 리턴



---

✅ 보너스: 개선 권장 사항

1. @Value("${CVC.URL}")는 static 변수에 사용 ❌

@Value("${CVC.URL}")
private static String CVC_URL;  // ❌ Spring이 주입하지 못함

Spring에서는 @Value가 non-static 필드에만 주입되므로, 아래와 같이 수정해야 함:

@Value("${CVC.URL}")
private String cvcUrl;  // 필드명을 소문자로 바꾸는 것도 컨벤션상 추천

private String getCvcEndpoint() {
    return cvcUrl + "/api/v1/scanner/multipart-scan";
}

그리고 scanCodeFile() 안에서는 static 제거하고 인스턴스 메소드로 유지:

String endpoint = getCvcEndpoint();


---

✅ 전체적으로 보면, 코드의 주요 문제는 다음과 같습니다

구분	문제	해결

GSON 파싱 실패	multipart/form-data를 JSON으로 파싱 시도	Content-Type 확인 후 JSON만 pretty print
@Value 주입 실패	static 필드에 @Value 사용	non-static으로 변경
에러 로그 가독성	GSON 오류로 stack trace 길어짐	에러 발생 시 graceful fallback 처리



---

🔄 다음 단계

Q1: AppUtil.JSONStringPrettyPrinter에서 발생하는 에러를 막기 위한 가장 적절한 유효성 체크 방법은 무엇일까?

Q2: 멀티파트 요청/응답을 로깅할 때 데이터 노출을 방지하기 위한 로깅 전략은 어떻게 구성해야 할까?

Q3: GSON을 활용한 JSON pretty print 대신 ObjectMapper를 사용하는 경우 장단점은 무엇일까?

