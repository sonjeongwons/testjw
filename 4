package com.cvc.scanner.service;

import com.cvc.scanner.config.TokenSecurityProperties;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.benmanes.caffeine.cache.Cache;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpStatusCodeException;
import org.springframework.web.client.RestTemplate;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TokenService {

    private static final Logger log = LoggerFactory.getLogger(TokenService.class);

    @Value("${cvc.service.id}")
    private String cvcServiceId;

    @Value("${cvc.service.pw}")
    private String cvcServicePw;

    @Value("${iam.api.endpoint}")
    private String iamApiEndpoint;

    private final RestTemplate restTemplate;
    private final TokenSecurityProperties securityProps;
    private final Cache<String, String> adminTokenCache;

    private static final String ADMIN_TOKEN_CACHE_KEY = "adminToken";

    /** admin 토큰을 TTL 캐시에서 획득. 없으면 Keystone에서 발급 후 캐시. */
    public String getCvcAdminToken() {
        String cached = adminTokenCache.getIfPresent(ADMIN_TOKEN_CACHE_KEY);
        if (cached != null && !cached.isBlank()) {
            log.debug("[AdminToken] cache=HIT token={}", maskToken(cached));
            return cached;
        }
        log.info("[AdminToken] cache=MISS. fetching from 키스톤 endpoint={}", iamApiEndpoint);
        Instant t0 = Instant.now();
        String fresh = fetchAdminTokenFromIam();
        adminTokenCache.put(ADMIN_TOKEN_CACHE_KEY, fresh);
        log.info("[AdminToken] fetched and cached. costMs={} token={}",
                Duration.between(t0, Instant.now()).toMillis(), maskToken(fresh));
        return fresh;
    }

    /** 키스톤에서 admin 토큰 발급 */
    private String fetchAdminTokenFromIam() {
        String url = iamApiEndpoint;

        Map<String, Object> body = Map.of(
                "auth", Map.of(
                        "identity", Map.of(
                                "methods", List.of("password"),
                                "password", Map.of(
                                        "user", Map.of(
                                                "name", cvcServiceId,
                                                "domain", Map.of("name", "service"),
                                                "password", cvcServicePw
                                        )
                                )
                        )
                )
        );

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(body, headers);

        try {
            Instant t0 = Instant.now();
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
            long cost = Duration.between(t0, Instant.now()).toMillis();

            String token = response.getHeaders().getFirst("X-Subject-Token");
            log.debug("[AdminToken] 키스톤 POST status={} costMs={} hasTokenHeader={}",
                    response.getStatusCodeValue(), cost, token != null);

            if (token == null || token.isBlank()) {
                log.error("[AdminToken] missing X-Subject-Token header. status={} bodySize={}",
                        response.getStatusCodeValue(), safeLen(response.getBody()));
                throw new IllegalStateException("키스톤으로부터 admin 토큰을 획득하지 못함");
            }
            return token;

        } catch (HttpStatusCodeException e) {
            log.error("[AdminToken] 키스톤 POST failed status={} body={}",
                    e.getStatusCode().value(), safeSnippet(e.getResponseBodyAsString(), 512));
            throw e;
        } catch (Exception e) {
            log.error("[AdminToken] 키스톤 POST unexpected error: {}", e.toString(), e);
            throw e;
        }
    }

    /**
     * 사용자 토큰 검증:
     * 1) user.domain.name == configured domain (대소문자 무시)
     * 2) user.name ∈ whitelist
     * 3) roles 내 admin 포함
     */
    public boolean validateToken(String userToken) {
        String url = iamApiEndpoint;
        String adminToken = getCvcAdminToken();

        HttpHeaders headers = new HttpHeaders();
        headers.set("X-Auth-Token", adminToken);
        headers.set("X-Subject-Token", userToken);

        HttpEntity<Void> request = new HttpEntity<>(headers);

        // 운영자 디버깅에 도움 되는 컨피그 로그 (info 1회/요청)
        log.debug("[Validate] cfg expectedDomain={} whitelist={}",
                nullSafeLower(securityProps.getUserDomain()),
                securityProps.getWhitelistUserNames());

        try {
            Instant t0 = Instant.now();
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);
            long cost = Duration.between(t0, Instant.now()).toMillis();

            if (!response.getStatusCode().is2xxSuccessful()) {
                log.warn("[Validate] 키스톤 GET non-2xx status={} costMs={} body={}",
                        response.getStatusCodeValue(), cost, safeSnippet(response.getBody(), 512));
                return false;
            }
            if (response.getBody() == null) {
                log.warn("[Validate] 키스톤 GET body=null costMs={}", cost);
                return false;
            }

            String body = response.getBody();
            log.debug("[Validate] 키스톤 GET ok costMs={} bodySize={}", cost, safeLen(body));

            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode root = objectMapper.readTree(body);
            JsonNode tokenNode = root.path("token");

            // 추출: user/domain/roles
            String expectedDomain = nullSafeLower(securityProps.getUserDomain());
            String actualDomain = nullSafeLower(tokenNode.path("user").path("domain").path("name").asText(null));
            String userName     = tokenNode.path("user").path("name").asText(null);

            log.debug("[Validate] claims userName={} actualDomain={}", userName, actualDomain);

            // 1) domain 체크
            if (expectedDomain != null && !expectedDomain.equals(actualDomain)) {
                log.warn("[Validate] domain mismatch expected={} actual={}", expectedDomain, actualDomain);
                return false;
            }

            // 2) 화이트리스트 체크
            boolean whitelisted = isWhitelistedUser(userName);
            if (!whitelisted) {
                log.warn("[Validate] user not in whitelist userName={}", userName);
                return false;
            }

            // 3) admin role 체크
            JsonNode roles = tokenNode.path("roles");
            boolean isAdmin = hasAdminRole(roles);
            log.debug("[Validate] rolesCount={} isAdmin={}", roles != null && roles.isArray() ? roles.size() : -1, isAdmin);
            if (!isAdmin) {
                log.warn("[Validate] admin role missing for userName={}", userName);
                return false;
            }

            log.info("[Validate] success userName={} domain={} result=true", userName, actualDomain);
            return true;

        } catch (HttpStatusCodeException e) {
            log.error("[Validate] 키스톤 GET failed status={} body={} userToken={} adminToken={}",
                    e.getStatusCode().value(),
                    safeSnippet(e.getResponseBodyAsString(), 512),
                    maskToken(userToken),
                    maskToken(adminToken));
            return false; // 운영 관점에선 401로 빠져야 하므로 false 반환
        } catch (Exception e) {
            log.error("[Validate] unexpected error: {} userToken={} adminToken={}",
                    e.toString(), maskToken(userToken), maskToken(adminToken), e);
            return false;
        }
    }

    private boolean isWhitelistedUser(String userName) {
        if (userName == null) {
            log.debug("[Whitelist] userName=null");
            return false;
        }
        Set<String> white = securityProps.getWhitelistUserNames()
                .stream()
                .filter(n -> n != null && !n.isBlank())
                .map(this::nullSafeLower)
                .collect(Collectors.toUnmodifiableSet());
        boolean contains = white.contains(userName.toLowerCase());
        log.debug("[Whitelist] userName={} allowed={}", userName, contains);
        return contains;
    }

    private boolean hasAdminRole(JsonNode roles) {
        if (roles == null || !roles.isArray()) {
            log.debug("[Roles] roles missing or not array");
            return false;
        }
        for (JsonNode role : roles) {
            String roleName = role.path("name").asText("");
            if ("admin".equalsIgnoreCase(roleName)) {
                return true;
            }
        }
        return false;
    }

    /** 보안: 토큰 마스킹(앞 10자리만 노출) */
    private String maskToken(String t) {
        if (t == null) return "null";
        int keep = Math.min(10, t.length());
        return t.substring(0, keep) + "****(" + t.length() + ")";
    }

    /** 본문 길이만 로깅 */
    private int safeLen(String s) {
        return s == null ? -1 : s.length();
    }

    /** 본문 스니펫 로깅(민감값 있을 수 있으므로 길이 제한) */
    private String safeSnippet(String s, int max) {
        if (s == null) return "null";
        String snippet = s.replaceAll("\\s+", " ");
        return snippet.length() <= max ? snippet : snippet.substring(0, max) + "...";
    }

    private String nullSafeLower(String s) {
        return (s == null) ? null : s.toLowerCase();
    }
}


package com.cvc.scanner.controller;

import com.cvc.scanner.dto.FileDto;
import com.cvc.scanner.service.TokenService;
import com.cvc.scanner.service.V3ScannerService;
import com.sun.net.httpserver.HttpsServer;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.InputStream;
import java.util.Random;

import org.springframework.http.HttpStatus;
import jakarta.validation.Valid;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/scanner")
public class V3ScannerController {

    private static final Logger logger = LoggerFactory.getLogger(V3ScannerController.class);

    @Autowired
    private V3ScannerService v3ScannerService;
    @Autowired
    private TokenService tokenService;

    @GetMapping("/simple")
    public ResponseEntity<Map<String, Object>> simpleScan(@RequestHeader("X-Subject-Token") String Token, @RequestParam String fileName) {
        logger.info("Simple scan requested. Filename: {}, API Key: {}", fileName, Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
//        }
        return ResponseEntity.ok(v3ScannerService.simpleScan(fileName));
    }

    @GetMapping("/remote")
    public ResponseEntity<Map<String, Object>> remoteScan(@RequestHeader("X-Subject-Token") String Token, @RequestParam String fileName) {
        logger.info("Remote scan requested. Filename: {}, API Key: {}", fileName, Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
//        }
        return ResponseEntity.ok(v3ScannerService.remoteScan(fileName));
    }

    @GetMapping("/detail")
    public ResponseEntity<Map<String, Object>> detailScan(@RequestHeader("X-Subject-Token") String Token, @RequestParam String fileName) {
        logger.info("Detail scan requested. Filename: {}, API Key: {}", fileName, Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
//        }
        return ResponseEntity.ok(v3ScannerService.detailScan(fileName));
    }


    @PostMapping("/base64-scan")
    public ResponseEntity<FileDto.Response> scanFile(
            @RequestHeader("X-Subject-Token") String Token,
            @Valid @RequestBody FileDto.Request fileDtoRequest) {
        logger.info("File scan requested. Filename: {}, API Key: {}", fileDtoRequest.getFileName(), Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
//                    FileDto.Response.builder()
//                            .fileName(fileDtoRequest.getFileName())
//                            .returnCode(HttpStatus.UNAUTHORIZED.value())
//                            .message("Unauthorized: Invalid API Key")
//                            .build()
//            );
//        }
        FileDto.Response response = v3ScannerService.scanBase64File(fileDtoRequest);
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }

    @PostMapping(value = "/multipart-scan", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<FileDto.Response> scanMultipartFile(
            @RequestHeader("X-Subject-Token") String token,
            @RequestPart("file") MultipartFile file) {

        logger.info("Multipart file scan requested. Filename: {}", file.getOriginalFilename());
        boolean isValid = tokenService.validateToken(token);
        if(!isValid){
            logger.info("인증 토큰이 유효하지 않습니다.");
            throw new RuntimeException("Token is Unauthorized");
        }
        FileDto.Response response = v3ScannerService.scanMultipartFile(file);
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }

    @PostMapping(value = "/binary-scan", consumes = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public ResponseEntity<FileDto.Response> scanBinaryFile(
            @RequestHeader("X-Subject-Token") String Token,
            @RequestHeader("File-Name") String fileName,
            HttpServletRequest request) {

//        if (v3ScannerService.validateToken(Token)) {
//            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
//                    FileDto.Response.builder()
//                            .fileName(fileName)
//                            .returnCode(HttpStatus.UNAUTHORIZED.value())
//                            .message("Unauthorized: Invalid API Key")
//                            .build()
//            );
//        }

        try (InputStream inputStream = request.getInputStream()) {
            FileDto.Response response = v3ScannerService.scanBinaryFile(fileName, inputStream);
            return ResponseEntity.status(HttpStatus.OK).body(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    FileDto.Response.builder()
                            .fileName(fileName)
                            .returnCode(-1)
                            .message("Error processing file: " + e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping(value = "/upload-chunk", consumes = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public ResponseEntity<String> uploadChunk(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("Chunk-Index") int chunkIndex,  // 청크 인덱스
            @RequestHeader("Total-Chunks") int totalChunks,  // 전체 청크 개수
            @RequestBody byte[] chunkData) {  // 청크 데이터

        try {
            v3ScannerService.saveChunk(fileId, chunkIndex, chunkData);
            return ResponseEntity.ok("Chunk uploaded successfully.");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Chunk upload failed: " + e.getMessage());
        }
    }

    /**
     * 병합 및 스캔 엔드포인트
     */
    @PostMapping("/merge-chunks")
    public ResponseEntity<FileDto.Response> mergeChunksAndScan(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("File-Name") String fileName) {  // 원래 파일 이름

        try {
            FileDto.Response response = v3ScannerService.mergeChunksAndScan(fileId, fileName);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    FileDto.Response.builder()
                            .fileName(fileName)
                            .returnCode(-1)
                            .message("Failed to merge and scan chunks: " + e.getMessage())
                            .build()
            );
        }
    }

    @GetMapping("/status")
    public ResponseEntity<FileDto.Response> getStatus() {
        logger.info("API status requested.");
        String[] fileNames = {"TestFile", "TestFolder","TestZip","Wow","Hello"};
        Random random = new Random();
        String fileName=fileNames[random.nextInt(fileNames.length)];
        return ResponseEntity.status(HttpStatus.OK).body(
                FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(0)
                        .message("API is running")
                        .build()
        );
    }

    @PostMapping("/status")
    public ResponseEntity<FileDto.Response> modifyStatus(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("File-Name") String fileName) {
        logger.info("Post메소드가 호출되었습니다.");
        String[] numbers = {"0","1"};
        Random random = new Random();
        String number=numbers[random.nextInt(numbers.length)];
        return ResponseEntity.status(HttpStatus.OK).body(
                FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(Integer.parseInt(number))
                        .message("File ID is : " + fileId)
                        .build()
        );
    }

    @GetMapping("/test")
    public ResponseEntity<FileDto.Response> callTest(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("File-Name") String fileName) {
        logger.info("TEST API is Called. 파일ID는 " + fileId +" 이고, 파일이름은 " + fileName + " 입니다.");
        return ResponseEntity.status(HttpStatus.OK).body(
                FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(-1)
                        .message("마지막으로 파일ID는 " + fileId)
                        .build()
        );
    }
}











package com.cvc.scanner.service;

import com.cvc.scanner.dto.FileDto;
import com.ahnlab.v3engine.V3Const;
import com.ahnlab.v3engine.V3Scanner;

import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Properties;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.FileOutputStream;
import java.nio.file.Files;
import java.time.Instant;
import java.util.*;


@Service
public class V3ScannerService {

    private static final Logger logger = LoggerFactory.getLogger(V3ScannerService.class);
    private final String chunkBaseDir = "/tmp/chunks";  // 청크 저장 디렉토리



    @Value("${cvc.service.id}")
    private String cvcServiceId;

    @Value("${cvc.service.pw}")
    private String cvcServicePw;

    @Value("${iam.api.endpoint}")
    private String iamApiEndpoint;


    public Map<String, Object> simpleScan(String filename) {
        Map<String, Object> result = new HashMap<>();
        int ret = V3Scanner.scanFile(filename);
        result.put("filename", filename);
        result.put("returnCode", ret);
        printScanInfo(filename, ret, null);
        return result;
    }

    public Map<String, Object> remoteScan(String filename) {
        Map<String, Object> result = new HashMap<>();
        Properties prop = new Properties();
        int ret = V3Scanner.remoteScanFile(filename, prop);

        result.put("filename", filename);
        result.put("returnCode", ret);
        result.put("details", prop);
        return result;
    }

    public Map<String, Object> detailScan(String filename) {
        Map<String, Object> result = new HashMap<>();
        Properties prop = new Properties();
        int ret = V3Scanner.scanFile(filename, prop);

        result.put("filename", filename);
        result.put("returnCode", ret);
        result.put("details", prop);
        return result;
    }

    public FileDto.Response scanBase64File(FileDto.Request fileDtoRequest) {
        File tempFile = null;
        try {
            // 파일 디코딩 후 임시파일로 저장
            byte[] fileData = Base64.getDecoder().decode(fileDtoRequest.getFileData());
            String baseDir = "/tmp/"; // 임시 디렉터리로 변경
            String uniqueFileName = "scan_" + UUID.randomUUID() + "_" + Instant.now().toEpochMilli() + "_" + fileDtoRequest.getFileName();
            tempFile = new File(baseDir + File.separator + uniqueFileName);
            String FilePath = tempFile.getAbsolutePath();
            logger.info("tempFile : {}", FilePath);
            Properties prop = new Properties();

            try (FileOutputStream fos = new FileOutputStream(tempFile)) {
                fos.write(fileData);
                fos.flush();
                logger.info("파일 내용 확인 : {}", new String(fileData));
            }
            // 파일 스캔 수행
            int ret = V3Scanner.scanFile(FilePath, prop);
            printScanInfo(FilePath, ret, prop);
            return FileDto.Response.builder()
                    .fileName(fileDtoRequest.getFileName())
                    .returnCode(ret)
                    .message(prop.getProperty(V3Const.PROP_KEY_MORE_INFO))
                    .build();
        } catch (Exception e) {
            return FileDto.Response.builder()
                    .fileName(fileDtoRequest.getFileName())
                    .returnCode(-1)
                    .message("File processing failed: " + e.getMessage())
                    .build();
        } finally {
            if (tempFile != null && tempFile.exists()) {
                try {
                    Files.delete(tempFile.toPath());
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public FileDto.Response scanMultipartFile(MultipartFile file) {
        File tempFile = null;

        // 파일 크기 제한 (50MB)
        if (file.getSize() > 1024L * 1024L * 1024L) {
            logger.info("File size exceeds the 1GB limit. fileSize(Byte) : {}", file.getSize());
            return FileDto.Response.builder()
                    .fileName(file.getOriginalFilename())
                    .returnCode(-1)
                    .message("File size exceeds the 50MB limit.")
                    .build();
        }

        // 파일 확장자 필터링
        String fileName = file.getOriginalFilename();
        if (!isAllowedExtension(fileName)) {
            logger.info("Unsupported file type.");
            return FileDto.Response.builder()
                    .fileName(fileName)
                    .returnCode(-1)
                    .message("Unsupported file type.")
                    .build();
        }

        try {
            Properties prop = new Properties();
            logger.info("Processing file on disk.");
            //byte[] fileBytes = file.getBytes();
            //String fileContent = new String(fileBytes);
            //logger.info("파일 내용 확인 : {}", fileContent);
            tempFile = Files.createTempFile("scan_", "_" + UUID.randomUUID() + "_" + Instant.now().toEpochMilli() + "_" + fileName).toFile();
            logger.info("tempFile : {}", tempFile.getAbsolutePath());
            file.transferTo(tempFile);

            int ret = V3Scanner.scanFile(tempFile.getAbsolutePath(), prop); // 디스크 기반 검사
            printScanInfo(tempFile.getAbsolutePath(), ret, prop);
            return buildResponse(fileName, ret, prop);

        } catch (Exception e) {
            logger.info("파일 처리 실패");
            return FileDto.Response.builder()
                    .fileName(file.getOriginalFilename())
                    .returnCode(-1)
                    .message("File processing failed: " + e.getMessage())
                    .build();
        } finally {
            if (tempFile != null && tempFile.exists()) {
                try {
                    tempFile.delete();
                    logger.info("임시파일삭제");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            else{
                logger.info("임시파일 없음");
            }
        }
    }

    public FileDto.Response scanBinaryFile(String fileName, InputStream inputStream) {
        File tempFile = null;
        try {
            Path tempPath = Files.createTempFile("scan_", "_" + UUID.randomUUID() + "_" + fileName);
            tempFile = tempPath.toFile();

            logger.info("Processing binary file on disk: {}", tempFile.getAbsolutePath());

            // 파일을 직접 디스크로 저장 (스트림 기반 처리)
            try (OutputStream outputStream = new FileOutputStream(tempFile)) {
                byte[] buffer = new byte[8192]; // 8KB 버퍼 크기 설정
                int bytesRead;
                while ((bytesRead = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, bytesRead);
                }
            }

            // 파일 확장자 필터링 (금지된 파일 체크)
            if (!isAllowedExtension(fileName)) {
                return FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(-1)
                        .message("Unsupported file type.")
                        .build();
            }

            // 파일 스캔 수행
            Properties prop = new Properties();
            int ret = V3Scanner.scanFile(tempFile.getAbsolutePath(), prop);
            printScanInfo(tempFile.getAbsolutePath(), ret, prop);

            return FileDto.Response.builder()
                    .fileName(fileName)
                    .returnCode(ret)
                    .message(prop.getProperty(V3Const.PROP_KEY_MORE_INFO, "No additional information."))
                    .build();
        } catch (Exception e) {
            return FileDto.Response.builder()
                    .fileName(fileName)
                    .returnCode(-1)
                    .message("File processing failed: " + e.getMessage())
                    .build();
        } finally {
            // 파일 처리 완료 후 삭제
            if (tempFile != null && tempFile.exists()) {
                tempFile.delete();
            }
        }
    }

    /**
     * 청크 저장 로직
     */
    public void saveChunk(String fileId, int chunkIndex, byte[] chunkData) throws Exception {
        Path chunkDir = Paths.get(chunkBaseDir, fileId);  // 파일 ID 기반 디렉토리 생성
        if (!Files.exists(chunkDir)) {
            Files.createDirectories(chunkDir);  // 디렉토리가 없으면 생성
        }
        Path chunkFile = chunkDir.resolve("chunk_" + chunkIndex);  // 청크 파일 이름
        Files.write(chunkFile, chunkData);  // 청크 데이터 저장
        logger.info("Saved chunk: FileId={}, ChunkIndex={}", fileId, chunkIndex);
    }

    /**
     * 병합 및 스캔 로직
     */
    public FileDto.Response mergeChunksAndScan(String fileId, String fileName) throws Exception {
        Path chunkDir = Paths.get(chunkBaseDir, fileId);
        Path mergedFile = Paths.get("/tmp/" + UUID.randomUUID() + "_" + fileName);  // 병합 파일 이름에 UUID 추가

        try {
            // 1. 병합 작업
            try (FileOutputStream outputStream = new FileOutputStream(mergedFile.toFile())) {
                Files.list(chunkDir)
                        .sorted()  // 청크 파일 정렬
                        .forEach(chunk -> {
                            try {
                                Files.copy(chunk, outputStream);
                            } catch (Exception e) {
                                throw new RuntimeException("Failed to merge chunk: " + chunk.getFileName(), e);
                            }
                        });
            }
            logger.info("tempFile : {}", mergedFile.toString());
            // 2. 스캔 작업 수행
            Properties prop = new Properties();
            int ret = V3Scanner.scanFile(mergedFile.toString(), prop);
            printScanInfo(mergedFile.toString(), ret, prop);

            // 3. 결과 반환
            return FileDto.Response.builder()
                    .fileName(fileName)
                    .returnCode(ret)
                    .message(prop.getProperty(V3Const.PROP_KEY_MORE_INFO, "No additional information."))
                    .build();

        } finally {
            // 4. 병합 파일 및 청크 디렉토리 삭제
            try {
                if (Files.exists(mergedFile)) {
                    Files.delete(mergedFile);
                    logger.info("Deleted merged file: {}", mergedFile);
                }
                if (Files.exists(chunkDir)) {
                    Files.walk(chunkDir)
                            .sorted(Comparator.reverseOrder())  // 하위 파일부터 삭제
                            .forEach(path -> {
                                try {
                                    Files.delete(path);
                                } catch (Exception e) {
                                    logger.warn("Failed to delete chunk file: {}", path, e);
                                }
                            });
                    logger.info("Deleted chunk directory: {}", chunkDir);
                }
            } catch (Exception e) {
                logger.error("Failed to clean up files: {}", e.getMessage());
            }
        }
    }

    // 지원되는 파일 확장자 확인
    private boolean isAllowedExtension(String fileName) {
        String[] allowedExtensions = {".zip", ".jar"};
        String lowerFileName = fileName.toLowerCase();
        return Arrays.stream(allowedExtensions).anyMatch(lowerFileName::endsWith);
    }

    // Response 생성 헬퍼 메서드
    private FileDto.Response buildResponse(String fileName, int ret, Properties prop) {
        return FileDto.Response.builder()
                .fileName(fileName)
                .returnCode(ret)
                .message(prop.getProperty(V3Const.PROP_KEY_MORE_INFO, "No additional information."))
                .build();
    }

    static void printScanInfo(String filename, int ret, Properties prop)
    {
        // message
        String msg = switch (ret) {
            case V3Const.RET_AUTH_FAILED -> "인증 실패";
            case V3Const.RET_CLIENT_TIMEOUT -> "검사 요청 클라이언트 TIMEOUT";
            case V3Const.RET_NETWORK_ERROR -> "네트워크 장애";
            case V3Const.RET_CLIENT_FAIL -> "검사 요청 클라이언트 오류";
            case V3Const.RET_CANNOT_SCAN -> "검사 실패";
            case V3Const.RET_NO_MALWARE -> "악성코드 없음";
            case V3Const.RET_MALWARE_FOUND -> "악성코드 발견";
            case V3Const.RET_CLEAN_MODIFY_SUCCESS -> "수정 치료 성공";
            case V3Const.RET_CLEAN_MODIFY_FAIL -> "수정 치료 실패(삭제 권고)";
            case V3Const.RET_CLEAN_DEL_SUCCESS -> "삭제 치료 성공";
            case V3Const.RET_CLEAN_DEL_FAIL -> "삭제 치료 실패(삭제 권고)";
            case V3Const.RET_CLEAN_DEL_FAIL_BYCONF -> "삭제 치료 실패(검사 서버 옵션)";
            default -> "알수 없음";
        };

        // 정보 출력
        logger.info("filename : {}", filename);
        logger.info("return : {} ({})", ret,msg);
        if (prop != null)
        {
            logger.info("date rev  : {}", prop.getProperty(V3Const.PROP_KEY_DATE_REV, "N/A"));
            logger.info("scan time : {}", prop.getProperty(V3Const.PROP_KEY_SCAN_DATE_TIME, "N/A"));
            logger.info("more info : {}", prop.getProperty(V3Const.PROP_KEY_MORE_INFO, "N/A"));
            if (ret == V3Const.RET_MALWARE_FOUND)
            {
                logger.info("    malware  : {}", prop.getProperty(V3Const.PROP_KEY_MALWARE_NAME, "N/A"));
                logger.info("    in    : {}", prop.getProperty(V3Const.PROP_KEY_MALWARE_FILE, "N/A"));
            }
            logger.info(String.valueOf(prop));
        }
    }
}


package com.cvc.scanner.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.*;
import jakarta.validation.Valid;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class FileDto {

    @NotBlank(message = "파일명을 입력해주세요")
    private String fileName;

    @NotBlank(message = "파일 데이터를 입력해주세요")
    private String fileData;

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class Request {

        @NotBlank(message = "파일명을 입력해주세요")
        private String fileName;

        @NotBlank(message = "파일 데이터를 입력해주세요")
        private String fileData;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class Response {

        private String fileName;

        private int returnCode;

        private String message;
    }
}









