package parser

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/prometheus/common/model"
	"github.com/prometheus/prometheus/model/labels"
)

// Tree returns a string of the tree structure of the given node.
func Tree(node Node) string {
	return buildTree(node, "")
}

// buildTree constructs the hierarchical tree representation of nodes.
func buildTree(node Node, level string) string {
	if node == nil {
		return fmt.Sprintf("%s |---- %T\n", level, node)
	}
	typeName := extractTypeName(node)
	treeStructure := fmt.Sprintf("%s |---- %s :: %s\n", level, typeName, node)
	level += " · · ·"
	for _, child := range Children(node) {
		treeStructure += buildTree(child, level)
	}
	return treeStructure
}

// extractTypeName retrieves the simple type name of a given node.
func extractTypeName(node Node) string {
	typeParts := strings.Split(fmt.Sprintf("%T", node), ".")
	return typeParts[len(typeParts)-1]
}

func (node *EvalStmt) String() string {
	return "EVAL " + node.Expr.String()
}

func (es Expressions) String() string {
	if len(es) == 0 {
		return ""
	}
	parts := make([]string, len(es))
	for i, e := range es {
		parts[i] = e.String()
	}
	return strings.Join(parts, ", ")
}

func (node *AggregateExpr) String() string {
	return fmt.Sprintf("%s(%s%s)", node.getAggOpStr(), formatOptionalParam(node), node.Expr)
}

// formatOptionalParam formats the parameter if it exists for the aggregator.
func formatOptionalParam(node *AggregateExpr) string {
	if node.Op.IsAggregatorWithParam() {
		return fmt.Sprintf("%s, ", node.Param)
	}
	return ""
}

func (node *AggregateExpr) getAggOpStr() string {
	groupingClause := ""
	if node.Without {
		groupingClause = fmt.Sprintf(" without (%s)", strings.Join(node.Grouping, ", "))
	} else if len(node.Grouping) > 0 {
		groupingClause = fmt.Sprintf(" by (%s)", strings.Join(node.Grouping, ", "))
	}
	return node.Op.String() + groupingClause
}

func (node *BinaryExpr) String() string {
	return fmt.Sprintf("%s %s%s%s %s", node.LHS, node.Op, formatBool(node), node.getMatchingStr(), node.RHS)
}

// formatBool adds "bool" to the string representation if ReturnBool is true.
func formatBool(node *BinaryExpr) string {
	if node.ReturnBool {
		return " bool"
	}
	return ""
}

func (node *BinaryExpr) getMatchingStr() string {
	if node.VectorMatching == nil || (len(node.VectorMatching.MatchingLabels) == 0 && !node.VectorMatching.On) {
		return ""
	}
	matchingType := "ignoring"
	if node.VectorMatching.On {
		matchingType = "on"
	}
	matching := fmt.Sprintf(" %s (%s)", matchingType, strings.Join(node.VectorMatching.MatchingLabels, ", "))
	if node.VectorMatching.Card == CardManyToOne || node.VectorMatching.Card == CardOneToMany {
		groupSide := "right"
		if node.VectorMatching.Card == CardManyToOne {
			groupSide = "left"
		}
		matching += fmt.Sprintf(" group_%s (%s)", groupSide, strings.Join(node.VectorMatching.Include, ", "))
	}
	return matching
}

func (node *Call) String() string {
	return fmt.Sprintf("%s(%s)", node.Func.Name, node.Args)
}

func (node *MatrixSelector) String() string {
	return formatSelector(node.VectorSelector, node.Range, node.VectorSelector.(*VectorSelector))
}

func formatSelector(vecSelector *VectorSelector, duration time.Duration, original *VectorSelector) string {
	originalOffset, timestamp, startOrEnd := original.OriginalOffset, original.Timestamp, original.StartOrEnd
	original.OriginalOffset, original.Timestamp, original.StartOrEnd = 0, nil, 0
	defer func() {
		original.OriginalOffset, original.Timestamp, original.StartOrEnd = originalOffset, timestamp, startOrEnd
	}()
	offset := formatOffset(vecSelector.OriginalOffset)
	at := formatTimestamp(vecSelector.Timestamp, vecSelector.StartOrEnd)
	return fmt.Sprintf("%s[%s]%s%s", vecSelector.String(), model.Duration(duration), at, offset)
}

func formatOffset(offset time.Duration) string {
	if offset > 0 {
		return fmt.Sprintf(" offset %s", model.Duration(offset))
	} else if offset < 0 {
		return fmt.Sprintf(" offset -%s", model.Duration(-offset))
	}
	return ""
}

func formatTimestamp(ts *int64, startOrEnd int) string {
	if ts != nil {
		return fmt.Sprintf(" @ %.3f", float64(*ts)/1000.0)
	} else if startOrEnd == START {
		return " @ start()"
	} else if startOrEnd == END {
		return " @ end()"
	}
	return ""
}

func (node *SubqueryExpr) String() string {
	return fmt.Sprintf("%s%s", node.Expr.String(), node.getSubqueryTimeSuffix())
}

func (node *NumberLiteral) String() string {
	return fmt.Sprint(node.Val)
}

func (node *ParenExpr) String() string {
	return fmt.Sprintf("(%s)", node.Expr)
}

func (node *StringLiteral) String() string {
	return fmt.Sprintf("%q", node.Val)
}

func (node *UnaryExpr) String() string {
	return fmt.Sprintf("%s%s", node.Op, node.Expr)
}

func (node *VectorSelector) String() string {
	labelStrings := formatLabelMatchers(node.LabelMatchers, node.Name)
	offset := formatOffset(node.OriginalOffset)
	at := formatTimestamp(node.Timestamp, node.StartOrEnd)
	if len(labelStrings) == 0 {
		return fmt.Sprintf("%s%s%s", node.Name, at, offset)
	}
	sort.Strings(labelStrings)
	return fmt.Sprintf("%s{%s}%s%s", node.Name, strings.Join(labelStrings, ","), at, offset)
}

func formatLabelMatchers(matchers []*labels.Matcher, name string) []string {
	var labelStrings []string
	for _, matcher := range matchers {
		if matcher.Name == labels.MetricName && matcher.Type == labels.MatchEqual && matcher.Value == name {
			continue
		}
		labelStrings = append(labelStrings, matcher.String())
	}
	return labelStrings
}