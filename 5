좋아. 아래 코드는 네 요구사항(Q1, Q2, Q3)을 모두 반영해 정리한 프로덕션용 설계야.

Q1: domain.name == "service" 인지도 강제

Q2: 화이트리스트(허용 user.name)와 domain 값을 application.yml 외부화 + @ConfigurationProperties 바인딩

Q3: X-Auth-Token(admin 토큰) 발급을 Caffeine 캐시(TTL) 로 최적화



---

1) application.yml 예시

iam:
  api:
    endpoint: https://iam.example.com/v3/auth/tokens # 실제 값으로

cvc:
  service:
    id: cvc-admin           # 실제 값으로
    pw: very-secret         # 실제 값으로

security:
  token:
    user-domain: service                    # Q1: 강제할 domain 값
    whitelist-user-names:                   # Q2: user.name 화이트리스트
      - scf-service
      - cvc-service
    cache:
      admin-token-ttl-seconds: 300          # Q3: admin 토큰 TTL(초)


---

2) 설정 바인딩: TokenSecurityProperties.java

package com.cvc.scanner.config;

import lombok.Getter;
import lombok.Setter;
import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@ConfigurationProperties(prefix = "security.token")
public class TokenSecurityProperties {

    /**
     * Token 내 user.domain.name 이 이 값과 같아야 유효(대소문자 무시).
     * 예) "service"
     */
    private String userDomain;

    /**
     * 허용할 user.name 화이트리스트.
     * 예) ["scf-service", "cvc-service"]
     */
    private List<String> whitelistUserNames = new ArrayList<>();

    private CacheProperties cache = new CacheProperties();

    @Getter @Setter
    public static class CacheProperties {
        /**
         * admin 토큰 TTL(초). 기본 300초.
         */
        private long adminTokenTtlSeconds = 300;
    }
}

> 바인딩 활성화를 위해 @EnableConfigurationProperties가 필요하다.




---

3) 캐시 및 설정 활성화: CacheConfig.java

package com.cvc.scanner.config;

import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
@EnableConfigurationProperties(TokenSecurityProperties.class)
public class CacheConfig {

    @Bean
    public Cache<String, String> adminTokenCache(TokenSecurityProperties props) {
        long ttl = props.getCache().getAdminTokenTtlSeconds();
        return Caffeine.newBuilder()
                .expireAfterWrite(Duration.ofSeconds(ttl))
                .maximumSize(1) // admin 토큰 하나만 캐시
                .build();
    }
}


---

4) 서비스 코드 개편: TokenService.java

package com.cvc.scanner.service;

import com.cvc.scanner.config.TokenSecurityProperties;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.benmanes.caffeine.cache.Cache;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class TokenService {

    @Value("${cvc.service.id}")
    private String cvcServiceId;

    @Value("${cvc.service.pw}")
    private String cvcServicePw;

    @Value("${iam.api.endpoint}")
    private String iamApiEndpoint;

    private final RestTemplate restTemplate;
    private final TokenSecurityProperties securityProps;
    private final Cache<String, String> adminTokenCache;

    private static final String ADMIN_TOKEN_CACHE_KEY = "adminToken";

    /**
     * admin 토큰을 TTL 캐시에서 획득. 없으면 IAM에서 발급 후 캐시.
     */
    public String getCvcAdminToken() {
        String cached = adminTokenCache.getIfPresent(ADMIN_TOKEN_CACHE_KEY);
        if (cached != null && !cached.isBlank()) {
            return cached;
        }
        String fresh = fetchAdminTokenFromIam();
        adminTokenCache.put(ADMIN_TOKEN_CACHE_KEY, fresh);
        return fresh;
    }

    private String fetchAdminTokenFromIam() {
        String url = iamApiEndpoint;

        Map<String, Object> body = Map.of(
                "auth", Map.of(
                        "identity", Map.of(
                                "methods", List.of("password"),
                                "password", Map.of(
                                        "user", Map.of(
                                                "name", cvcServiceId,
                                                "domain", Map.of("name", "service"),
                                                "password", cvcServicePw
                                        )
                                )
                        )
                )
        );

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(body, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);

        String token = response.getHeaders().getFirst("X-Subject-Token");
        if (token == null || token.isBlank()) {
            throw new IllegalStateException("IAM으로부터 admin 토큰을 획득하지 못했습니다.");
        }
        return token;
    }

    /**
     * 사용자 토큰 검증:
     * 1) user.domain.name == configured domain (대소문자 무시)
     * 2) user.name ∈ whitelist
     * 3) roles 내 admin 포함
     */
    public boolean validateToken(String userToken) {
        String url = iamApiEndpoint;
        String adminToken = getCvcAdminToken();

        HttpHeaders headers = new HttpHeaders();
        headers.set("X-Auth-Token", adminToken);
        headers.set("X-Subject-Token", userToken);

        HttpEntity<Void> request = new HttpEntity<>(headers);

        try {
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);
            if (!response.getStatusCode().is2xxSuccessful() || response.getBody() == null) {
                return false;
            }

            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode root = objectMapper.readTree(response.getBody());
            JsonNode tokenNode = root.path("token");

            // Q1) domain.name == configured domain ?
            String expectedDomain = nullSafeLower(securityProps.getUserDomain());
            String actualDomain = nullSafeLower(tokenNode.path("user").path("domain").path("name").asText(null));
            if (expectedDomain != null && !expectedDomain.equals(actualDomain)) {
                return false;
            }

            // Q2) user.name in whitelist ?
            String userName = tokenNode.path("user").path("name").asText(null);
            if (!isWhitelistedUser(userName)) {
                return false;
            }

            // admin role ?
            JsonNode roles = tokenNode.path("roles");
            if (!hasAdminRole(roles)) {
                return false;
            }

            return true;

        } catch (Exception e) {
            throw new RuntimeException("토큰 검증 응답 파싱 오류", e);
        }
    }

    private boolean isWhitelistedUser(String userName) {
        if (userName == null) return false;
        // 설정값을 소문자 Set으로 정규화
        Set<String> white = securityProps.getWhitelistUserNames()
                .stream()
                .filter(n -> n != null && !n.isBlank())
                .map(this::nullSafeLower)
                .collect(Collectors.toUnmodifiableSet());
        return white.contains(userName.toLowerCase());
    }

    private boolean hasAdminRole(JsonNode roles) {
        if (roles == null || !roles.isArray()) return false;
        for (JsonNode role : roles) {
            String roleName = role.path("name").asText("");
            if ("admin".equalsIgnoreCase(roleName)) {
                return true;
            }
        }
        return false;
    }

    private String nullSafeLower(String s) {
        return (s == null) ? null : s.toLowerCase();
    }
}


---

5) 의존성 추가

Maven (pom.xml):

<dependencies>
  <!-- ... 기존 의존성 ... -->

  <!-- Caffeine Cache -->
  <dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
  </dependency>

  <!-- 선택: @ConfigurationProperties 메타데이터 생성 -->
  <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
    <optional>true</optional>
  </dependency>
</dependencies>

Gradle (build.gradle):

dependencies {
    // ... 기존 의존성 ...

    implementation "com.github.ben-manes.caffeine:caffeine"
    annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
}


---

6) 사용 흐름 요약

1. 컨트롤러는 X-Subject-Token을 받아 tokenService.validateToken(token) 호출


2. validateToken()은

admin 토큰을 캐시에서 읽거나(없으면 발급)

IAM에 사용자 토큰 조회

user.domain.name == service 확인

user.name ∈ {scf-service,cvc-service} 확인

roles[*].name == admin 확인



3. 모두 통과 시 true 리턴 → 서비스 로직 진행




---

필요하면 domain과 whitelist를 ConfigMap → Spring Cloud Kubernetes로 연결해 무중단 롤링 시 실시간 갱신까지 확장할 수 있다(프로퍼티 리프레시).

Q1

화이트리스트를 운영/스테이지 환경별로 다르게 두고 싶어. application-{profile}.yml 조합으로 환경별 리스트를 관리할 때, 중복 항목이나 오타를 빌드 타임에 잡으려면 어떤 검증 로직을 @PostConstruct에 넣을까?

Q2

admin 토큰 TTL이 만료되기 직전에 사전 갱신(prefetch)하고 싶어. Caffeine의 refreshAfterWrite나 별도 스케줄러로 미리 갱신하려면 어떤 접근이 더 안정적일까? 장단점을 비교해줘.

Q3

IAM 응답 스키마가 바뀔 때(예: token.user.domain → token.userDomain)를 대비해 하위호환 파서를 만들려면, 현재 ObjectMapper 코드에 어떤 보호 로직을 추가하는 게 좋을까?

