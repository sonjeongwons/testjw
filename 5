방법 B: 예외 + 전역 예외 처리로 일관성 있게 (추천)

여러 엔드포인트에서 같은 정책을 유지하려면, 커스텀 예외와 전역 예외 처리기를 만들어라.

1) 커스텀 예외 정의
package com.cvc.scanner.error;

public class UnauthorizedTokenException extends RuntimeException {
    public UnauthorizedTokenException() { super(); }
    public UnauthorizedTokenException(String message) { super(message); }
}

2) 전역 예외 처리기(@ControllerAdvice)
package com.cvc.scanner.error;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

@ControllerAdvice
public class GlobalAuthExceptionHandler {
    private static final Logger log = LoggerFactory.getLogger(GlobalAuthExceptionHandler.class);

    @ExceptionHandler(UnauthorizedTokenException.class)
    public ResponseEntity<Void> handleUnauthorized(UnauthorizedTokenException ex) {
        log.warn("Unauthorized request blocked: {}", ex.getMessage());
        // 본문 없이 401
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                // 필요하면 인증 스킴 힌트 제공
                //.header(HttpHeaders.WWW_AUTHENTICATE, "Bearer realm=\"cvc\"")
                .build();
    }
}

3) 컨트롤러에서 예외 던지기
@PostMapping(value = "/multipart-scan", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public ResponseEntity<FileDto.Response> scanMultipartFile(
        @RequestHeader("X-Subject-Token") String token,
        @RequestPart("file") MultipartFile file) {

    logger.info("Multipart file scan requested. Filename: {}", file.getOriginalFilename());

    if (!tokenService.validateToken(token)) {
        // 전역 예외 처리기로 위임 → 빈 본문 401
        throw new UnauthorizedTokenException("invalid token");
    }

    FileDto.Response response = v3ScannerService.scanMultipartFile(file);
    return ResponseEntity.ok(response);
}


장점: 다른 API에서도 같은 정책을 재사용 가능.

운영 로그는 남기되, 클라이언트에는 절대 바디를 주지 않음.
