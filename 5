나는 java spring framework를 통해 아래와 같이 FileDto.java, V3ScannerController.java, TokenService.java를 작성 중이야.
맨 아래 "validate값 예시"처럼 해당 json 값에 대해서 Admin 권한인지 체크하는 로직이 TokenService.java에 현재 추가되어있어. 나는 여기서 추가적으로 한가지 더 체크 하기를 원해. 
user스코프 내 name이 "scf-service", "cvc-service" 인 것만 화이트리스트 체크방식으로 API 요청을 허용하도록 체크하고싶어. 해당 로직을 TokenService.java에 추가시켜줘. 그래서 role에 대해서 admin이고, user 내 name이 scf-service, cvc-service 인것만 허용하도록 이 결과를 만족하는 경우에만 validateToken 메소드 리턴값을 true를 반환하는 형식으로 하면어떨까해

// FileDto.java

package com.cvc.scanner.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.*;
import jakarta.validation.Valid;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class FileDto {

    @NotBlank(message = "파일명을 입력해주세요")
    private String fileName;

    @NotBlank(message = "파일 데이터를 입력해주세요")
    private String fileData;

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class Request {

        @NotBlank(message = "파일명을 입력해주세요")
        private String fileName;

        @NotBlank(message = "파일 데이터를 입력해주세요")
        private String fileData;
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Builder
    public static class Response {

        private String fileName;

        private int returnCode;

        private String message;
    }
}

// V3ScannerController.java

package com.cvc.scanner.controller;

import com.cvc.scanner.dto.FileDto;
import com.cvc.scanner.service.TokenService;
import com.cvc.scanner.service.V3ScannerService;
import com.sun.net.httpserver.HttpsServer;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.io.InputStream;
import java.util.Random;

import org.springframework.http.HttpStatus;
import jakarta.validation.Valid;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/scanner")
public class V3ScannerController {

    private static final Logger logger = LoggerFactory.getLogger(V3ScannerController.class);

    @Autowired
    private V3ScannerService v3ScannerService;
    @Autowired
    private TokenService tokenService;

    @GetMapping("/simple")
    public ResponseEntity<Map<String, Object>> simpleScan(@RequestHeader("X-Subject-Token") String Token, @RequestParam String fileName) {
        logger.info("Simple scan requested. Filename: {}, API Key: {}", fileName, Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
//        }
        return ResponseEntity.ok(v3ScannerService.simpleScan(fileName));
    }

    @GetMapping("/remote")
    public ResponseEntity<Map<String, Object>> remoteScan(@RequestHeader("X-Subject-Token") String Token, @RequestParam String fileName) {
        logger.info("Remote scan requested. Filename: {}, API Key: {}", fileName, Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
//        }
        return ResponseEntity.ok(v3ScannerService.remoteScan(fileName));
    }

    @GetMapping("/detail")
    public ResponseEntity<Map<String, Object>> detailScan(@RequestHeader("X-Subject-Token") String Token, @RequestParam String fileName) {
        logger.info("Detail scan requested. Filename: {}, API Key: {}", fileName, Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(401).body(Map.of("error", "Unauthorized", "message", "Invalid API Key"));
//        }
        return ResponseEntity.ok(v3ScannerService.detailScan(fileName));
    }


    @PostMapping("/base64-scan")
    public ResponseEntity<FileDto.Response> scanFile(
            @RequestHeader("X-Subject-Token") String Token,
            @Valid @RequestBody FileDto.Request fileDtoRequest) {
        logger.info("File scan requested. Filename: {}, API Key: {}", fileDtoRequest.getFileName(), Token);
//        if (v3ScannerService.validateToken(Token)) {
//            logger.warn("Unauthorized access attempt with API Key: {}", Token);
//            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
//                    FileDto.Response.builder()
//                            .fileName(fileDtoRequest.getFileName())
//                            .returnCode(HttpStatus.UNAUTHORIZED.value())
//                            .message("Unauthorized: Invalid API Key")
//                            .build()
//            );
//        }
        FileDto.Response response = v3ScannerService.scanBase64File(fileDtoRequest);
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }

    @PostMapping(value = "/multipart-scan", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public ResponseEntity<FileDto.Response> scanMultipartFile(
            @RequestHeader("X-Subject-Token") String token,
            @RequestPart("file") MultipartFile file) {

        logger.info("Multipart file scan requested. Filename: {}, User Token: {}", file.getOriginalFilename(), token);
        boolean isValid = tokenService.validateToken(token);
        if(!isValid){
            logger.info("인증 토큰이 유효하지 않습니다.");
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(FileDto.Response.builder()
                            .fileName(file.getOriginalFilename())
                            .returnCode(HttpStatus.UNAUTHORIZED.value())
                            .message("인증 토큰이 유효하지 않습니다.")
                            .build());
        }
        FileDto.Response response = v3ScannerService.scanMultipartFile(file);
        return ResponseEntity.status(HttpStatus.OK).body(response);
    }

    @PostMapping(value = "/binary-scan", consumes = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public ResponseEntity<FileDto.Response> scanBinaryFile(
            @RequestHeader("X-Subject-Token") String Token,
            @RequestHeader("File-Name") String fileName,
            HttpServletRequest request) {

//        if (v3ScannerService.validateToken(Token)) {
//            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
//                    FileDto.Response.builder()
//                            .fileName(fileName)
//                            .returnCode(HttpStatus.UNAUTHORIZED.value())
//                            .message("Unauthorized: Invalid API Key")
//                            .build()
//            );
//        }

        try (InputStream inputStream = request.getInputStream()) {
            FileDto.Response response = v3ScannerService.scanBinaryFile(fileName, inputStream);
            return ResponseEntity.status(HttpStatus.OK).body(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    FileDto.Response.builder()
                            .fileName(fileName)
                            .returnCode(-1)
                            .message("Error processing file: " + e.getMessage())
                            .build()
            );
        }
    }

    @PostMapping(value = "/upload-chunk", consumes = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public ResponseEntity<String> uploadChunk(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("Chunk-Index") int chunkIndex,  // 청크 인덱스
            @RequestHeader("Total-Chunks") int totalChunks,  // 전체 청크 개수
            @RequestBody byte[] chunkData) {  // 청크 데이터

        try {
            v3ScannerService.saveChunk(fileId, chunkIndex, chunkData);
            return ResponseEntity.ok("Chunk uploaded successfully.");
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Chunk upload failed: " + e.getMessage());
        }
    }

    /**
     * 병합 및 스캔 엔드포인트
     */
    @PostMapping("/merge-chunks")
    public ResponseEntity<FileDto.Response> mergeChunksAndScan(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("File-Name") String fileName) {  // 원래 파일 이름

        try {
            FileDto.Response response = v3ScannerService.mergeChunksAndScan(fileId, fileName);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(
                    FileDto.Response.builder()
                            .fileName(fileName)
                            .returnCode(-1)
                            .message("Failed to merge and scan chunks: " + e.getMessage())
                            .build()
            );
        }
    }

    @GetMapping("/status")
    public ResponseEntity<FileDto.Response> getStatus() {
        logger.info("API status requested.");
        String[] fileNames = {"TestFile", "TestFolder","TestZip","Wow","Hello"};
        Random random = new Random();
        String fileName=fileNames[random.nextInt(fileNames.length)];
        return ResponseEntity.status(HttpStatus.OK).body(
                FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(0)
                        .message("API is running")
                        .build()
        );
    }

    @PostMapping("/status")
    public ResponseEntity<FileDto.Response> modifyStatus(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("File-Name") String fileName) {
        logger.info("Post메소드가 호출되었습니다.");
        String[] numbers = {"0","1"};
        Random random = new Random();
        String number=numbers[random.nextInt(numbers.length)];
        return ResponseEntity.status(HttpStatus.OK).body(
                FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(Integer.parseInt(number))
                        .message("File ID is : " + fileId)
                        .build()
        );
    }

    @GetMapping("/test")
    public ResponseEntity<FileDto.Response> callTest(
            @RequestHeader("File-Id") String fileId,  // 파일 ID
            @RequestHeader("File-Name") String fileName) {
        logger.info("TEST API is Called. 파일ID는 " + fileId +" 이고, 파일이름은 " + fileName + " 입니다.");
        return ResponseEntity.status(HttpStatus.OK).body(
                FileDto.Response.builder()
                        .fileName(fileName)
                        .returnCode(-1)
                        .message("마지막으로 파일ID는 " + fileId)
                        .build()
        );
    }
}


// TokenService.java

package com.cvc.scanner.service;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.HttpServerErrorException;
import org.springframework.web.client.RestTemplate;

import java.util.List;
import java.util.Map;

@Service
public class TokenService {

    @Value("${cvc.service.id}")
    private String cvcServiceId;

    @Value("${cvc.service.pw}")
    private String cvcServicePw;

    @Value("${iam.api.endpoint}")
    private String iamApiEndpoint;

    private final RestTemplate restTemplate;

    public TokenService(RestTemplate restTemplate) {
        this.restTemplate = restTemplate;
    }

    public String getCvcAdminToken() {
        //String url = iamApiEndpoint + "/v3/auth/tokens?nocatalog=null";
        String url = iamApiEndpoint;

        Map<String, Object> body = Map.of(
                "auth", Map.of(
                        "identity", Map.of(
                                "methods", List.of("password"),
                                "password", Map.of(
                                        "user", Map.of(
                                                "name", cvcServiceId,
                                                "domain", Map.of("name", "service"),
                                                "password", cvcServicePw
                                        )
                                )
                        )
                )
        );

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(body, headers);

        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
        return response.getHeaders().getFirst("X-Subject-Token");
    }
    public boolean validateToken(String userToken) {
        //String url = iamApiEndpoint + "/v3/auth/tokens?nocatalog=null";
        String url = iamApiEndpoint;
        String adminToken = getCvcAdminToken();

        HttpHeaders headers = new HttpHeaders();
        headers.set("X-Auth-Token", adminToken);
        headers.set("X-Subject-Token", userToken);

        HttpEntity<Void> request = new HttpEntity<>(headers);

        try {
            ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, request, String.class);

            if (!response.getStatusCode().is2xxSuccessful()) {
                return false;
            }

            String responseBody = response.getBody();
            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode root = objectMapper.readTree(responseBody);
            JsonNode roles = root.path("token").path("roles");

            for (JsonNode role : roles) {
                String roleName = role.path("name").asText();
                if ("admin".equalsIgnoreCase(roleName)) {
                    return true;
                }
            }

            return false;

        } catch (Exception e) {
            throw new RuntimeException("Response 파싱에러: " , e);
        }
    }
}




// validate값 예시

{
  "token": {
    "methods": [
      "password"
    ],
    "user": {
      "domain": {
        "id": "0860cdd74e06475395d29f14848cba22",
        "name": "service"
      },
      "id": "b5a83c42cf204d74842c6f0bc2fbb08a",
      "name": "scf-service",
      "password_expires_at": null
    },
    "audit_ids": [
      "t2K_voIxTSiK9yyQD3d_8w"
    ],
    "expires_at": "2025-05-02T15:21:21.000000Z",
    "issued_at": "2025-05-02T03:21:21.000000Z",
    "project": {
      "domain": {
        "id": "0860cdd74e06475395d29f14848cba22",
        "name": "service"
      },
      "id": "33b532c466824bcf9324101a3c6f3015",
      "name": "service-dp-scf"
    },
    "is_domain": false,
    "roles": [
      {
        "id": "521b706a398243f281f7e4b98296f671",
        "name": "admin"
      },
      {
        "id": "a5c62ffa0e7a4ccca077094e64ecc35a",
        "name": "reader"
      },
      {
        "id": "0b0467920fe04cbd9d479e2eab84575a",
        "name": "manager"
      },
      {
        "id": "cbf6c7f89b084734927bd40bf8ce0681",
        "name": "member"
      }
    ]
  }
}
