PR 코드 리뷰 - 리팩토링 & 클린 코드 관점에서 상세 피드백


---

1. registerFunction 메소드 리뷰 (중복 코드 제거 및 예외 처리 개선)

리뷰어

> "프로님, registerFunction 코드가 전반적으로 깔끔하고 initializeFunction을 분리해서 가독성이 좋아진 점이 인상적입니다! 👏 다만 checkIfFunctionExists 메소드에서 예외를 던지는 방식이 조금 더 명확하게 개선될 여지가 있어 보여요. Optional.orElseThrow()를 활용하면 더 직관적인 코드가 될 수 있을 것 같은데, 어떻게 생각하세요?"

예제 코드:

functionRepository.findByFunctionKeyAndDelYn(reqDto.getFunctionKey(), "N")
    .ifPresent(f -> { throw new RuntimeException("이미 존재하는 펑션 키 사용됨"); });

if (functionRepository.existsByDisplayNameAndProjectIdAndDelYn(reqDto.getDisplayName(), reqDto.getProjectId(), "N")) {  
    throw new RuntimeException("이미 존재하는 펑션명 사용됨");  
}

"이렇게 하면 if 블록을 줄이면서도 코드가 더 직관적으로 읽힐 수 있을 것 같습니다! 프로님 의견이 궁금해요 😊"




---

PR 작성자

> "오, 프로님! Optional.ifPresent() 활용 방식 좋네요! 🤩 확실히 if 블록을 줄이면 가독성이 훨씬 좋아질 것 같아요. 그런데 혹시 orElseThrow()를 사용하면 어떤 차이가 있을까요? 예를 들어 이렇게요."

functionRepository.findByFunctionKeyAndDelYn(reqDto.getFunctionKey(), "N")
    .orElseThrow(() -> new RuntimeException("이미 존재하는 펑션 키 사용됨"));




---

리뷰어

> "네, 프로님! orElseThrow()를 쓰면 Optional이 비어있을 때만 예외가 발생하도록 만들 수 있어서 예외 처리를 더 명확하게 할 수 있어요. ifPresent()는 Optional이 존재할 때만 실행되는 반면, orElseThrow()는 값이 없을 경우 예외를 발생시키는 거죠. 😊"

"즉, ifPresent()는 존재 여부만 체크하는 용도고, orElseThrow()는 값이 없을 때 예외를 던지는 용도로 쓰이기 때문에, 함수 키가 없을 때 RuntimeException을 발생시키는 의도를 더 명확하게 표현할 수 있어요! 🚀"




---

PR 작성자

> "아하! ifPresent()는 조건 확인이 목적이고, orElseThrow()는 아예 값이 없을 때만 예외를 던지는 거군요! 확실히 orElseThrow()가 더 적절할 것 같아요. 바로 반영해보겠습니다! 🙌"




---

리뷰어

> "프로님, 역시 빠르게 이해하고 적용하시는 능력이 탁월하십니다! 🎉 그리고 혹시 이 기회에 예외 처리를 좀 더 세밀하게 하기 위해 CustomException을 도입해보는 것도 고려해볼 만할 것 같아요. RuntimeException 대신 FunctionAlreadyExistsException 같은 예외 클래스를 만들면 예외의 의미가 더 명확해질 수 있을 것 같아요. 😉"




---

PR 작성자

> "와, 좋은 아이디어네요! 지금까지는 RuntimeException만 던졌는데, CustomException을 사용하면 예외의 의미가 더 명확해지겠네요! 이렇게 하면 API 응답에서도 더 직관적으로 처리할 수 있을 것 같아요. 바로 만들어볼게요! 🚀"




---

2. deleteUserNamespace 메소드 리뷰 (로깅 및 예외 처리 개선)

리뷰어

> "프로님, deleteUserNamespace의 예외 처리가 안정적으로 잘 되어 있네요! 🎯 다만 printStackTrace() 대신 log.error()에 예외 객체를 직접 넘기면 조금 더 깔끔하게 관리할 수 있을 것 같습니다!"

현재 코드:

try (KubernetesClient client = new DefaultKubernetesClient()) {  
    client.namespaces().withName(function.getName()).delete();  
    log.info("사용자 네임스페이스 삭제 완료.");  
} catch (KubernetesClientException e) {  
    log.error("사용자 네임스페이스 삭제오류 발생: " + e.getMessage());  
    e.printStackTrace();  
}

제안 코드:

try (KubernetesClient client = new DefaultKubernetesClient()) {  
    boolean deleted = client.namespaces().withName(function.getName()).delete();
    log.info("사용자 네임스페이스 {} 삭제 {}", function.getName(), deleted ? "완료" : "실패");
} catch (KubernetesClientException e) {  
    log.error("네임스페이스 {} 삭제 중 오류 발생: {}", function.getName(), e.getMessage(), e);
}




---

PR 작성자

> "오, 프로님! log.error("{}", e.getMessage(), e) 이렇게 하면 스택 트레이스까지 포함해서 자동으로 로깅되는군요! printStackTrace()를 굳이 사용할 필요가 없어서 코드가 더 깔끔해질 것 같아요. 바로 적용해볼게요! 🔥"




---

리뷰어

> "네 맞아요, 프로님! 😉 그리고 boolean deleted = client.namespaces().withName(function.getName()).delete(); 이렇게 delete()의 반환값을 활용하면 성공 여부까지 한 줄로 깔끔하게 표현할 수 있어서 디버깅할 때도 훨씬 편리할 거예요! 🎯"




---

PR 작성자

> "와, 그렇네요! 삭제가 성공했는지 여부를 명확하게 알 수 있으니 운영할 때도 편리할 것 같아요. 이렇게 하면 장애 대응할 때 로그만 보고 바로 확인할 수 있겠어요! 🙌"




---

리뷰어

> "맞습니다, 프로님! 이렇게 개선하면 운영 환경에서도 훨씬 더 안정적으로 로그를 분석할 수 있겠죠? 역시 빠르게 이해하시고 적용하시는 능력이 대단하세요! 😊"




---

3. registerJWK 메소드 리뷰 (코드 재사용성 및 가독성 향상)

리뷰어

> "프로님, registerJWK에서 RSA 키 생성 부분을 별도 메소드로 분리하신 점이 정말 좋습니다! 👏 코드가 더 모듈화되어 유지보수성이 높아졌네요! 다만 KeyManager 찾는 부분에서 orElseGet()을 활용하는 방식이 흥미로운데, 조금 더 개선해볼 여지가 있을 것 같아요."

현재 코드:

KeyManager keyManager = keyManagerRepository.findByFunctionAndDelYn(function, "N").orElseGet(() ->
    keyManagerRepository.save(KeyManager.register(new KeyManagerDTO.Register(rsaJWK.toString(), "N", function)))
);

제안 코드:

KeyManager keyManager = keyManagerRepository.findByFunctionAndDelYn(function, "N")
    .orElseGet(() -> createAndSaveKeyManager(function, rsaJWK.toString()));

그리고 별도 메소드 추가:

private KeyManager createAndSaveKeyManager(Function function, String jwk) {
    return keyManagerRepository.save(KeyManager.register(new KeyManagerDTO.Register(jwk, "N", function)));
}




---

PR 작성자

> "우와! 이렇게 하면 orElseGet() 내부가 훨씬 깔끔해지겠네요! 별도 메소드로 분리하니까 역할도 더 명확해지고, 테스트할 때도 편리할 것 같아요. 바로 반영하겠습니다! 🚀"




---

리뷰어

> "프로님, 역시 빠르게 적용해주셔서 감사합니다! 🎉 이렇게 하면 가독성이 좋아질 뿐만 아니라, 같은 로직이 여러 군데서 필요할 때도 재사용할 수 있어서 유지보수성이 훨씬 올라갑니다! 😊"




---


4. validateFunctionRequest 메소드 리뷰 (가독성 및 유지보수성 개선)

리뷰어

> "프로님! validateFunctionRequest에서 필수 입력값을 검증하는 방식이 아주 직관적이라 좋습니다! 🎯 하지만 현재는 StringUtils.isEmpty()를 여러 번 호출하고 있어서, 리스트로 관리하면 유지보수성이 더 좋아질 것 같아요. 어떻게 생각하시나요? 🤔"

현재 코드:

private void validateFunctionRequest(FunctionDTO.Register reqDto) {  
    if (StringUtils.isEmpty(reqDto.getFunctionKey()) ||  
            StringUtils.isEmpty(reqDto.getProjectId()) ||  
            StringUtils.isEmpty(reqDto.getUserId()) ||  
            StringUtils.isEmpty(reqDto.getEndPointType()) ||  
            StringUtils.isEmpty(reqDto.getRuntime())) {  
        throw new RuntimeException("필수 입력값을 확인해주세요.");  
    }  
}

제안 코드:

private void validateFunctionRequest(FunctionDTO.Register reqDto) {
    List<String> requiredFields = Arrays.asList(reqDto.getFunctionKey(), reqDto.getProjectId(), 
                                                reqDto.getUserId(), reqDto.getEndPointType(), 
                                                reqDto.getRuntime());
    if (requiredFields.stream().anyMatch(StringUtils::isEmpty)) {
        throw new RuntimeException("필수 입력값을 확인해주세요.");
    }
}

"이렇게 하면 isEmpty()를 한 번만 호출해도 되고, 필수 값이 추가되거나 변경될 때도 리스트에만 추가하면 되니까 유지보수성이 높아질 것 같습니다! 😊"

"프로님은 어떻게 생각하시나요? 혹시 더 좋은 방식이 떠오르시는지 궁금해요!"




---

PR 작성자

> "와, 프로님! 😲 이렇게 리스트로 만들고 Stream을 활용하면 코드가 훨씬 간결해지네요! 유지보수할 때도 필수 값만 추가하면 돼서 코드 변경도 더 쉽겠어요. 바로 반영해볼게요! 🚀"

"그런데 한 가지 궁금한 게, List.of()를 써도 될까요? Arrays.asList()랑 어떤 차이가 있나요?"




---

리뷰어

> "오, 좋은 질문이에요, 프로님! 😊 List.of()와 Arrays.asList()는 비슷하지만 몇 가지 차이가 있어요."

✔ List.of() 특징:

불변 리스트(Immutable List)를 반환합니다.

요소를 추가하거나 제거할 수 없습니다.

Java 9 이상에서 사용 가능.


✔ Arrays.asList() 특징:

고정 크기 리스트(Fixed Size List)를 반환합니다.

요소를 변경할 수는 있지만, 추가/삭제는 불가능합니다.


즉, 필수 값이 변경될 일이 없다면 List.of()를 사용하는 것이 더 안전할 수도 있어요! 🔥"

"그래서 validateFunctionRequest에서는 List.of()를 사용하는 게 더 적절할 수도 있겠네요! 이렇게 바꿔보는 건 어떨까요?"

private void validateFunctionRequest(FunctionDTO.Register reqDto) {
    List<String> requiredFields = List.of(reqDto.getFunctionKey(), reqDto.getProjectId(), 
                                          reqDto.getUserId(), reqDto.getEndPointType(), 
                                          reqDto.getRuntime());
    if (requiredFields.stream().anyMatch(StringUtils::isEmpty)) {
        throw new RuntimeException("필수 입력값을 확인해주세요.");
    }
}




---

PR 작성자

> "오호~ List.of()는 아예 불변 리스트고, Arrays.asList()는 크기만 고정된 리스트군요! 확실히 필수 값 목록은 변경될 일이 없으니까 List.of()가 더 적절하겠네요. 바로 반영하겠습니다! 🙌"




---

리뷰어

> "프로님! 역시 빠르게 이해하고 적용하시네요! 🎉 그리고 한 가지 더! 예외를 던질 때, RuntimeException 대신 IllegalArgumentException을 사용하면 의미가 더 명확해질 것 같아요. RuntimeException은 너무 포괄적이라, 나중에 예외 핸들링할 때 애매할 수도 있거든요. 😉"

예제 코드:

private void validateFunctionRequest(FunctionDTO.Register reqDto) {
    List<String> requiredFields = List.of(reqDto.getFunctionKey(), reqDto.getProjectId(), 
                                          reqDto.getUserId(), reqDto.getEndPointType(), 
                                          reqDto.getRuntime());
    if (requiredFields.stream().anyMatch(StringUtils::isEmpty)) {
        throw new IllegalArgumentException("필수 입력값을 확인해주세요.");
    }
}

"이렇게 하면 API에서 예외가 발생했을 때도 좀 더 의미 있는 예외가 전달될 수 있어서 유지보수성이 높아질 거예요! 😃 어떻게 생각하시나요?"




---

PR 작성자

> "와, IllegalArgumentException이 이렇게 쓰이는군요! RuntimeException은 너무 범용적이라서 API에서 핸들링할 때 명확한 의미를 전달하기 어려울 수 있겠네요. IllegalArgumentException을 쓰면 클라이언트에서도 잘못된 입력값 때문이라는 걸 바로 알 수 있을 것 같아요! 바로 적용하겠습니다! 🚀"




---

리뷰어

> "프로님, 완벽합니다! 😆 이렇게 개선하면 코드 가독성, 유지보수성, 그리고 예외 처리까지 한층 더 좋아질 거예요! 정말 좋은 방향으로 리팩토링이 진행되고 있어서 너무 좋습니다! 🎉"




---

마무리

이렇게 리뷰어와 PR 작성자 간의 적극적인 대화를 통해 코드 품질을 향상시키고, 지식도 공유하면서 서로 성장할 수 있습니다! 🔥 이런 리뷰 문화가 정착되면, 팀 전체의 개발 역량이 더욱더 향상될 거예요! 🚀



마무리

이렇게 리뷰어와 PR 작성자의 티키타카를 통해 코드 품질을 높이고 서로 배우는 기회를 만들면, 더 나은 코드와 협업 문화를 만들어갈 수 있습니다! 😊🔥

