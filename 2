package com.scf.manager.mvc.service;

import com.google.gson.Gson;
import com.scf.manager.mvc.domain.Function;
import com.scf.manager.mvc.dto.FunctionLogDTO;
import com.scf.manager.mvc.repository.FunctionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.json.JSONArray;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Value;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class FunctionLogService {
    @Value("${monitoring.http.timeout}")
    private int timeOutValue;
    @Value("${monitoring.lethe.letheHttpApi}")
    private String letheHttpApi;
    private final FunctionRepository functionRepository;

    public FunctionLogDTO getLogByRange(String functionKey, String time, String pod) throws IOException {
        StringBuilder letheLogQuery = makeLogQueryString(functionKey, time, pod);

        return new Gson().fromJson(getLetheLogData(letheLogQuery.toString()), FunctionLogDTO.class);
    }

    @NotNull
    private StringBuilder makeLogQueryString(String functionKey, String time, String pod) {
        Function function = functionRepository.findByFunctionKey(functionKey).orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
        String functionName;

        // 별도 Pod Instance 미지정 시, 전체 로그 조회 수행
        if (pod == null || pod.isEmpty()) {
            functionName=function.getName().concat(".*");
        } else {  //특정 Pod Instance 지정 시, 해당 Pod에 대한 부분 로그 조회 수행
            functionName = pod;
        }

        String queryEndTime = String.valueOf(new Date().getTime() / 1000L); //현재 시각 타임스탬프

        Calendar currentCal = Calendar.getInstance();
        currentCal.add(Calendar.HOUR_OF_DAY, Integer.valueOf("-".concat(time))); // 시간 계산
        String queryStartTime = String.valueOf(new Date(currentCal.getTimeInMillis()).getTime() / 1000L); //현재 시각 1/3/12 시간 전 타임스탬프

        //쿼리 결과값 예시 ↓
        //query=pod{namespace="sampleNamespace",pod="hello.*",container="user-container"}&start=1665552010&end=1665552490
        StringBuilder letheLogQuery = new StringBuilder();
        letheLogQuery.append("query=pod{namespace=\"").append(function.getName()).append("\",pod=\"").append(functionName).append("\",container=\"user-container\"}&start=").append(queryStartTime).append("&end=").append(queryEndTime).append("&logFormat=json");
        return letheLogQuery;
    }

    private String getLetheLogData(String query) throws IOException {
        // Lethe의 URL을 생성하고, Connection을 맺는다
        HttpURLConnection connection = establishLetheConnection(query);

        if(connection.getResponseCode()== HttpURLConnection.HTTP_OK ){
            // Lethe에게 받은 응답(Raw response)을 RAW JSON(Stirng) 형태로 변환한다
            String jsonResponse= retrieveRawJSON(connection);

            // Raw JSON을 직렬화하고, 필요한 정보를 추출하여 Information JSON(String)으로 변환한다.
            return extractInformationFromRawJSON(jsonResponse);
        }

        return null;
    }

    private HttpURLConnection establishLetheConnection(String query) throws IOException {
        URL url = new URL(letheHttpApi+"?"+ query);
        log.info("URL =" + url.toString());
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setConnectTimeout(timeOutValue);
        connection.setReadTimeout(timeOutValue);
        connection.setRequestMethod("GET");
        connection.setDoOutput(true);
        connection.connect();
        return connection;
    }

    private String retrieveRawJSON(HttpURLConnection connection) throws IOException {
        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        StringBuffer stringBuffer = new StringBuffer();


        String inputLine;

        while ((inputLine = bufferedReader.readLine()) != null)  {
            stringBuffer.append(inputLine);
        }
        bufferedReader.close();
        return stringBuffer.toString();
    }

    private String extractInformationFromRawJSON(String jsonResponse) {
        JSONObject jsonObject = new JSONObject(jsonResponse);
        String status = jsonObject.getString("status");
        JSONObject dataObject = jsonObject.getJSONObject("data");
        String resultType = dataObject.getString("resultType");
        JSONArray resultArray = dataObject.getJSONArray("result");

        List<String> podList = new ArrayList<>();

        // "time"과 "log" 키만 추출해서 새로운 JsonArray 생성
        JSONArray extractedArray = new JSONArray();
        for (int i = resultArray.length() - 1; i >= 0; i--) {
            JSONObject logObject = resultArray.getJSONObject(i);

            JSONObject extractedLogObject = new JSONObject();
            extractedLogObject.put("time", logObject.getString("time"));
            extractedLogObject.put("log", logObject.getString("log"));

            extractedArray.put(extractedLogObject);

            // Pod Instance 별도 리스트로 구성
            podList.add(logObject.getString("pod"));
        }

        // Pod Instance List 내 중복 데이터 제거 + 오름차순 정렬
        podList = podList.stream().distinct().sorted().collect(Collectors.toList());

        //추출한 정보들을 새로운 JSONObject에 담는다
        JSONObject extractedJson = new JSONObject();
        extractedJson.put("status", status);
        //extractedJson.put("data", new JSONObject().put("resultType", resultType).put("result", extractedArray));
        extractedJson.put("data", new JSONObject().put("resultType", resultType).put("pods", podList).put("result", extractedArray));

        return extractedJson.toString();
    }


}
