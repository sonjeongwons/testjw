package com.scf.manager.mvc.service;

import com.scf.manager.common.exception.ResourceNotFoundException;
import com.scf.manager.common.util.AppUtil;
import com.scf.manager.mvc.domain.BaseImage;
import com.scf.manager.mvc.dto.BaseImageDTO;
import com.scf.manager.mvc.repository.BaseImageRepository;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

import static com.scf.manager.common.constants.ExceptionConst.BASEIMAGE_NOTFOUND_EXCEPTION;


@Slf4j
@Service
@RequiredArgsConstructor
public class BaseImageService {
	private final BaseImageRepository baseImageRepository;

    @Transactional
    public BaseImageDTO.Response registerBaseImage(BaseImageDTO.Register reqDto) {
        BaseImage baseImage = baseImageRepository.save(
                        BaseImage.register(reqDto)
        );
        return AppUtil.getMapper().map(baseImage, BaseImageDTO.Response.class);
    }

    @Transactional(readOnly = true)
    public List<BaseImageDTO.Response> searchAllBaseImage() {
        return baseImageRepository.findAllByOrderByNameAscVersionDesc()
                .stream()
                .sorted((b1, b2) -> {
                    String runtime1 = b1.getName();
                    String runtime2 = b2.getName();
                    String[] version1 = b1.getVersion().split("\\.");
                    String[] version2 = b2.getVersion().split("\\.");
                    int v1 = Integer.parseInt(version1[0]);
                    int v2 = Integer.parseInt(version2[0]);

                    if (!runtime1.equals(runtime2)) {
                        return runtime1.compareTo(runtime2);
                    } else {
                        if (v1 != v2) {
                            return v2 - v1;
                        }
                        return Integer.parseInt(version2[1]) - Integer.parseInt(version1[1]);
                    }
                })
                .map(BaseImage::toDto)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public BaseImageDTO.Response searchBaseImage(Long baseImageSeq) {
        BaseImage baseImage = baseImageRepository.findById(baseImageSeq).orElseThrow(() -> new ResourceNotFoundException(BASEIMAGE_NOTFOUND_EXCEPTION));
        return AppUtil.getMapper().map(baseImage, BaseImageDTO.Response.class);
    }

    @Transactional
    public BaseImageDTO.Response modifyBaseImage(Long baseImageSeq, BaseImageDTO.Modify reqDto) {
        BaseImage baseImage = baseImageRepository.findById(baseImageSeq).orElseThrow(() -> new ResourceNotFoundException(BASEIMAGE_NOTFOUND_EXCEPTION));
        baseImage.modify(reqDto);
        baseImageRepository.save(baseImage);
        return AppUtil.getMapper().map(baseImage, BaseImageDTO.Response.class);
    }

}
