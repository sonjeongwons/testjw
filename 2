ë¦¬íŒ©í† ë§ ë° í´ë¦° ì½”ë“œ ì ìš© ê°œì„ ì‚¬í•­

ì´ ì½”ë“œì˜ ì£¼ìš” ë¬¸ì œì ì€ ê°€ë…ì„±, ì¤‘ë³µ ì½”ë“œ, ì˜ˆì™¸ ì²˜ë¦¬ ë¯¸í¡, í•˜ë“œì½”ë”©ëœ ë¬¸ìì—´, ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP) ìœ„ë°˜ì…ë‹ˆë‹¤. ì´ë¥¼ ê°œì„ í•˜ê¸° ìœ„í•´ ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.


---

ğŸ“Œ ì£¼ìš” ê°œì„ ì‚¬í•­

1. ì¤‘ë³µ ì½”ë“œ ì œê±° ë° ë©”ì†Œë“œ ë¶„ë¦¬

retrieveRawJSON()ê³¼ extractInformationFromRawJSON()ì—ì„œ ë¶ˆí•„ìš”í•œ ì¤‘ë³µì´ ë°œìƒ.

JSON ë°ì´í„° íŒŒì‹±ì„ extractLogData() ë©”ì†Œë“œë¡œ ë¶„ë¦¬í•˜ì—¬ extractInformationFromRawJSON()ì´ ë„ˆë¬´ ë§ì€ ì±…ì„ì„ ê°–ì§€ ì•Šë„ë¡ ê°œì„ .


2. ëª…í™•í•œ ë³€ìˆ˜ëª… ë° ìƒìˆ˜í™”

"user-container", "status", "resultType" ë“± í•˜ë“œì½”ë”©ëœ ë¬¸ìì—´ì„ ìƒìˆ˜í™”í•˜ì—¬ ìœ ì§€ë³´ìˆ˜ì„±ì„ í–¥ìƒ.

StringBuffer ëŒ€ì‹  StringBuilder ì‚¬ìš©. StringBufferëŠ” synchronized ì²˜ë¦¬ë˜ì–´ ìˆì§€ë§Œ, ë©€í‹°ìŠ¤ë ˆë”©ì´ í•„ìš” ì—†ëŠ” í™˜ê²½ì—ì„œëŠ” StringBuilderê°€ ì„±ëŠ¥ì´ ë” ì¢‹ìŒ.


3. ì˜ˆì™¸ ì²˜ë¦¬ ë° ë¡œê¹… ê°œì„ 

RuntimeException ëŒ€ì‹  ëª…í™•í•œ ì˜ë¯¸ë¥¼ ê°€ì§€ëŠ” IllegalArgumentException ì‚¬ìš©.

connection.getResponseCode()ê°€ HTTP_OKê°€ ì•„ë‹ ë•Œ ì ì ˆí•œ ì˜ˆì™¸ë¥¼ ë˜ì§€ë„ë¡ ë³€ê²½í•˜ì—¬ ë””ë²„ê¹…ì´ ì‰¬ì›Œì§.


4. ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP) ì ìš©

getLogByRange() ë©”ì†Œë“œì—ì„œ makeLogQueryString()ê³¼ getLetheLogData()ë¥¼ ë³„ë„ë¡œ ë¶„ë¦¬í•˜ì—¬ ê°€ë…ì„±ì„ í–¥ìƒ.

JSON ë°ì´í„°ë¥¼ JSONObjectì—ì„œ ì§ì ‘ ë³€í™˜í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ì „ìš© DTO í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ JSON ë³€í™˜ ë¡œì§ì„ ë¶„ë¦¬í•˜ëŠ” ê²ƒì´ ë” ì¢‹ì§€ë§Œ, ì´ë²ˆ ë¦¬íŒ©í† ë§ì—ì„œëŠ” ê¸°ì¡´ êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë©´ì„œ ì½”ë“œë§Œ ê°œì„ .



---

ğŸ“Œ ê°œì„ ëœ ì½”ë“œ

package com.scf.manager.mvc.service;

import com.google.gson.Gson;
import com.scf.manager.mvc.domain.Function;
import com.scf.manager.mvc.dto.FunctionLogDTO;
import com.scf.manager.mvc.repository.FunctionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.json.JSONArray;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Value;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class FunctionLogService {
    
    @Value("${monitoring.http.timeout}")
    private int timeOutValue;
    
    @Value("${monitoring.lethe.letheHttpApi}")
    private String letheHttpApi;
    
    private final FunctionRepository functionRepository;

    private static final String CONTAINER_NAME = "user-container";
    private static final String QUERY_FORMAT = "query=pod{namespace=\"%s\",pod=\"%s\",container=\"" + CONTAINER_NAME + "\"}&start=%s&end=%s&logFormat=json";

    public FunctionLogDTO getLogByRange(String functionKey, String time, String pod) throws IOException {
        String letheLogQuery = makeLogQueryString(functionKey, time, pod);
        String logData = getLetheLogData(letheLogQuery);
        return new Gson().fromJson(logData, FunctionLogDTO.class);
    }

    @NotNull
    private String makeLogQueryString(String functionKey, String time, String pod) {
        Function function = functionRepository.findByFunctionKey(functionKey)
                .orElseThrow(() -> new IllegalArgumentException("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” í‘ì…˜ì…ë‹ˆë‹¤."));

        String functionName = (pod == null || pod.isEmpty()) ? function.getName().concat(".*") : pod;

        long queryEndTime = System.currentTimeMillis() / 1000L; // í˜„ì¬ ì‹œê° íƒ€ì„ìŠ¤íƒ¬í”„

        Calendar currentCal = Calendar.getInstance();
        currentCal.add(Calendar.HOUR_OF_DAY, -Integer.parseInt(time)); // ì‹œê°„ ê³„ì‚°
        long queryStartTime = currentCal.getTimeInMillis() / 1000L;

        return String.format(QUERY_FORMAT, function.getName(), functionName, queryStartTime, queryEndTime);
    }

    private String getLetheLogData(String query) throws IOException {
        HttpURLConnection connection = establishLetheConnection(query);

        if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {
            throw new IOException("Lethe ë¡œê·¸ ìš”ì²­ ì‹¤íŒ¨: HTTP ìƒíƒœ ì½”ë“œ " + connection.getResponseCode());
        }

        String jsonResponse = retrieveRawJSON(connection);
        return extractInformationFromRawJSON(jsonResponse);
    }

    private HttpURLConnection establishLetheConnection(String query) throws IOException {
        URL url = new URL(letheHttpApi + "?" + query);
        log.info("Lethe ìš”ì²­ URL: {}", url);

        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setConnectTimeout(timeOutValue);
        connection.setReadTimeout(timeOutValue);
        connection.setRequestMethod("GET");
        connection.setDoOutput(true);
        connection.connect();
        return connection;
    }

    private String retrieveRawJSON(HttpURLConnection connection) throws IOException {
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
            return bufferedReader.lines().collect(Collectors.joining());
        }
    }

    private String extractInformationFromRawJSON(String jsonResponse) {
        JSONObject jsonObject = new JSONObject(jsonResponse);
        JSONObject dataObject = jsonObject.getJSONObject("data");
        JSONArray resultArray = dataObject.getJSONArray("result");

        JSONArray extractedArray = extractLogData(resultArray);
        List<String> podList = extractPodList(resultArray);

        JSONObject extractedJson = new JSONObject();
        extractedJson.put("status", jsonObject.getString("status"));
        extractedJson.put("data", new JSONObject()
                .put("resultType", dataObject.getString("resultType"))
                .put("pods", podList)
                .put("result", extractedArray));

        return extractedJson.toString();
    }

    private JSONArray extractLogData(JSONArray resultArray) {
        JSONArray extractedArray = new JSONArray();
        for (int i = resultArray.length() - 1; i >= 0; i--) {
            JSONObject logObject = resultArray.getJSONObject(i);
            JSONObject extractedLogObject = new JSONObject()
                    .put("time", logObject.getString("time"))
                    .put("log", logObject.getString("log"));
            extractedArray.put(extractedLogObject);
        }
        return extractedArray;
    }

    private List<String> extractPodList(JSONArray resultArray) {
        return resultArray.toList().stream()
                .map(obj -> ((Map<String, Object>) obj).get("pod").toString())
                .distinct()
                .sorted()
                .collect(Collectors.toList());
    }
}


---

ğŸ“Œ ê°œì„  ì‚¬í•­ ìš”ì•½

1. makeLogQueryString()

ê¸°ì¡´ ë¬¸ì œì :

if-elseì—ì„œ pod == null || pod.isEmpty()ë¥¼ ì²´í¬í•˜ëŠ” ë¶€ë¶„ì´ ì½”ë“œ ê°€ë…ì„±ì„ ì €í•˜ì‹œí‚´.

StringBuilder ëŒ€ì‹  String.format()ì„ í™œìš©í•  ìˆ˜ ìˆìŒ.


ê°œì„ :

String.format()ì„ ì‚¬ìš©í•˜ì—¬ ê°€ë…ì„±ì„ ê°œì„ .

time ê°’ì„ Integer.parseInt(time)ìœ¼ë¡œ ë³€í™˜ ì‹œ - ì—°ì‚°ì„ í™œìš©í•˜ì—¬ ì§ê´€ì ìœ¼ë¡œ ìˆ˜ì •.



2. getLetheLogData()

ê¸°ì¡´ ë¬¸ì œì :

HTTP_OKê°€ ì•„ë‹ ê²½ìš° ì•„ë¬´ëŸ° ì²˜ë¦¬ ì—†ì´ nullì„ ë°˜í™˜.


ê°œì„ :

IOExceptionì„ ë˜ì§€ë„ë¡ ìˆ˜ì •í•˜ì—¬ ì˜ˆì™¸ ìƒí™©ì„ ëª…í™•íˆ ì²˜ë¦¬.



3. retrieveRawJSON()

ê¸°ì¡´ ë¬¸ì œì :

StringBuffer ì‚¬ìš© (ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì´ ì•„ë‹ˆë¼ë©´ StringBuilderê°€ ë” ì ì ˆí•¨).


ê°œì„ :

Collectors.joining()ì„ í™œìš©í•˜ì—¬ ë” ê¹”ë”í•˜ê²Œ ë³€í™˜.



4. extractInformationFromRawJSON()

ê¸°ì¡´ ë¬¸ì œì :

JSON ë³€í™˜ ë¡œì§ì´ ë„ˆë¬´ ë³µì¡í•˜ì—¬ í•˜ë‚˜ì˜ ë©”ì†Œë“œì—ì„œ ë„ˆë¬´ ë§ì€ ì—­í• ì„ ë‹´ë‹¹.


ê°œì„ :

extractLogData() ë° extractPodList() ë©”ì†Œë“œë¡œ ë¶„ë¦¬í•˜ì—¬ ë‹¨ì¼ ì±…ì„ ì›ì¹™(SRP) ì ìš©.




---

ğŸ“Œ ê²°ë¡ 

ì´ ë¦¬íŒ©í† ë§ì„ í†µí•´ ì½”ë“œ ê°€ë…ì„±, ìœ ì§€ë³´ìˆ˜ì„±, ì˜ˆì™¸ ì²˜ë¦¬, ì¤‘ë³µ ì½”ë“œ ì œê±° ë“±ì„ ê°œì„ í–ˆìŠµë‹ˆë‹¤.
ì´ì œ ë” ì§ê´€ì ì´ê³  ìœ ì§€ë³´ìˆ˜í•˜ê¸° ì‰¬ìš´ ì½”ë“œ êµ¬ì¡°ë¥¼ ê°–ì¶”ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤! ğŸš€

