public void saveChunk(String fileId, int chunkIndex, byte[] chunkData) throws Exception {
    Path chunkDir = Paths.get("/tmp/chunks/" + fileId);
    if (!Files.exists(chunkDir)) {
        Files.createDirectories(chunkDir);
    }
    Path chunkFile = chunkDir.resolve("chunk_" + chunkIndex);
    Files.write(chunkFile, chunkData);
}

public FileDto.Response mergeChunksAndScan(String fileId, String fileName) throws Exception {
    Path chunkDir = Paths.get("/tmp/chunks/" + fileId);
    Path mergedFile = Paths.get("/tmp/" + fileName);

    try (FileOutputStream outputStream = new FileOutputStream(mergedFile.toFile())) {
        Files.list(chunkDir)
                .sorted()
                .forEach(chunk -> {
                    try {
                        Files.copy(chunk, outputStream);
                    } catch (Exception e) {
                        throw new RuntimeException("Failed to merge chunk: " + chunk.getFileName(), e);
                    }
                });
    }

    // 파일 스캔 수행
    Properties prop = new Properties();
    int ret = V3Scanner.scanFile(mergedFile.toString(), prop);
    return buildResponse(fileName, ret, prop);
}
