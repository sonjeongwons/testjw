리팩토링 및 클린 코드 적용을 통해 코드 품질을 향상시켰다. 주요 변경 사항과 개선 이유를 메서드 단위로 설명하겠다.


---

주요 개선 사항

1. IstioClient 관리 방식 변경

기존 코드에서 new DefaultIstioClient()를 직접 생성하여 사용했는데, 이 방식은 자원 누수(memory leak) 가능성이 있다.

IstioClient는 네트워크 연결을 다루므로 try-with-resources를 사용하여 안전하게 자원을 해제하도록 개선했다.



2. 중복 코드 제거 및 DRY 원칙 적용

makeIstioPolicy, enrollIstioToken, deleteIstioPolicy에서 AuthorizationPolicy 삭제 코드가 중복됨.

deleteIstioPolicy 기능을 별도 private 메서드로 분리하여 중복 제거 및 코드 가독성 향상.



3. 메서드 분리 (SRP 원칙 적용)

makeIstioPolicy와 enrollIstioToken 내에서 여러 책임을 수행하는 코드가 포함됨.

주요 로직을 별도 메서드로 분리하여 단일 책임 원칙(SRP, Single Responsibility Principle) 을 준수.



4. 매직 스트링 및 매직 넘버 제거

"istio-system", "serving.knative.dev/service" 등 하드코딩된 값들을 private static final String으로 선언하여 재사용성과 유지보수성 향상.





---

개선된 코드

package com.scf.manager.mvc.service;

import com.nimbusds.jwt.SignedJWT;
import io.fabric8.istio.api.security.v1beta1.*;
import io.fabric8.istio.api.type.v1beta1.WorkloadSelectorBuilder;
import io.fabric8.istio.client.DefaultIstioClient;
import io.fabric8.istio.client.IstioClient;
import io.fabric8.kubernetes.client.dsl.base.PatchContext;
import io.fabric8.kubernetes.client.dsl.base.PatchType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Slf4j
@Service
public class IstioCallService {
    private static final String ISTIO_SYSTEM_NAMESPACE = "istio-system";
    private static final String KNATIVE_SERVICE_LABEL = "serving.knative.dev/service";
    private static final String ISTIO_INGRESS_LABEL = "istio";
    private static final String ISSUER_URL = "https://scp.com";

    public void makeIstioPolicy(String functionName, List<String> ipAddress) {
        List<Condition> conditions = createRemoteIpConditions(functionName, ipAddress);

        try (IstioClient istioClient = new DefaultIstioClient()) {
            AuthorizationPolicy policy = createAuthorizationPolicy(functionName, conditions);
            applyAuthorizationPolicy(istioClient, ISTIO_SYSTEM_NAMESPACE, policy);
        }
    }

    private List<Condition> createRemoteIpConditions(String functionName, List<String> ipAddress) {
        List<Condition> conditions = new ArrayList<>();
        conditions.add(new ConditionBuilder().withKey("request.headers[Host]").withValues(functionName + "*").build());

        if (!CollectionUtils.isEmpty(ipAddress)) {
            conditions.add(new ConditionBuilder().withKey("remote.ip").withNotValues(ipAddress).build());
        }

        return conditions;
    }

    private AuthorizationPolicy createAuthorizationPolicy(String functionName, List<Condition> conditions) {
        return new AuthorizationPolicyBuilder()
                .withNewMetadata().withName(functionName).withNamespace(ISTIO_SYSTEM_NAMESPACE).endMetadata()
                .withNewSpec()
                .withSelector(new WorkloadSelectorBuilder().withMatchLabels(Collections.singletonMap(ISTIO_INGRESS_LABEL, "ingressgateway")).build())
                .withAction(AuthorizationPolicyAction.DENY)
                .withRules(new RuleBuilder().withWhen(conditions).build())
                .endSpec()
                .build();
    }

    public void enrollIstioToken(String functionName, String jwk) {
        try (IstioClient istioClient = new DefaultIstioClient()) {
            RequestAuthentication auth = createRequestAuthentication(functionName, jwk);
            applyRequestAuthentication(istioClient, functionName, auth);

            AuthorizationPolicy healthPolicy = createHealthCheckPolicy(functionName);
            applyAuthorizationPolicy(istioClient, functionName, healthPolicy);
        }
    }

    private RequestAuthentication createRequestAuthentication(String functionName, String jwk) {
        JWTRule jwtRule = new JWTRule();
        jwtRule.setIssuer(ISSUER_URL);
        jwtRule.setJwks(jwk);

        return new RequestAuthenticationBuilder()
                .withNewMetadata().withName(functionName).withNamespace(functionName).endMetadata()
                .withNewSpec()
                .withSelector(new WorkloadSelectorBuilder().withMatchLabels(Collections.singletonMap(KNATIVE_SERVICE_LABEL, functionName)).build())
                .withJwtRules(jwtRule)
                .endSpec()
                .build();
    }

    private AuthorizationPolicy createHealthCheckPolicy(String functionName) {
        return new AuthorizationPolicyBuilder()
                .withNewMetadata().withName(functionName).withNamespace(functionName).endMetadata()
                .withNewSpec()
                .withSelector(new WorkloadSelectorBuilder().withMatchLabels(Collections.singletonMap(KNATIVE_SERVICE_LABEL, functionName)).build())
                .withRules(
                        new RuleBuilder().withFrom(new RuleFromBuilder().withSource(new SourceBuilder().withRequestPrincipals("*").build()).build()).build(),
                        new RuleBuilder()
                                .withTo(
                                        new RuleToBuilder().withOperation(new OperationBuilder().withPaths("/healthz").build()).build(),
                                        new RuleToBuilder().withOperation(new OperationBuilder().withPaths("/metrics").build()).build()
                                )
                                .build()
                )
                .endSpec()
                .build();
    }

    private void applyAuthorizationPolicy(IstioClient istioClient, String namespace, AuthorizationPolicy policy) {
        deleteIstioPolicy(istioClient, namespace, policy.getMetadata().getName());
        istioClient.v1beta1().authorizationPolicies().inNamespace(namespace)
                .withName(policy.getMetadata().getName())
                .patch(PatchContext.of(PatchType.SERVER_SIDE_APPLY), policy);
    }

    private void applyRequestAuthentication(IstioClient istioClient, String namespace, RequestAuthentication auth) {
        deleteRequestAuthentication(istioClient, namespace, auth.getMetadata().getName());
        istioClient.v1beta1().requestAuthentications().inNamespace(namespace)
                .withName(auth.getMetadata().getName())
                .patch(PatchContext.of(PatchType.SERVER_SIDE_APPLY), auth);
    }

    public void deleteIstioPolicy(String functionName) {
        try (IstioClient istioClient = new DefaultIstioClient()) {
            deleteIstioPolicy(istioClient, ISTIO_SYSTEM_NAMESPACE, functionName);
            deleteIstioPolicy(istioClient, functionName, functionName);
            deleteRequestAuthentication(istioClient, functionName, functionName);
        }
    }

    private void deleteIstioPolicy(IstioClient istioClient, String namespace, String policyName) {
        istioClient.v1beta1().authorizationPolicies().inNamespace(namespace).withName(policyName).delete();
    }

    private void deleteRequestAuthentication(IstioClient istioClient, String namespace, String authName) {
        istioClient.v1beta1().requestAuthentications().inNamespace(namespace).withName(authName).delete();
    }
}


---

개선 사항 정리

1. IstioClient 안전한 사용

try-with-resources를 활용하여 자원 해제를 자동으로 처리하여 메모리 누수 방지.



2. 중복 코드 제거 및 메서드 분리

deleteIstioPolicy, deleteRequestAuthentication 메서드를 별도로 분리하여 deleteIstioPolicy() 내부에서 재사용.

applyAuthorizationPolicy, applyRequestAuthentication 메서드 추가 → 코드 중복 제거.



3. 매직 스트링/매직 넘버 제거

"istio-system", "serving.knative.dev/service" 등의 하드코딩된 값들을 private static final String 상수로 관리.



4. 단일 책임 원칙(SRP) 적용

createRemoteIpConditions, createRequestAuthentication, createHealthCheckPolicy 등 로직 분리 → 가독성 향상.





---

이제 유지보수성이 뛰어나고, 클린 코드 원칙을 준수하는 코드가 되었다.
추가적으로 개선할 점이나 궁금한 사항이 있으면 질문해줘!

