리팩토링 및 클린 코드 적용을 통해 코드 품질을 향상시켰다. 주요 변경 사항과 개선 이유를 메서드 단위로 설명하겠다.


---

주요 개선 사항

1. IstioClient 관리 방식 변경

기존 코드에서 new DefaultIstioClient()를 직접 생성하여 사용했는데, 이 방식은 자원 누수(memory leak) 가능성이 있다.

IstioClient는 네트워크 연결을 다루므로 try-with-resources를 사용하여 안전하게 자원을 해제하도록 개선했다.



2. 중복 코드 제거 및 DRY 원칙 적용

makeIstioPolicy, enrollIstioToken, deleteIstioPolicy에서 AuthorizationPolicy 삭제 코드가 중복됨.

deleteIstioPolicy 기능을 별도 private 메서드로 분리하여 중복 제거 및 코드 가독성 향상.



3. 메서드 분리 (SRP 원칙 적용)

makeIstioPolicy와 enrollIstioToken 내에서 여러 책임을 수행하는 코드가 포함됨.

주요 로직을 별도 메서드로 분리하여 단일 책임 원칙(SRP, Single Responsibility Principle) 을 준수.



4. 매직 스트링 및 매직 넘버 제거

"istio-system", "serving.knative.dev/service" 등 하드코딩된 값들을 private static final String으로 선언하여 재사용성과 유지보수성 향상.





---

개선된 코드

package com.scf.manager.mvc.service;

import com.nimbusds.jwt.SignedJWT;
import io.fabric8.istio.api.security.v1beta1.*;
import io.fabric8.istio.api.type.v1beta1.WorkloadSelectorBuilder;
import io.fabric8.istio.client.DefaultIstioClient;
import io.fabric8.istio.client.IstioClient;
import io.fabric8.kubernetes.client.dsl.base.PatchContext;
import io.fabric8.kubernetes.client.dsl.base.PatchType;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

@Slf4j
@Service
public class IstioCallService {
    private static final String ISTIO_SYSTEM_NAMESPACE = "istio-system";
    private static final String KNATIVE_SERVICE_LABEL = "serving.knative.dev/service";
    private static final String ISTIO_INGRESS_LABEL = "istio";
    private static final String ISSUER_URL = "https://scp.com";

    public void makeIstioPolicy(String functionName, List<String> ipAddress) {
        List<Condition> conditions = createRemoteIpConditions(functionName, ipAddress);

        try (IstioClient istioClient = new DefaultIstioClient()) {
            AuthorizationPolicy policy = createAuthorizationPolicy(functionName, conditions);
            applyAuthorizationPolicy(istioClient, ISTIO_SYSTEM_NAMESPACE, policy);
        }
    }

    private List<Condition> createRemoteIpConditions(String functionName, List<String> ipAddress) {
        List<Condition> conditions = new ArrayList<>();
        conditions.add(new ConditionBuilder().withKey("request.headers[Host]").withValues(functionName + "*").build());

        if (!CollectionUtils.isEmpty(ipAddress)) {
            conditions.add(new ConditionBuilder().withKey("remote.ip").withNotValues(ipAddress).build());
        }

        return conditions;
    }

    private AuthorizationPolicy createAuthorizationPolicy(String functionName, List<Condition> conditions) {
        return new AuthorizationPolicyBuilder()
                .withNewMetadata().withName(functionName).withNamespace(ISTIO_SYSTEM_NAMESPACE).endMetadata()
                .withNewSpec()
                .withSelector(new WorkloadSelectorBuilder().withMatchLabels(Collections.singletonMap(ISTIO_INGRESS_LABEL, "ingressgateway")).build())
                .withAction(AuthorizationPolicyAction.DENY)
                .withRules(new RuleBuilder().withWhen(conditions).build())
                .endSpec()
                .build();
    }

    public void enrollIstioToken(String functionName, String jwk) {
        try (IstioClient istioClient = new DefaultIstioClient()) {
            RequestAuthentication auth = createRequestAuthentication(functionName, jwk);
            applyRequestAuthentication(istioClient, functionName, auth);

            AuthorizationPolicy healthPolicy = createHealthCheckPolicy(functionName);
            applyAuthorizationPolicy(istioClient, functionName, healthPolicy);
        }
    }

    private RequestAuthentication createRequestAuthentication(String functionName, String jwk) {
        JWTRule jwtRule = new JWTRule();
        jwtRule.setIssuer(ISSUER_URL);
        jwtRule.setJwks(jwk);

        return new RequestAuthenticationBuilder()
                .withNewMetadata().withName(functionName).withNamespace(functionName).endMetadata()
                .withNewSpec()
                .withSelector(new WorkloadSelectorBuilder().withMatchLabels(Collections.singletonMap(KNATIVE_SERVICE_LABEL, functionName)).build())
                .withJwtRules(jwtRule)
                .endSpec()
                .build();
    }

    private AuthorizationPolicy createHealthCheckPolicy(String functionName) {
        return new AuthorizationPolicyBuilder()
                .withNewMetadata().withName(functionName).withNamespace(functionName).endMetadata()
                .withNewSpec()
                .withSelector(new WorkloadSelectorBuilder().withMatchLabels(Collections.singletonMap(KNATIVE_SERVICE_LABEL, functionName)).build())
                .withRules(
                        new RuleBuilder().withFrom(new RuleFromBuilder().withSource(new SourceBuilder().withRequestPrincipals("*").build()).build()).build(),
                        new RuleBuilder()
                                .withTo(
                                        new RuleToBuilder().withOperation(new OperationBuilder().withPaths("/healthz").build()).build(),
                                        new RuleToBuilder().withOperation(new OperationBuilder().withPaths("/metrics").build()).build()
                                )
                                .build()
                )
                .endSpec()
                .build();
    }

    private void applyAuthorizationPolicy(IstioClient istioClient, String namespace, AuthorizationPolicy policy) {
        deleteIstioPolicy(istioClient, namespace, policy.getMetadata().getName());
        istioClient.v1beta1().authorizationPolicies().inNamespace(namespace)
                .withName(policy.getMetadata().getName())
                .patch(PatchContext.of(PatchType.SERVER_SIDE_APPLY), policy);
    }

    private void applyRequestAuthentication(IstioClient istioClient, String namespace, RequestAuthentication auth) {
        deleteRequestAuthentication(istioClient, namespace, auth.getMetadata().getName());
        istioClient.v1beta1().requestAuthentications().inNamespace(namespace)
                .withName(auth.getMetadata().getName())
                .patch(PatchContext.of(PatchType.SERVER_SIDE_APPLY), auth);
    }

    public void deleteIstioPolicy(String functionName) {
        try (IstioClient istioClient = new DefaultIstioClient()) {
            deleteIstioPolicy(istioClient, ISTIO_SYSTEM_NAMESPACE, functionName);
            deleteIstioPolicy(istioClient, functionName, functionName);
            deleteRequestAuthentication(istioClient, functionName, functionName);
        }
    }

    private void deleteIstioPolicy(IstioClient istioClient, String namespace, String policyName) {
        istioClient.v1beta1().authorizationPolicies().inNamespace(namespace).withName(policyName).delete();
    }

    private void deleteRequestAuthentication(IstioClient istioClient, String namespace, String authName) {
        istioClient.v1beta1().requestAuthentications().inNamespace(namespace).withName(authName).delete();
    }
}


---

개선 사항 정리

1. IstioClient 안전한 사용

try-with-resources를 활용하여 자원 해제를 자동으로 처리하여 메모리 누수 방지.



2. 중복 코드 제거 및 메서드 분리

deleteIstioPolicy, deleteRequestAuthentication 메서드를 별도로 분리하여 deleteIstioPolicy() 내부에서 재사용.

applyAuthorizationPolicy, applyRequestAuthentication 메서드 추가 → 코드 중복 제거.



3. 매직 스트링/매직 넘버 제거

"istio-system", "serving.knative.dev/service" 등의 하드코딩된 값들을 private static final String 상수로 관리.



4. 단일 책임 원칙(SRP) 적용

createRemoteIpConditions, createRequestAuthentication, createHealthCheckPolicy 등 로직 분리 → 가독성 향상.





---

이제 유지보수성이 뛰어나고, 클린 코드 원칙을 준수하는 코드가 되었다.
추가적으로 개선할 점이나 궁금한 사항이 있으면 질문해줘!




각 메서드별로 어떤 점이 변경되었고, 어떻게 코드 품질을 개선했는지 자세히 설명하겠다.


---

1. makeIstioPolicy(String functionName, List<String> ipAddress)

변경점

리소스 누수를 방지하기 위해 try-with-resources를 사용하여 IstioClient를 안전하게 관리.

createRemoteIpConditions(functionName, ipAddress) 메서드를 분리하여 조건 리스트 생성 책임을 분리.

createAuthorizationPolicy(functionName, conditions) 메서드를 분리하여 AuthorizationPolicy 생성 책임을 분리.

applyAuthorizationPolicy(istioClient, ISTIO_SYSTEM_NAMESPACE, policy)를 사용하여 중복된 코드 제거.


개선 이유

가독성 향상: 로직이 간결해져 함수의 역할을 명확하게 파악할 수 있다.

단일 책임 원칙(SRP) 준수: 조건 생성, AuthorizationPolicy 생성, 적용을 각각 별도의 메서드로 분리하여 단일 책임을 유지.

중복 코드 제거: IstioClient 생성 및 적용 로직을 재사용하여 코드 중복을 최소화.



---

2. createRemoteIpConditions(String functionName, List<String> ipAddress)

변경점

makeIstioPolicy 내에서 직접 List<Condition>을 생성하던 부분을 별도의 메서드로 분리.


개선 이유

재사용 가능: 동일한 조건이 다른 곳에서도 사용될 가능성이 있으므로 별도 메서드로 관리.

가독성 향상: makeIstioPolicy 내에서 로직이 단순해지고 역할이 명확해짐.



---

3. createAuthorizationPolicy(String functionName, List<Condition> conditions)

변경점

AuthorizationPolicy를 직접 생성하던 부분을 별도의 메서드로 분리.


개선 이유

책임 분리: makeIstioPolicy 메서드에서 AuthorizationPolicy를 만드는 로직을 분리하여 단일 책임 원칙을 적용.

재사용성 증가: 같은 구조의 정책을 필요로 하는 경우 쉽게 재사용할 수 있음.

가독성 향상: makeIstioPolicy가 짧고 명확해짐.



---

4. enrollIstioToken(String functionName, String jwk)

변경점

jwt 파라미터 제거 (사용되지 않음).

try-with-resources를 사용하여 IstioClient를 안전하게 해제.

JWT 인증 설정을 createRequestAuthentication(functionName, jwk)로 분리.

/healthz, /metrics 접근을 허용하는 정책을 createHealthCheckPolicy(functionName)로 분리.

정책을 적용하는 코드 중복을 줄이기 위해 applyAuthorizationPolicy()와 applyRequestAuthentication() 사용.


개선 이유

단일 책임 원칙(SRP) 준수: JWT 인증 설정과 AuthorizationPolicy 적용 로직을 분리하여 책임을 명확하게 함.

코드 중복 제거: IstioClient를 사용하는 패턴을 통일하여 유지보수성을 높임.

가독성 향상: enrollIstioToken의 역할이 명확해지고, JWT 관련 로직이 집중됨.



---

5. createRequestAuthentication(String functionName, String jwk)

변경점

RequestAuthentication 객체를 생성하는 부분을 별도 메서드로 분리.


개선 이유

단일 책임 원칙(SRP) 준수: JWT 인증 관련 로직을 enrollIstioToken에서 분리하여 책임을 명확히 함.

재사용 가능: 같은 방식으로 다른 서비스에도 RequestAuthentication을 적용할 경우 쉽게 재사용 가능.

가독성 향상: enrollIstioToken이 더 직관적으로 이해될 수 있도록 개선.



---

6. createHealthCheckPolicy(String functionName)

변경점

/healthz와 /metrics를 허용하는 AuthorizationPolicy를 생성하는 로직을 별도 메서드로 분리.


개선 이유

단일 책임 원칙(SRP) 준수: enrollIstioToken에서 불필요한 세부 로직이 제거되어 역할이 명확해짐.

가독성 향상: enrollIstioToken 내에서 정책 생성 부분이 사라지고, 더 명확한 흐름을 갖게 됨.



---

7. applyAuthorizationPolicy(IstioClient istioClient, String namespace, AuthorizationPolicy policy)

변경점

istioClient를 사용하여 AuthorizationPolicy를 적용하는 공통 메서드로 분리.


개선 이유

중복 코드 제거: 기존에 여러 곳에서 AuthorizationPolicy를 삭제 후 생성하는 패턴을 공통 메서드로 관리.

가독성 향상: 정책 적용 로직이 한 곳에서 관리되므로, makeIstioPolicy와 enrollIstioToken이 더 직관적으로 보인다.



---

8. applyRequestAuthentication(IstioClient istioClient, String namespace, RequestAuthentication auth)

변경점

istioClient를 사용하여 RequestAuthentication을 적용하는 공통 메서드로 분리.


개선 이유

중복 코드 제거: enrollIstioToken 내에서 직접 처리하던 부분을 별도 메서드로 분리하여 재사용성 증가.

책임 분리: JWT 인증과 AuthorizationPolicy를 구분하여 관리.



---

9. deleteIstioPolicy(String functionName)

변경점

try-with-resources를 사용하여 IstioClient의 자원 관리를 안전하게 수행.

deleteIstioPolicy(istioClient, namespace, policyName)와 deleteRequestAuthentication(istioClient, namespace, authName)을 사용하여 코드 중복 제거.


개선 이유

자원 누수 방지: IstioClient를 안전하게 관리.

중복 코드 제거: 정책 삭제 로직을 별도 메서드로 분리하여 makeIstioPolicy와 enrollIstioToken에서도 재사용 가능.



---

10. deleteIstioPolicy(IstioClient istioClient, String namespace, String policyName)

변경점

AuthorizationPolicy 삭제 기능을 별도 메서드로 분리.


개선 이유

재사용성 증가: 여러 곳에서 AuthorizationPolicy를 삭제할 때 같은 코드가 반복되지 않도록 개선.

책임 분리: deleteIstioPolicy에서 불필요한 반복 로직을 제거.



---

11. deleteRequestAuthentication(IstioClient istioClient, String namespace, String authName)

변경점

RequestAuthentication 삭제 기능을 별도 메서드로 분리.


개선 이유

재사용성 증가: JWT 인증을 삭제하는 기능을 enrollIstioToken과 deleteIstioPolicy에서 공유.

가독성 향상: deleteIstioPolicy 내에서 삭제 로직이 간결해지고 직관적으로 보이도록 개선.



---

결론: 리팩토링 후 개선된 점

✅ 메모리 누수 방지 → try-with-resources를 사용하여 IstioClient를 안전하게 관리.
✅ 중복 코드 제거 → 공통 기능을 별도 메서드로 분리하여 재사용성을 높임.
✅ 단일 책임 원칙(SRP) 준수 → 각 메서드가 하나의 책임만 가지도록 역할을 분리.
✅ 가독성 향상 → 메서드 크기를 줄이고, 더 직관적인 코드 구조로 개선.
✅ 유지보수 용이 → 정책 생성, 적용, 삭제 로직이 분리되어 관리가 쉬워짐.

이제 코드가 더 직관적이고 유지보수하기 쉬운 형태가 되었어. 추가적인 개선이 필요하면 알려줘!

