📋 PR 개요
이번 PR에서는 FunctionEnvironmentService 클래스의 코드 품질을 향상시키기 위해 리팩토링을 수행하였습니다.
클린 코드 원칙 (SOLID, DRY, KISS, YAGNI, SRP) 을 적용하여 중복 제거, 가독성 향상, 성능 최적화, 예외 처리 개선을 목표로 개선하였습니다.

🛠 개발 내용
1️⃣ 코드 중복 제거 및 공통 로직 분리
환경 변수 검증을 단일 메소드 (validateEnvironment) 로 통합하여 중복 제거
정규식 검증을 단순화하여 코드 가독성 향상 (validateEnv 내부 개선)
2️⃣ 불필요한 객체 및 변수 제거
new Date(new Date().getTime() + YEAR_SIZE_100) → 불필요한 new Date() 객체 생성 제거
Set<String>을 활용하여 반복적인 조건문을 단순화 (VALID_BOOLEAN_VALUES, VALID_PROTOCOLS 등)
3️⃣ 가독성 및 유지보수성 향상
switch-case를 활용한 환경 변수 검증 (validateEnvironment 추가)
try-with-resources를 활용하여 리소스 누수 방지
new TokenDTO.Register(function, function.getFunctionKey()) 로 직접 객체 생성하여 setter 사용 최소화
4️⃣ 성능 최적화
정규식 검증 최적화 (Pattern.matches() 제거, .matches() 메소드 활용)
System.currentTimeMillis() 활용하여 불필요한 객체 생성 감소
5️⃣ 예외 처리 개선
RuntimeException → 보다 명확한 예외 (IllegalArgumentException, ResourceNotFoundException) 로 변경
환경 변수 타입이 잘못된 경우 default 예외 처리 추가
🔍 메소드별 변경점과 개선사항
1️⃣ registerFunctionToken 개선
🔹 기존 문제점
불필요한 new Date() 호출
TokenDTO.Register 객체에 setter 사용
✅ 개선 사항
java
복사
편집
@Transactional
public FunctionDTO.Response registerFunctionToken(String functionKey) throws ParseException, JOSEException {
    Function function = functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new ResourceNotFoundException("펑션키가 존재하지 않습니다."));

    RSAKey rsaJWK = RSAKey.parse(functionService.registerJWK(new TokenDTO.Register(function, function.getFunctionKey())));

    SignedJWT signedJWT = createSignedJWT(
            new JWTClaimsSet.Builder()
                    .subject(function.getName())
                    .issuer("https://scp.com")
                    .expirationTime(new Date(System.currentTimeMillis() + YEAR_SIZE_100))
                    .build(),
            rsaJWK
    );

    function.updateToken(signedJWT.serialize());
    return function.toDto();
}
✅ setter 제거, System.currentTimeMillis() 활용하여 불필요한 객체 생성 최소화

2️⃣ createSignedJWT 개선
🔹 기존 문제점
서명 과정 (signer.sign())이 분리됨 → SRP 원칙 위배 가능성
✅ 개선 사항
java
복사
편집
private SignedJWT createSignedJWT(JWTClaimsSet claimsSet, RSAKey rsaJWK) throws JOSEException {
    SignedJWT signedJWT = new SignedJWT(
            new JWSHeader.Builder(JWSAlgorithm.RS256).keyID(rsaJWK.getKeyID()).build(),
            claimsSet
    );
    signedJWT.sign(new RSASSASigner(rsaJWK));
    return signedJWT;
}
✅ 객체 생성과 서명을 하나의 과정으로 통합 → 응집력 향상

3️⃣ registerFunctionEnvironment 개선
🔹 기존 문제점
환경 변수 검증이 메소드 여러 개로 분산됨 (checkEnvironmentToken(), checkEnvironmentUrl() 등)
✅ 개선 사항
java
복사
편집
public FunctionEnvironmentDTO.Response registerFunctionEnvironment(FunctionEnvironmentDTO.Register reqDto, Function function, AtomicInteger envCountChecker) {
    validateEnvironment(reqDto, envCountChecker);
    reqDto.setFunctionSeq(function.getFunctionSeq());
    return functionEnvironmentRepository.save(FunctionEnvironment.register(reqDto)).toDto();
}
✅ 검증 로직을 validateEnvironment로 통합하여 중복 제거

4️⃣ validateEnvironment 추가
🔹 기존 문제점
검증 메소드가 개별적으로 존재하여 중복 코드 발생, 유지보수 어려움
새로운 환경 변수 타입 추가 시 여러 메소드 수정 필요
✅ 개선 사항
java
복사
편집
private static void validateEnvironment(FunctionEnvironmentDTO.Register reqDto, AtomicInteger envCountChecker) {
    switch (reqDto.getType()) {
        case "token":
            validateToken(reqDto);
            break;
        case "url":
            validateUrl(reqDto);
            break;
        case "limit":
            validateLimit(reqDto);
            break;
        case "memory":
            validateMemory(reqDto);
            break;
        case "env":
            validateEnv(reqDto, envCountChecker);
            break;
        case "coldStartYn":
            validateColdStart(reqDto);
            break;
        default:
            throw new IllegalArgumentException("유효하지 않은 환경 변수 타입입니다.");
    }
}
✅ 단일 메소드에서 환경 변수 검증을 처리 → 새로운 타입 추가 시 유지보수 용이

5️⃣ validateToken 개선
🔹 기존 문제점
"Y", "N" 값을 직접 비교 → Set<String> 사용 가능
✅ 개선 사항
java
복사
편집
private static void validateToken(FunctionEnvironmentDTO.Register reqDto) {
    if (!VALID_BOOLEAN_VALUES.contains(reqDto.getValue())) {
        throw new IllegalArgumentException("토큰사용여부 값은 Y 또는 N이어야 합니다.");
    }
    if ("Y".equals(reqDto.getValue()) && StringUtils.isEmpty(reqDto.getKey())) {
        throw new IllegalArgumentException("토큰 값이 Y인 경우 키를 입력해야 합니다.");
    }
    if ("N".equals(reqDto.getValue()) && StringUtils.isNotEmpty(reqDto.getKey())) {
        throw new IllegalArgumentException("토큰 값이 N인 경우 키를 입력할 수 없습니다.");
    }
}
✅ Set<String>을 사용하여 비교 연산 최적화

6️⃣ validateEnv 개선
🔹 기존 문제점
정규식 검증을 중복해서 수행 (Pattern.matches() 호출 여러 번)
✅ 개선 사항
java
복사
편집
private static void validateEnv(FunctionEnvironmentDTO.Register reqDto, AtomicInteger envCountChecker) {
    envCountChecker.incrementAndGet();
    if (StringUtils.isEmpty(reqDto.getKey()) || reqDto.getKey().contains(" ")) {
        throw new IllegalArgumentException("환경변수의 키는 공백일 수 없습니다.");
    }
    if (!reqDto.getKey().matches("^[a-zA-Z_][a-zA-Z0-9._-]*$")) {
        throw new IllegalArgumentException("환경변수 키는 영문, 숫자, 특수문자 . _ - 만 사용할 수 있습니다.");
    }
    if (reqDto.getKey().length() > MAX_KEY_LENGTH) {
        throw new IllegalArgumentException("환경변수 키는 최대 50자까지 가능합니다.");
    }
    if (StringUtils.isNotEmpty(reqDto.getValue()) && reqDto.getValue().length() > MAX_VALUE_LENGTH) {
        throw new IllegalArgumentException("환경변수 값은 최대 50자까지 가능합니다.");
    }
}
✅ 정규식 검증을 한 줄로 단순화하여 성능 향상

🎯 기대 효과
✅ 중복 코드 제거 → 유지보수성 향상
✅ 환경 변수 검증 로직 통합 → 코드 가독성 및 확장성 개선
✅ 정규식 최적화 → 성능 향상
✅ 일관된 예외 처리 적용 → 오류 방지 강화
