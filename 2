package com.scf.manager.mvc.service;


import com.google.gson.Gson;
import com.scf.manager.mvc.domain.Function;
import com.scf.manager.mvc.dto.*;
import com.scf.manager.mvc.repository.FunctionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.json.JSONObject;
import org.springframework.beans.factory.annotation.Value;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class FunctionMetricService {

    @Value("${monitoring.http.timeout}")
    private int timeOutValue;

    public static final String METRIC_TIME_RANGE_1_HOUR = "1";
    public static final String METRIC_TIME_RANGE_3_HOUR = "3";
    public static final String METRIC_TIME_RANGE_12_HOUR = "12";

    public static final String METRIC_TIME_UNIT_15M = "15";
    public static final String METRIC_TIME_UNIT_30M = "30";
    public static final String METRIC_TIME_UNIT_180M = "180";
    public static final String METRIC_TIME_UNIT_1440M = "1440";

    @Value("${monitoring.prometheus.prometheusHttpApi}")
    private String prometheusHttpApi;

    private final FunctionRepository functionRepository;
    private class MetricRequest{
        URL url;
        String functionName;
        String queryTiming;
        Gson g;
        List<FunctionMetricElementsListDTO> requestCountList;
        List<FunctionMetricElementsListDTO> requestLatencyList;
        List<FunctionMetricElementsListDTO> functionMemoryList;
        List<FunctionMetricElementsListDTO> actualPodsList;
        List<FunctionMetricElementsListDTO> successCountList;
        List<FunctionMetricElementsListDTO> failCountList;
        String timeRange;
    }

    // Text Block으로 만들어진 String의 개행문자, 탭, 공백제거하여 실제 쿼리문을 생성함.
    // 가독성을 위하여 기존 +로 더하던 방식을, Text Block에서 $변수$를 마지막에 치환해주는 방식으로 변경
    // 추후 성능상 이슈가 발생시 해당 부분을 최적화할 필요가 있음.
    private String replaceNextlineTabBlank(String qs){
        return qs.replace("\n","").replace("\t","").replace(" ", "");
    }

    // 호출수 쿼리
    public String generateQueryForRequestCount(String functionName, String timeRange, String queryTiming) {
        String qs = """
                        query=
                        sum(rate(activator_request_count{service_name="$functionName$"}[$timeRange$m]))
                        *60
                        *$timeRange$
                        &time=$queryTiming$
                        """;

        return this.replaceNextlineTabBlank(qs)
                .replace("$functionName$",functionName)
                .replace("$timeRange$", timeRange)
                .replace("$queryTiming$", queryTiming);
    }
    // 실행시간 쿼리
    public String generateQueryForRequestLatency(String functionName, String timeRange, String queryTiming){
        String qs = """
                        query=  (
                                    sum(rate(activator_request_latencies_sum{service_name="$functionName$",response_code="200"}[$timeRange$m]))
                                    / sum(rate(activator_request_latencies_count{service_name="$functionName$",response_code="200"}[$timeRange$m]))
                                )
                                /1000
                                &time=$queryTiming$
                        """;

        return this.replaceNextlineTabBlank(qs)
                .replace("$functionName$",functionName)
                .replace("$timeRange$", timeRange)
                .replace("$queryTiming$", queryTiming);
    }
    // 메모리 사용량 쿼리
    public String generateQueryForFunctionMemory(String functionName, String timeRange, String queryTiming) {
        String qs = """
                    query=
                    avg(avg_over_time(container_memory_working_set_bytes{pod=~"$functionName$-.*", container="user-container"}[$timeRange$m]))
                    /1024
                    &time=$queryTiming$
                    """;

        return this.replaceNextlineTabBlank(qs)
                .replace("$functionName$",functionName)
                .replace("$timeRange$", timeRange)
                .replace("$queryTiming$", queryTiming);
    }
    // 현재 작업수 쿼리
    public String generateQueryForActualPods(String functionName, String timeRange, String queryTiming) {
        String qs = """
                    query=
                    autoscaler_actual_pods{service_name="$functionName$"}
                    &time=$queryTiming$
                    """;

        return this.replaceNextlineTabBlank(qs)
                .replace("$functionName$",functionName)
                .replace("$timeRange$", timeRange)
                .replace("$queryTiming$", queryTiming);
    }
    // 성공 호출수 쿼리
    public String generateQueryForSuccessCount(String functionName, String timeRange, String queryTiming) {
        String qs ="""
                    query=
                    sum(rate(activator_request_count{response_code="200",service_name="$functionName$"}[$timeRange$m]))
                    *60
                    *$timeRange$
                    &time=$queryTiming$
                    """;

        return this.replaceNextlineTabBlank(qs)
                .replace("$functionName$",functionName)
                .replace("$timeRange$", timeRange)
                .replace("$queryTiming$", queryTiming);
    }
    // 실패 호출수 쿼리
    public String generateQueryForFailCount(String functionName, String timeRange, String queryTiming) {
        String qs = """
                    query=
                    sum(rate(activator_request_count{response_code="500",service_name="$functionName$"}[$timeRange$m]))
                    *60
                    *$timeRange$
                    &time=$queryTiming$
                    """;
        
        return this.replaceNextlineTabBlank(qs)
                .replace("$functionName$",functionName)
                .replace("$timeRange$", timeRange)
                .replace("$queryTiming$", queryTiming);
    }

    public FunctionMetricListDTO getMetricList(String functionKey, String time, String start, String end) throws IOException, ParseException {
        URL url = new URL(prometheusHttpApi);

        Function function = functionRepository.findByFunctionKey(functionKey).orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
        String functionName = function.getName();
        FunctionMetricListDTO response = new FunctionMetricListDTO();
        Calendar cal = Calendar.getInstance();
        MetricRequest metricRequest = new MetricRequest();

        metricRequest.url=url;
        metricRequest.functionName=functionName;
        metricRequest.queryTiming="";
        metricRequest.g= new Gson();
        metricRequest.requestCountList = new ArrayList<>();
        metricRequest.requestLatencyList = new ArrayList<>();
        metricRequest.functionMemoryList = new ArrayList<>();
        metricRequest.actualPodsList = new ArrayList<>();
        metricRequest.successCountList = new ArrayList<>();
        metricRequest.failCountList = new ArrayList<>();


        if(METRIC_TIME_RANGE_1_HOUR.equals(time)){ //1시간 15분 단위 4개
            metricRequest.timeRange=METRIC_TIME_UNIT_15M;
            getEachMetricInstance(metricRequest);

            for (int i=0; i<3; i++){
                cal.add(Calendar.MINUTE, -15);
                metricRequest.queryTiming=String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetricInstance(metricRequest);
            }
        } else if (METRIC_TIME_RANGE_3_HOUR.equals(time)) { //3시간 30분 단위 6개
            metricRequest.timeRange=METRIC_TIME_UNIT_30M;
            getEachMetricInstance(metricRequest);
            for (int i=0; i<5; i++){
                cal.add(Calendar.MINUTE, -30);
                metricRequest.queryTiming=String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetricInstance(metricRequest);
            }
        } else if (METRIC_TIME_RANGE_12_HOUR.equals(time)) { //12시간 3시간 단위 4개
            metricRequest.timeRange=METRIC_TIME_UNIT_180M;
            getEachMetricInstance(metricRequest);
            for (int i=0; i<3; i++){
                cal.add(Calendar.MINUTE, -180);
                metricRequest.queryTiming=String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetricInstance(metricRequest);
            }
        } else { //사용자 지정 기간 1일 단위 날짜수 ex)1101 ~ 1103 이면 3일치
            SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
            Date startDate = format.parse(start);
            long startDateLong = startDate.getTime() / 1000L;
            //종료 일자
            Date endDate = format.parse(end);
            long endDateLong = endDate.getTime() / 1000L;
            //종료-시작 일수 차이
            int dateDiffer = (int) ((endDateLong-startDateLong) / (24*60*60));

            cal.setTime(endDate);
            cal.add(Calendar.MINUTE, 720);
            metricRequest.timeRange=METRIC_TIME_UNIT_1440M;
            getEachMetricInstance(metricRequest);

            for (int i=0; i<dateDiffer; i++){
                cal.add(Calendar.MINUTE, -1440);
                metricRequest.queryTiming=String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);
                getEachMetricInstance(metricRequest);
            }
        }

        for(FunctionMetricElementsListDTO element : metricRequest.requestLatencyList) {
            RequestLatencyMetricInvalidValueHandling(element);
        }

        response.setRequestCount(metricRequest.requestCountList);
        response.setRequestLatency(metricRequest.requestLatencyList);
        response.setFunctionMemory(metricRequest.functionMemoryList);

        response.setActualPods(metricRequest.actualPodsList);
        response.setSuccessCount(metricRequest.successCountList);
        response.setFailCount(metricRequest.failCountList);

        return response;
    }

    private void RequestLatencyMetricInvalidValueHandling(FunctionMetricElementsListDTO element){
        if(element.getData().getResult().size() > 0){
            if("NaN".equals(element.getData().getResult().get(0).getValue().get(1)) || "Inf".equals(element.getData().getResult().get(0).getValue().get(1))
                    || "-Inf".equals(element.getData().getResult().get(0).getValue().get(1)) || "+Inf".equals(element.getData().getResult().get(0).getValue().get(1))){
                element.getData().getResult().get(0).getValue().set(1, "0");
            }
        }
    }

    private void getEachMetricInstance(MetricRequest metricRequest) throws IOException {

        metricRequest.requestCountList.add(metricRequest.g.fromJson(getPrometheusMetric(metricRequest.url, generateQueryForRequestCount(metricRequest.functionName, metricRequest.timeRange, metricRequest.queryTiming)), FunctionMetricElementsListDTO.class));
        metricRequest.requestLatencyList.add(metricRequest.g.fromJson(getPrometheusMetric(metricRequest.url, generateQueryForRequestLatency(metricRequest.functionName, metricRequest.timeRange, metricRequest.queryTiming)), FunctionMetricElementsListDTO.class));
        metricRequest.functionMemoryList.add(metricRequest.g.fromJson(getPrometheusMetric(metricRequest.url, generateQueryForFunctionMemory(metricRequest.functionName, metricRequest.timeRange, metricRequest.queryTiming)), FunctionMetricElementsListDTO.class));

        metricRequest.actualPodsList.add(metricRequest.g.fromJson(getPrometheusMetric(metricRequest.url, generateQueryForActualPods(metricRequest.functionName, metricRequest.timeRange, metricRequest.queryTiming)), FunctionMetricElementsListDTO.class));
        metricRequest.successCountList.add(metricRequest.g.fromJson(getPrometheusMetric(metricRequest.url, generateQueryForSuccessCount(metricRequest.functionName, metricRequest.timeRange, metricRequest.queryTiming)), FunctionMetricElementsListDTO.class));
        metricRequest.failCountList.add(metricRequest.g.fromJson(getPrometheusMetric(metricRequest.url, generateQueryForFailCount(metricRequest.functionName, metricRequest.timeRange, metricRequest.queryTiming)), FunctionMetricElementsListDTO.class));
    }

    public FunctionBillingMetricDTO getBillingMetric(String metricType, String date) throws IOException, ParseException {
        URL url = new URL(prometheusHttpApi);
        Gson g = new Gson();

        SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");
        Calendar cal = Calendar.getInstance();
        cal.setTime(format.parse(date));
        String queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);

        StringBuilder query = new StringBuilder();

        JSONObject prometheusReturn;
        List<FunctionBillingElementsDTO> functionMetricList = new ArrayList<>();
        FunctionBillingMetricDTO response = new FunctionBillingMetricDTO();

        List<Function> functionList = functionRepository.findAll();
        for(Function f : functionList){
            query.delete(0, query.length());
            if("requestCount".equals(metricType)){
                query.append("query=sum(increase(activator_request_count{service_name=\"").append(f.getName()).append("\"}[1d]))&time=").append(queryTiming);
            }else{
                query.append("query=sum(sum_over_time(container_memory_working_set_bytes{pod=~\"").append(f.getName()).append("-.*\", container=\"user-container\"}[1d]))/1024/1024/1024*60&time=").append(queryTiming);
            }
            prometheusReturn = new JSONObject(getPrometheusMetric(url, query.toString()));
            prometheusReturn.put("functionKey", f.getFunctionKey());
            functionMetricList.add(g.fromJson(prometheusReturn.toString(), FunctionBillingElementsDTO.class));
        }
        response.setMetric(functionMetricList);
        return response;
    }

    private String getPrometheusMetric(URL url, String query) throws IOException {
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        connection.setConnectTimeout(timeOutValue);
        connection.setReadTimeout(timeOutValue);
        connection.setRequestMethod("POST");
        connection.setDoOutput(true);
        DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream());
        outputStream.writeBytes(query);
        outputStream.flush();
        outputStream.close();

        if(connection.getResponseCode()== HttpURLConnection.HTTP_OK ){
            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            StringBuffer stringBuffer = new StringBuffer();

            String inputLine;
            while ((inputLine = bufferedReader.readLine()) != null)  {
                stringBuffer.append(inputLine);
            }
            bufferedReader.close();
            return stringBuffer.toString();
        }
        return null;
    }

    public FunctionMetricDTO getCloudMonitoringMetric(String functionKey, String range) throws IOException{
        URL url = new URL(prometheusHttpApi);

        Function function = functionRepository.findByFunctionKey(functionKey).orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
        String functionName = function.getName();
        String queryTiming = "";

        Calendar cal = Calendar.getInstance();
        queryTiming = String.valueOf(new Date(cal.getTimeInMillis()).getTime() / 1000L);

        Gson g = new Gson();

        FunctionMetricDTO output = new FunctionMetricDTO();
        FunctionMetricElementsListDTO requestLatency;

        output.setRequestCount(g.fromJson(getPrometheusMetric(url, generateQueryForRequestCount(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        requestLatency = g.fromJson(getPrometheusMetric(url, generateQueryForRequestLatency(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class);
        output.setFunctionMemory(g.fromJson(getPrometheusMetric(url, generateQueryForFunctionMemory(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        output.setActualPods(g.fromJson(getPrometheusMetric(url, generateQueryForActualPods(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        output.setSuccessCount(g.fromJson(getPrometheusMetric(url, generateQueryForSuccessCount(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));
        output.setFailCount(g.fromJson(getPrometheusMetric(url, generateQueryForFailCount(functionName, range, queryTiming)), FunctionMetricElementsListDTO.class));

        // requestLatency invalid 값 처리 (NaN, Inf)
        RequestLatencyMetricInvalidValueHandling(requestLatency);

        output.setRequestLatency(requestLatency);

        return output;
    }
}


