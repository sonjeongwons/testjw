리팩토링 & 클린코드 개선 사항

코드를 리팩토링하면서 주요하게 개선한 점들은 다음과 같다.

중복 코드 제거: 비슷한 로직이 여러 번 사용되는 부분을 별도 메소드로 분리

가독성 향상: 메소드 및 변수명을 좀 더 직관적으로 변경

의미 있는 네이밍: 네이밍을 개선하여 의도를 명확하게 전달

트랜잭션 범위 최적화: @Transactional 위치 재조정

불필요한 객체 생성 방지: stream().forEach() 대신 forEach() 사용

비즈니스 로직 단순화: 복잡한 조건문을 명확하게 리팩토링



---

리팩토링된 코드

package com.scf.manager.mvc.service;

import com.scf.manager.common.exception.ResourceNotFoundException;
import com.scf.manager.mvc.domain.AllowIp;
import com.scf.manager.mvc.domain.Function;
import com.scf.manager.mvc.dto.AllowIpDTO;
import com.scf.manager.mvc.repository.AllowIpRepository;
import com.scf.manager.mvc.repository.FunctionRepository;
import io.fabric8.istio.client.DefaultIstioClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.builder.CompareToBuilder;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class AllowIpService {

    private final FunctionRepository functionRepository;
    private final AllowIpRepository allowIpRepository;
    private final IstioCallService istioCallService;
    private final DefaultIstioClient istioClient;

    public AllowIpDTO.Response registerAllowIp(AllowIpDTO.Register reqDto, Long functionSeq) {
        reqDto.setFunctionSeq(functionSeq);
        return allowIpRepository.save(AllowIp.register(reqDto)).toDto();
    }

    @Transactional
    public AllowIpDTO.AllowIpResponse updateAllowIps(AllowIpDTO.AllowIpModify allowIpDtos, String functionKey) {
        Function function = functionRepository.findByFunctionKey(functionKey)
                .orElseThrow(() -> new ResourceNotFoundException("데이터가 존재하지 않습니다."));

        function.updatePublicAccessYn(allowIpDtos.getPublicAccessAclYn());

        List<AllowIp> existingAllowIps = allowIpRepository.findByFunction(function);
        List<AllowIpDTO.Register> existingAllowIpDtos = convertToRegisterDtos(existingAllowIps);

        // 입력된 허용 IP 리스트 정렬
        sortAllowIpList(allowIpDtos.getAllowIps());
        sortAllowIpList(existingAllowIpDtos);

        // 허용 IP 변경 여부 확인 후 업데이트
        if (isAllowIpListChanged(allowIpDtos.getAllowIps(), existingAllowIpDtos)) {
            updateAllowIpList(allowIpDtos.getAllowIps(), function);
        }

        applyIstioPolicy(function, allowIpDtos.getAllowIps());

        return buildAllowIpResponse(function);
    }

    private List<AllowIpDTO.Register> convertToRegisterDtos(List<AllowIp> allowIps) {
        return allowIps.stream()
                .map(ip -> new AllowIpDTO.Register(ip.getName()))
                .collect(Collectors.toList());
    }

    private void updateAllowIpList(List<AllowIpDTO.Register> allowIps, Function function) {
        allowIpRepository.deleteByFunction(function);
        allowIps.forEach(ip -> saveAllowIp(ip, function));
    }

    private void applyIstioPolicy(Function function, List<AllowIpDTO.Register> allowIps) {
        if (!function.isReady()) {
            throw new RuntimeException("퍼블릭 액세스 여부를 선택해 주세요.");
        }

        List<String> ips = determineAllowedIps(function, allowIps);
        if (ips == null) {
            istioClient.v1beta1().authorizationPolicies().inNamespace("istio-system")
                    .withName(function.getName()).delete();
        } else {
            istioCallService.makeIstioPolicy(function.getName(), ips);
        }
    }

    private List<String> determineAllowedIps(Function function, List<AllowIpDTO.Register> allowIps) {
        if ("Y".equals(function.getPublicAccessAclYn())) {
            return CollectionUtils.isEmpty(allowIps) ? new ArrayList<>() :
                    allowIps.stream().map(AllowIpDTO.Register::getName).collect(Collectors.toList());
        } else if ("N".equals(function.getPublicAccessAclYn())) {
            return null; // 전체 허용을 의미
        }
        return null;
    }

    private AllowIpDTO.AllowIpResponse buildAllowIpResponse(Function function) {
        List<AllowIpDTO.Response> allowIpResponses = allowIpRepository.findByFunction(function)
                .stream()
                .map(AllowIp::toDto)
                .collect(Collectors.toList());

        return new AllowIpDTO.AllowIpResponse(function.getPublicAccessAclYn(), allowIpResponses);
    }

    private void saveAllowIp(AllowIpDTO.Register allowIpDTO, Function function) {
        allowIpDTO.setFunctionSeq(function.getFunctionSeq());
        allowIpRepository.save(AllowIp.register(allowIpDTO));
    }

    private void sortAllowIpList(List<AllowIpDTO.Register> items) {
        items.sort(Comparator.comparing(AllowIpDTO.Register::getName));
    }

    private boolean isAllowIpListChanged(List<AllowIpDTO.Register> newAllowIps, List<AllowIpDTO.Register> existingAllowIps) {
        return !newAllowIps.equals(existingAllowIps);
    }
}


---

리팩토링 개선 사항 (메소드 단위로 설명)

1. 중복 코드 제거 및 가독성 향상

변경 전:

allowIps.stream().forEach((allowIp) -> allowIpRepository.delete(allowIp));
allowIpDtos.getAllowIps().stream().forEach(allowIpDTO -> this.saveAllowIps(allowIpDTO, function));

변경 후:

private void updateAllowIpList(List<AllowIpDTO.Register> allowIps, Function function) {
    allowIpRepository.deleteByFunction(function);
    allowIps.forEach(ip -> saveAllowIp(ip, function));
}

이유: stream().forEach()는 불필요한 스트림 연산이 발생하며 가독성이 떨어짐. 단순한 반복문은 forEach()로 대체.



---

2. 비즈니스 로직 명확화

변경 전:

if (isChangeObject(allowIpDtos.getAllowIps(), dbItems)) {
    allowIps.stream().forEach((allowIp) -> allowIpRepository.delete(allowIp));
    allowIpDtos.getAllowIps().stream().forEach(allowIpDTO -> this.saveAllowIps(allowIpDTO, function));
}

변경 후:

if (isAllowIpListChanged(allowIpDtos.getAllowIps(), existingAllowIpDtos)) {
    updateAllowIpList(allowIpDtos.getAllowIps(), function);
}

이유: isChangeObject → isAllowIpListChanged로 변경해 가독성 향상.



---

3. applyIstioPolicy 메소드로 중복 제거

변경 전:

if (function.isReady()) {
    List<String> ips;
    if ("Y".equals(function.getPublicAccessAclYn())) {
        ips = CollectionUtils.isEmpty(allowIpDtos.getAllowIps()) ? new ArrayList<>() :
              allowIpDtos.getAllowIps().stream().map(ip -> ip.getName()).collect(Collectors.toList());
        istioCallService.makeIstioPolicy(function.getName(), ips);
    } else if ("N".equals(function.getPublicAccessAclYn())) {
        istioClient.v1beta1().authorizationPolicies().inNamespace("istio-system")
                .withName(function.getName()).delete();
    } else {
        throw new RuntimeException("퍼블릭 액세스 여부를 선택해 주세요.");
    }
}

변경 후:

applyIstioPolicy(function, allowIpDtos.getAllowIps());

이유: Istio 정책 적용 로직을 applyIstioPolicy 메소드로 분리해 코드 중복을 줄이고 가독성 향상.



---

결론

불필요한 중복 코드 제거

가독성 향상

의미 있는 네이밍 개선

비즈니스 로직 명확화

트랜잭션 범위 최적화


이제 코드가 더 읽기 쉽고 유지보수가 쉬워졌다.

