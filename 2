Pull Request: FunctionMetricService 리팩토링 및 코드 품질 개선

📌 PR 개요

이번 PR에서는 FunctionMetricService 클래스의 코드 품질을 향상시키기 위해 리팩토링을 수행하였습니다.
클린 코드 원칙 (SOLID, DRY, KISS, YAGNI) 을 적용하여 중복 제거, 가독성 향상, 성능 개선, 유지보수성 향상을 목표로 개선하였습니다.

🛠 개발 내용

1. 중복 코드 제거 및 공통 로직 분리

PromQL을 생성하는 코드에서 공통 패턴을 추출하여 buildQuery 메소드를 도입

Prometheus API 호출 코드에서 불필요한 자원 관리 및 중복 코드 제거



2. 불필요한 객체 및 변수 제거

MetricRequest 내부 클래스에서 불필요한 필드 및 초기화 코드 정리



3. 가독성 및 유지보수성 향상

불필요한 replaceNextlineTabBlank 메소드 제거 및 정규식 적용

RequestLatencyMetricInvalidValueHandling을 handleInvalidLatencyValues로 변경하여 이름을 명확화



4. 성능 최적화

BufferedReader.lines()를 활용하여 응답 처리 속도 개선

Calendar 대신 Instant와 Duration을 사용하여 시간 계산 로직 단순화





---

🔍 메소드별 변경점과 개선사항

1️⃣ MetricRequest 클래스 리팩토링

변경 내용

private static class MetricRequest {
    URL url;
    String functionName;
    String queryTiming;
    Gson gson = new Gson();
    List<FunctionMetricElementsListDTO> requestCountList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> requestLatencyList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> functionMemoryList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> actualPodsList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> successCountList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> failCountList = new ArrayList<>();
    String timeRange;
}

개선 사항

내부 클래스를 static으로 선언하여 불필요한 외부 참조 방지

failCountList 초기화 추가 (new ArrayList<>())

Gson 객체를 필드 초기화에서 바로 생성 (gson 변수명 명확화)



---

2️⃣ replaceNextlineTabBlank → sanitizeQuery로 변경

변경 내용

private String sanitizeQuery(String query) {
    return query.replaceAll("[\\n\\t ]", "");
}

개선 사항

기존 방식 (replace("\n", "").replace("\t", "").replace(" ", "")) 대신 정규식 replaceAll("[\\n\\t ]", "") 적용

코드 가독성과 성능 개선

메소드명을 sanitizeQuery로 변경하여 명확한 의미 전달



---

3️⃣ PromQL 쿼리 생성 로직 개선 (buildQuery 추가)

변경 내용

private String buildQuery(String baseQuery, String functionName, String timeRange, String queryTiming) {
    String query = String.format(baseQuery, functionName, timeRange);
    return sanitizeQuery(query) + "&time=" + queryTiming;
}

public String generateQueryForRequestCount(String functionName, String timeRange, String queryTiming) {
    String queryTemplate = "query=sum(rate(activator_request_count{service_name=\"%s\"}[%sm]))*60*%s";
    return buildQuery(queryTemplate, functionName, timeRange, queryTiming);
}

개선 사항

String.format을 사용하여 가독성 및 유지보수성 향상

공통 패턴을 buildQuery로 분리하여 코드 중복 제거

모든 쿼리에 반복적으로 붙던 &time=$queryTiming$을 메소드 내부에서 자동 추가



---

4️⃣ Prometheus API 호출 최적화 (getPrometheusMetric 개선)

변경 내용

private String getPrometheusMetric(URL url, String query) throws IOException {
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    connection.setConnectTimeout(timeOutValue);
    connection.setReadTimeout(timeOutValue);
    connection.setRequestMethod("POST");
    connection.setDoOutput(true);

    try (DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream())) {
        outputStream.writeBytes(query);
    }

    if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
            return bufferedReader.lines().reduce("", (acc, line) -> acc + line);
        }
    }
    return null;
}

개선 사항

try-with-resources 적용 → 명시적 close() 호출 불필요

BufferedReader.lines().reduce()를 사용하여 간결한 코드 구현

불필요한 flush() 호출 제거 → try-with-resources에서 자동 처리



---

5️⃣ getMetricList 리팩토링

변경 내용

public FunctionMetricListDTO getMetricList(String functionKey, String time, String start, String end) throws IOException, ParseException {
    URL url = new URL(prometheusHttpApi);
    Function function = functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
    
    MetricRequest metricRequest = new MetricRequest();
    metricRequest.url = url;
    metricRequest.functionName = function.getName();
    
    int iterationCount;
    int timeUnit;
    
    if (METRIC_TIME_RANGE_1_HOUR.equals(time)) {
        iterationCount = 3;
        timeUnit = 15;
    } else if (METRIC_TIME_RANGE_3_HOUR.equals(time)) {
        iterationCount = 5;
        timeUnit = 30;
    } else if (METRIC_TIME_RANGE_12_HOUR.equals(time)) {
        iterationCount = 3;
        timeUnit = 180;
    } else {
        iterationCount = (int) Duration.between(parseDate(start), parseDate(end)).toDays();
        timeUnit = 1440;
    }

    fetchMetrics(metricRequest, iterationCount, timeUnit);

    for (FunctionMetricElementsListDTO element : metricRequest.requestLatencyList) {
        handleInvalidLatencyValues(element);
    }

    return createMetricListResponse(metricRequest);
}

개선 사항

반복문 로직을 fetchMetrics 메소드로 분리 → 중복 제거

Calendar 대신 Instant와 Duration 사용 → 가독성 향상

응답 객체 생성 로직을 createMetricListResponse로 분리 → SRP 적용

parseDate 메소드 추가 → 중복 제거 및 코드 가독성 향상



---

6️⃣ handleInvalidLatencyValues 추가

변경 내용

private void handleInvalidLatencyValues(FunctionMetricElementsListDTO element) {
    if (element.getData().getResult().isEmpty()) {
        return;
    }

    List<String> invalidValues = List.of("NaN", "Inf", "-Inf", "+Inf");
    String currentValue = element.getData().getResult().get(0).getValue().get(1);

    if (invalidValues.contains(currentValue)) {
        element.getData().getResult().get(0).getValue().set(1, "0");
    }
}

개선 사항

isEmpty()를 사용하여 리스트의 크기 검증 → 가독성 향상

"NaN", "Inf", "-Inf", "+Inf" 값을 List.of()로 변환하여 contains() 체크 → 더 간결한 코드 작성

Early Return 적용 → 불필요한 연산 방지



---

🎯 기대 효과

✅ 중복 코드 제거
✅ 가독성 및 유지보수성 향상
✅ API 호출 최적화로 성능 개선
✅ 리팩토링을 통해 더 안정적인 코드 구현

이번 PR을 통해 FunctionMetricService의 품질을 개선하였으며, 이후 유지보수 비용이 절감될 것으로 기대됩니다. 🚀

