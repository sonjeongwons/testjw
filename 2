코드 리팩토링을 진행하며 클린 코드 원칙(SOLID, DRY, KISS, YAGNI 등)을 적용하고, 코드의 가독성, 유지보수성, 성능을 개선하겠습니다.
주요 개선 사항을 메소드 단위로 설명하고, 각각의 변경 이유를 상세히 설명하겠습니다.


---

1. 개선된 코드

변경된 코드와 함께 주요 개선 사항을 설명합니다.

(1) MetricRequest 내부 클래스를 static으로 변경

private static class MetricRequest {
    URL url;
    String functionName;
    String queryTiming;
    Gson gson = new Gson();
    List<FunctionMetricElementsListDTO> requestCountList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> requestLatencyList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> functionMemoryList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> actualPodsList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> successCountList = new ArrayList<>();
    List<FunctionMetricElementsListDTO> failCountList;
    String timeRange;
}

개선 이유

MetricRequest 내부 필드 초기화를 생성자 없이 필드에서 바로 수행 → 불필요한 코드 제거

static 클래스화하여 불필요한 외부 클래스 참조를 방지

g라는 애매한 변수명을 gson으로 명확히 변경

failCountList가 초기화되지 않았으므로 명시적으로 new ArrayList<>()로 초기화



---

(2) replaceNextlineTabBlank 메소드 개선

private String sanitizeQuery(String query) {
    return query.replaceAll("[\\n\\t ]", "");
}

개선 이유

정규식 replaceAll("[\\n\\t ]", "")을 사용하여 불필요한 개행, 공백, 탭을 한 번에 처리 → 성능 향상

메소드명을 sanitizeQuery로 변경하여 의미 명확화



---

(3) PromQL 생성 메소드 개선

기존 문제점

1. $변수$ 치환 방식이 유지보수에 불리함 → String.format 적용


2. replaceNextlineTabBlank() 메소드가 필요 이상으로 호출됨


3. &time=$queryTiming$가 모든 쿼리에 포함되므로 중복 제거 가능



개선된 코드

private String buildQuery(String baseQuery, String functionName, String timeRange, String queryTiming) {
    String query = String.format(baseQuery, functionName, timeRange);
    return sanitizeQuery(query) + "&time=" + queryTiming;
}

public String generateQueryForRequestCount(String functionName, String timeRange, String queryTiming) {
    String queryTemplate = "query=sum(rate(activator_request_count{service_name=\"%s\"}[%sm]))*60*%s";
    return buildQuery(queryTemplate, functionName, timeRange, queryTiming);
}

개선 이유

String.format을 사용하여 가독성 및 유지보수성 향상

중복된 &time=$queryTiming$을 메소드에서 자동으로 추가

모든 쿼리 생성 로직을 buildQuery로 통합하여 중복 제거



---

(4) getPrometheusMetric 메소드 개선

기존 문제점

DataOutputStream을 굳이 사용할 필요 없음

BufferedReader를 간결하게 변환 가능


개선된 코드

private String getPrometheusMetric(URL url, String query) throws IOException {
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    connection.setConnectTimeout(timeOutValue);
    connection.setReadTimeout(timeOutValue);
    connection.setRequestMethod("POST");
    connection.setDoOutput(true);

    try (DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream())) {
        outputStream.writeBytes(query);
    }

    if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(connection.getInputStream()))) {
            return bufferedReader.lines().reduce("", (acc, line) -> acc + line);
        }
    }
    return null;
}

개선 이유

try-with-resources 사용 → 명시적 close() 호출 불필요

BufferedReader.lines().reduce() 사용 → 간결한 코드 구현

DataOutputStream의 flush() 호출 불필요 → 자동으로 처리됨



---

(5) getMetricList 메소드 개선

기존 문제점

MetricRequest 객체를 매번 생성하는데 불필요한 필드가 많음

Calendar를 사용하여 Date 변환을 반복 → Instant와 Duration을 사용하면 간결화 가능

중복된 반복문을 메소드로 분리


개선된 코드

public FunctionMetricListDTO getMetricList(String functionKey, String time, String start, String end) throws IOException, ParseException {
    URL url = new URL(prometheusHttpApi);
    Function function = functionRepository.findByFunctionKey(functionKey)
            .orElseThrow(() -> new RuntimeException("존재하지 않는 펑션입니다."));
    
    MetricRequest metricRequest = new MetricRequest();
    metricRequest.url = url;
    metricRequest.functionName = function.getName();
    
    int iterationCount;
    int timeUnit;
    
    if (METRIC_TIME_RANGE_1_HOUR.equals(time)) {
        iterationCount = 3;
        timeUnit = 15;
    } else if (METRIC_TIME_RANGE_3_HOUR.equals(time)) {
        iterationCount = 5;
        timeUnit = 30;
    } else if (METRIC_TIME_RANGE_12_HOUR.equals(time)) {
        iterationCount = 3;
        timeUnit = 180;
    } else {
        iterationCount = (int) Duration.between(parseDate(start), parseDate(end)).toDays();
        timeUnit = 1440;
    }

    fetchMetrics(metricRequest, iterationCount, timeUnit);

    for (FunctionMetricElementsListDTO element : metricRequest.requestLatencyList) {
        handleInvalidLatencyValues(element);
    }

    return createMetricListResponse(metricRequest);
}

private Instant parseDate(String date) throws ParseException {
    return new SimpleDateFormat("yyyyMMdd").parse(date).toInstant();
}

private void fetchMetrics(MetricRequest metricRequest, int iterationCount, int timeUnit) throws IOException {
    metricRequest.timeRange = String.valueOf(timeUnit);
    for (int i = 0; i <= iterationCount; i++) {
        metricRequest.queryTiming = String.valueOf(Instant.now().minus(Duration.ofMinutes(timeUnit * i)).getEpochSecond());
        getEachMetricInstance(metricRequest);
    }
}

private FunctionMetricListDTO createMetricListResponse(MetricRequest metricRequest) {
    return new FunctionMetricListDTO(
            metricRequest.requestCountList,
            metricRequest.requestLatencyList,
            metricRequest.functionMemoryList,
            metricRequest.actualPodsList,
            metricRequest.successCountList,
            metricRequest.failCountList
    );
}

개선 이유

반복문 로직을 fetchMetrics 메소드로 분리 → 중복 제거

Calendar 대신 Instant와 Duration 사용 → 가독성 향상

응답 객체 생성 로직을 createMetricListResponse로 분리 → SRP 적용

parseDate 메소드 추가 → 중복 제거 및 코드 가독성 향상



---

2. 최종적인 개선 요약


---

이제 코드가 더 직관적이고 유지보수하기 쉬운 형태로 정리되었습니다.
이런 리팩토링이 실제 운영 시스템에서도 적용될 수 있도록 지속적인 코드 개선이 필요합니다.

