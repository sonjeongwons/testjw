Pull Request: AllowIpService 코드 리팩토링 및 클린 코드 적용

PR 개요

이번 PR에서는 AllowIpService의 코드 품질을 개선하고 유지보수성을 향상시키기 위해 중복 코드 제거, 역할 분리, 메소드 추출, 가독성 향상, 불필요한 객체 생성 방지 등을 수행하였습니다.
또한, AllowIpRepository에서 특정 Function과 연관된 AllowIp 데이터를 삭제하는 메소드 (deleteByFunction)를 추가하여 데이터 정합성을 유지하면서 명확한 역할을 수행하도록 개선하였습니다.


---

개발 내용

1. 주요 리팩토링 내용

메소드 크기 축소 및 역할 분리

메소드가 단일 책임을 갖도록 리팩토링하여 유지보수성을 높임.

applyIstioPolicy, updateAllowIpList, convertToRegisterDtos, determineAllowedIps 등의 메소드로 세분화하여 가독성을 개선.


중복 코드 제거 및 성능 개선

기존 stream().forEach()에서 단순한 반복문을 forEach()로 변경하여 불필요한 스트림 연산 제거.

deleteByFunction 메소드를 AllowIpRepository에 추가하여 반복적인 삭제 로직을 단순화.


클린 코드 적용

List.sort(Comparator.comparing(...))을 활용하여 Collections.sort()를 개선.

메소드 네이밍을 의미 있게 변경 (isChangeObject → isAllowIpListChanged).

null 반환을 명확한 의미를 갖도록 변경 (determineAllowedIps 메소드 활용).


트랜잭션 범위 최적화

deleteByFunction을 트랜잭션 처리하도록 @Transactional 적용.

updateAllowIps에서 필요 이상의 데이터 조작을 줄이고 변경 사항이 있을 때만 실행.




---

2. 개선된 소스코드

AllowIpService 리팩토링 코드

package com.scf.manager.mvc.service;

import com.scf.manager.common.exception.ResourceNotFoundException;
import com.scf.manager.mvc.domain.AllowIp;
import com.scf.manager.mvc.domain.Function;
import com.scf.manager.mvc.dto.AllowIpDTO;
import com.scf.manager.mvc.repository.AllowIpRepository;
import com.scf.manager.mvc.repository.FunctionRepository;
import io.fabric8.istio.client.DefaultIstioClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@org.springframework.stereotype.Service
@RequiredArgsConstructor
public class AllowIpService {

    private final FunctionRepository functionRepository;
    private final AllowIpRepository allowIpRepository;
    private final IstioCallService istioCallService;
    private final DefaultIstioClient istioClient;

    public AllowIpDTO.Response registerAllowIp(AllowIpDTO.Register reqDto, Long functionSeq) {
        reqDto.setFunctionSeq(functionSeq);
        return allowIpRepository.save(AllowIp.register(reqDto)).toDto();
    }

    @Transactional
    public AllowIpDTO.AllowIpResponse updateAllowIps(AllowIpDTO.AllowIpModify allowIpDtos, String functionKey) {
        Function function = functionRepository.findByFunctionKey(functionKey)
                .orElseThrow(() -> new ResourceNotFoundException("데이터가 존재하지 않습니다."));

        function.updatePublicAccessYn(allowIpDtos.getPublicAccessAclYn());

        List<AllowIp> existingAllowIps = allowIpRepository.findByFunction(function);
        List<AllowIpDTO.Register> existingAllowIpDtos = convertToRegisterDtos(existingAllowIps);

        sortAllowIpList(allowIpDtos.getAllowIps());
        sortAllowIpList(existingAllowIpDtos);

        if (isAllowIpListChanged(allowIpDtos.getAllowIps(), existingAllowIpDtos)) {
            updateAllowIpList(allowIpDtos.getAllowIps(), function);
        }

        applyIstioPolicy(function, allowIpDtos.getAllowIps());

        return buildAllowIpResponse(function);
    }

    private List<AllowIpDTO.Register> convertToRegisterDtos(List<AllowIp> allowIps) {
        return allowIps.stream()
                .map(ip -> new AllowIpDTO.Register(ip.getName()))
                .collect(Collectors.toList());
    }

    private void updateAllowIpList(List<AllowIpDTO.Register> allowIps, Function function) {
        allowIpRepository.deleteByFunction(function);
        allowIps.forEach(ip -> saveAllowIp(ip, function));
    }

    private void applyIstioPolicy(Function function, List<AllowIpDTO.Register> allowIps) {
        if (!function.isReady()) {
            throw new RuntimeException("퍼블릭 액세스 여부를 선택해 주세요.");
        }

        List<String> ips = determineAllowedIps(function, allowIps);
        if (ips == null) {
            istioClient.v1beta1().authorizationPolicies().inNamespace("istio-system")
                    .withName(function.getName()).delete();
        } else {
            istioCallService.makeIstioPolicy(function.getName(), ips);
        }
    }

    private List<String> determineAllowedIps(Function function, List<AllowIpDTO.Register> allowIps) {
        if ("Y".equals(function.getPublicAccessAclYn())) {
            return CollectionUtils.isEmpty(allowIps) ? new ArrayList<>() :
                    allowIps.stream().map(AllowIpDTO.Register::getName).collect(Collectors.toList());
        } else if ("N".equals(function.getPublicAccessAclYn())) {
            return null;
        }
        return null;
    }

    private AllowIpDTO.AllowIpResponse buildAllowIpResponse(Function function) {
        List<AllowIpDTO.Response> allowIpResponses = allowIpRepository.findByFunction(function)
                .stream()
                .map(AllowIp::toDto)
                .collect(Collectors.toList());

        return new AllowIpDTO.AllowIpResponse(function.getPublicAccessAclYn(), allowIpResponses);
    }

    private void saveAllowIp(AllowIpDTO.Register allowIpDTO, Function function) {
        allowIpDTO.setFunctionSeq(function.getFunctionSeq());
        allowIpRepository.save(AllowIp.register(allowIpDTO));
    }

    private void sortAllowIpList(List<AllowIpDTO.Register> items) {
        items.sort((o1, o2) -> o1.getName().compareTo(o2.getName()));
    }

    private boolean isAllowIpListChanged(List<AllowIpDTO.Register> newAllowIps, List<AllowIpDTO.Register> existingAllowIps) {
        return !newAllowIps.equals(existingAllowIps);
    }
}


---

3. 메소드별 변경점 및 개선 사항


---

PR 결론

이번 리팩토링을 통해 유지보수성과 코드의 가독성이 크게 향상되었으며, 중복 코드 제거 및 역할 분리를 통해 효율성을 개선하였습니다. AllowIpRepository의 deleteByFunction을 추가함으로써 데이터 정합성을 유지하면서도 보다 직관적인 코드 작성을 할 수 있었습니다.

